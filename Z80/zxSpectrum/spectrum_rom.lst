# file opened: spectrum_rom.asm
    1 0000
    2 0000              ;************************************************************************
    3 0000              ;** An Assembly File Listing to generate a 16K ROM for the ZX Spectrum **
    4 0000              ;************************************************************************
    5 0000
    6 0000              ; -------------------------
    7 0000              ; Last updated: 13-DEC-2004
    8 0000              ; -------------------------
    9 0000
   10 0000              ; TASM cross-assembler directives.
   11 0000              ; ( comment out, perhaps, for other assemblers - see Notes at end.)
   12 0000
spectrum_rom.asm(13): error: Invalid labelname: #define
   13 0000 00           #define DEFB .BYTE
spectrum_rom.asm(14): error: Invalid labelname: #define
   14 0001 00 00        #define DEFW .WORD
spectrum_rom.asm(15): error: Invalid labelname: #define
   15 0003 00           #define DEFM .TEXT
spectrum_rom.asm(16): error: Invalid labelname: #define
   16 0004              #define ORG  .ORG
spectrum_rom.asm(17): error: Label not found: _.EQU
spectrum_rom.asm(17): error: Invalid labelname: #define
   17 0000              #define EQU  .EQU
spectrum_rom.asm(18): error: Label not found: _.EQU
spectrum_rom.asm(18): error: Invalid labelname: #define
   18 0000              #define equ  .EQU
   19 0000
   20 0000              ;   It is always a good idea to anchor, using ORGs, important sections such as
   21 0000              ;   the character bitmaps so that they don't move as code is added and removed.
   22 0000
   23 0000              ;   Generally most approaches try to maintain main entry points as they are
   24 0000              ;   often used by third-party software.
   25 0000
spectrum_rom.asm(26): warning: Label has different value in pass 3: previous value 15616 not equal 0
spectrum_rom.asm(26): error: Unrecognized instruction: 0000
   26 0000              ORG 0000
   27 0000
   28 0000              ;*****************************************
   29 0000              ;** Part 1. RESTART ROUTINES AND TABLES **
   30 0000              ;*****************************************
   31 0000
   32 0000              ; -----------
   33 0000              ; THE 'START'
   34 0000              ; -----------
   35 0000              ;   At switch on, the Z80 chip is in Interrupt Mode 0.
   36 0000              ;   The Spectrum uses Interrupt Mode 1.
   37 0000              ;   This location can also be 'called' to reset the machine.
   38 0000              ;   Typically with PRINT USR 0.
   39 0000
   40 0000              ;; START
   41 0000 F3           L0000:  DI                      ; Disable Interrupts.
   42 0001 AF                   XOR     A               ; Signal coming from START.
   43 0002 11 FF FF             LD      DE,$FFFF        ; Set pointer to top of possible physical RAM.
   44 0005 C3 CB 11             JP      L11CB           ; Jump forward to common code at START-NEW.
   45 0008
   46 0008              ; -------------------
   47 0008              ; THE 'ERROR' RESTART
   48 0008              ; -------------------
   49 0008              ;   The error pointer is made to point to the position of the error to enable
   50 0008              ;   the editor to highlight the error position if it occurred during syntax
   51 0008              ;   checking.  It is used at 37 places in the program.  An instruction fetch
   52 0008              ;   on address $0008 may page in a peripheral ROM such as the Sinclair
   53 0008              ;   Interface 1 or Disciple Disk Interface.  This was not an original design
   54 0008              ;   concept and not all errors pass through here.
   55 0008
   56 0008              ;; ERROR-1
   57 0008 2A 5D 5C     L0008:  LD      HL,($5C5D)      ; Fetch the character address from CH_ADD.
   58 000B 22 5F 5C             LD      ($5C5F),HL      ; Copy it to the error pointer X_PTR.
   59 000E 18 43                JR      L0053           ; Forward to continue at ERROR-2.
   60 0010
   61 0010              ; -----------------------------
   62 0010              ; THE 'PRINT CHARACTER' RESTART
   63 0010              ; -----------------------------
   64 0010              ;   The A register holds the code of the character that is to be sent to
   65 0010              ;   the output stream of the current channel.  The alternate register set is
   66 0010              ;   used to output a character in the A register so there is no need to
   67 0010              ;   preserve any of the current main registers (HL, DE, BC).
   68 0010              ;   This restart is used 21 times.
   69 0010
   70 0010              ;; PRINT-A
   71 0010 C3 F2 15     L0010:  JP      L15F2           ; Jump forward to continue at PRINT-A-2.
   72 0013
   73 0013              ; ---
   74 0013
   75 0013 FF FF FF             DEFB    $FF, $FF, $FF   ; Five unused locations.
   76 0016 FF FF                DEFB    $FF, $FF        ;
   77 0018
   78 0018              ; -------------------------------
   79 0018              ; THE 'COLLECT CHARACTER' RESTART
   80 0018              ; -------------------------------
   81 0018              ;   The contents of the location currently addressed by CH_ADD are fetched.
   82 0018              ;   A return is made if the value represents a character that has
   83 0018              ;   relevance to the BASIC parser. Otherwise CH_ADD is incremented and the
   84 0018              ;   tests repeated. CH_ADD will be addressing somewhere -
   85 0018              ;   1) in the BASIC program area during line execution.
   86 0018              ;   2) in workspace if evaluating, for example, a string expression.
   87 0018              ;   3) in the edit buffer if parsing a direct command or a new BASIC line.
   88 0018              ;   4) in workspace if accepting input but not that from INPUT LINE.
   89 0018
   90 0018              ;; GET-CHAR
   91 0018 2A 5D 5C     L0018:  LD      HL,($5C5D)      ; fetch the address from CH_ADD.
   92 001B 7E                   LD      A,(HL)          ; use it to pick up current character.
   93 001C
   94 001C              ;; TEST-CHAR
   95 001C CD 7D 00     L001C:  CALL    L007D           ; routine SKIP-OVER tests if the character is
   96 001F                                              ; relevant.
   97 001F D0                   RET     NC              ; Return if it is significant.
   98 0020
   99 0020              ; ------------------------------------
  100 0020              ; THE 'COLLECT NEXT CHARACTER' RESTART
  101 0020              ; ------------------------------------
  102 0020              ;   As the BASIC commands and expressions are interpreted, this routine is
  103 0020              ;   called repeatedly to step along the line.  It is used 83 times.
  104 0020
  105 0020              ;; NEXT-CHAR
  106 0020 CD 74 00     L0020:  CALL    L0074           ; routine CH-ADD+1 fetches the next immediate
  107 0023                                              ; character.
  108 0023 18 F7                JR      L001C           ; jump back to TEST-CHAR until a valid
  109 0025                                              ; character is found.
  110 0025
  111 0025              ; ---
  112 0025
  113 0025 FF FF FF             DEFB    $FF, $FF, $FF   ; unused
  114 0028
  115 0028              ; -----------------------
  116 0028              ; THE 'CALCULATE' RESTART
  117 0028              ; -----------------------
  118 0028              ;   This restart enters the Spectrum's internal, floating-point, stack-based,
  119 0028              ;   FORTH-like language.
  120 0028              ;   It is further used recursively from within the calculator.
  121 0028              ;   It is used on 77 occasions.
  122 0028
  123 0028              ;; FP-CALC
  124 0028 C3 5B 33     L0028:  JP      L335B           ; jump forward to the CALCULATE routine.
  125 002B
  126 002B              ; ---
  127 002B
  128 002B FF FF FF             DEFB    $FF, $FF, $FF   ; spare - note that on the ZX81, space being a
  129 002E FF FF                DEFB    $FF, $FF        ; little cramped, these same locations were
  130 0030                                              ; used for the five-byte end-calc literal.
  131 0030
  132 0030              ; ------------------------------
  133 0030              ; THE 'CREATE BC SPACES' RESTART
  134 0030              ; ------------------------------
  135 0030              ;   This restart is used on only 12 occasions to create BC spaces
  136 0030              ;   between workspace and the calculator stack.
  137 0030
  138 0030              ;; BC-SPACES
  139 0030 C5           L0030:  PUSH    BC              ; Save number of spaces.
  140 0031 2A 61 5C             LD      HL,($5C61)      ; Fetch WORKSP.
  141 0034 E5                   PUSH    HL              ; Save address of workspace.
  142 0035 C3 9E 16             JP      L169E           ; Jump forward to continuation code RESERVE.
  143 0038
  144 0038              ; --------------------------------
  145 0038              ; THE 'MASKABLE INTERRUPT' ROUTINE
  146 0038              ; --------------------------------
  147 0038              ;   This routine increments the Spectrum's three-byte FRAMES counter fifty
  148 0038              ;   times a second (sixty times a second in the USA ).
  149 0038              ;   Both this routine and the called KEYBOARD subroutine use the IY register
  150 0038              ;   to access system variables and flags so a user-written program must
  151 0038              ;   disable interrupts to make use of the IY register.
  152 0038
  153 0038              ;; MASK-INT
  154 0038 F5           L0038:  PUSH    AF              ; Save the registers that will be used but not
  155 0039 E5                   PUSH    HL              ; the IY register unfortunately.
  156 003A 2A 78 5C             LD      HL,($5C78)      ; Fetch the first two bytes at FRAMES1.
  157 003D 23                   INC     HL              ; Increment lowest two bytes of counter.
  158 003E 22 78 5C             LD      ($5C78),HL      ; Place back in FRAMES1.
  159 0041 7C                   LD      A,H             ; Test if the result was zero.
  160 0042 B5                   OR      L               ;
  161 0043 20 03                JR      NZ,L0048        ; Forward, if not, to KEY-INT
  162 0045
  163 0045 FD 34 40             INC     (IY+$40)        ; otherwise increment FRAMES3 the third byte.
  164 0048
  165 0048              ;   Now save the rest of the main registers and read and decode the keyboard.
  166 0048
  167 0048              ;; KEY-INT
  168 0048 C5           L0048:  PUSH    BC              ; Save the other main registers.
  169 0049 D5                   PUSH    DE              ;
  170 004A
  171 004A CD BF 02             CALL    L02BF           ; Routine KEYBOARD executes a stage in the
  172 004D                                              ; process of reading a key-press.
  173 004D D1                   POP     DE              ;
  174 004E C1                   POP     BC              ; Restore registers.
  175 004F
  176 004F E1                   POP     HL              ;
  177 0050 F1                   POP     AF              ;
  178 0051
  179 0051 FB                   EI                      ; Enable Interrupts.
  180 0052 C9                   RET                     ; Return.
  181 0053
  182 0053              ; ---------------------
  183 0053              ; THE 'ERROR-2' ROUTINE
  184 0053              ; ---------------------
  185 0053              ;   A continuation of the code at 0008.
  186 0053              ;   The error code is stored and after clearing down stacks, an indirect jump
  187 0053              ;   is made to MAIN-4, etc. to handle the error.
  188 0053
  189 0053              ;; ERROR-2
  190 0053 E1           L0053:  POP     HL              ; drop the return address - the location
  191 0054                                              ; after the RST 08H instruction.
  192 0054 6E                   LD      L,(HL)          ; fetch the error code that follows.
  193 0055                                              ; (nice to see this instruction used.)
  194 0055
  195 0055              ;   Note. this entry point is used when out of memory at REPORT-4.
  196 0055              ;   The L register has been loaded with the report code but X-PTR is not
  197 0055              ;   updated.
  198 0055
  199 0055              ;; ERROR-3
  200 0055 FD 75 00     L0055:  LD      (IY+$00),L      ; Store it in the system variable ERR_NR.
  201 0058 ED 7B 3D 5C          LD      SP,($5C3D)      ; ERR_SP points to an error handler on the
  202 005C                                              ; machine stack. There may be a hierarchy
  203 005C                                              ; of routines.
  204 005C                                              ; To MAIN-4 initially at base.
  205 005C                                              ; or REPORT-G on line entry.
  206 005C                                              ; or  ED-ERROR when editing.
  207 005C                                              ; or   ED-FULL during ed-enter.
  208 005C                                              ; or  IN-VAR-1 during runtime input etc.
  209 005C
  210 005C C3 C5 16             JP      L16C5           ; Jump to SET-STK to clear the calculator stack
  211 005F                                              ; and reset MEM to usual place in the systems
  212 005F                                              ; variables area and then indirectly to MAIN-4,
  213 005F                                              ; etc.
  214 005F
  215 005F              ; ---
  216 005F
  217 005F FF FF FF             DEFB    $FF, $FF, $FF   ; Unused locations
  218 0062 FF FF FF             DEFB    $FF, $FF, $FF   ; before the fixed-position
  219 0065 FF                   DEFB    $FF             ; NMI routine.
  220 0066
  221 0066              ; ------------------------------------
  222 0066              ; THE 'NON-MASKABLE INTERRUPT' ROUTINE
  223 0066              ; ------------------------------------
  224 0066              ;
  225 0066              ;   There is no NMI switch on the standard Spectrum or its peripherals.
  226 0066              ;   When the NMI line is held low, then no matter what the Z80 was doing at
  227 0066              ;   the time, it will now execute the code at 66 Hex.
  228 0066              ;   This Interrupt Service Routine will jump to location zero if the contents
  229 0066              ;   of the system variable NMIADD are zero or return if the location holds a
  230 0066              ;   non-zero address.   So attaching a simple switch to the NMI as in the book
  231 0066              ;   "Spectrum Hardware Manual" causes a reset.  The logic was obviously
  232 0066              ;   intended to work the other way.  Sinclair Research said that, since they
  233 0066              ;   had never advertised the NMI, they had no plans to fix the error "until
  234 0066              ;   the opportunity arose".
  235 0066              ;
  236 0066              ;   Note. The location NMIADD was, in fact, later used by Sinclair Research
  237 0066              ;   to enhance the text channel on the ZX Interface 1.
  238 0066              ;   On later Amstrad-made Spectrums, and the Brazilian Spectrum, the logic of
  239 0066              ;   this routine was indeed reversed but not as at first intended.
  240 0066              ;
  241 0066              ;   It can be deduced by looking elsewhere in this ROM that the NMIADD system
  242 0066              ;   variable pointed to L121C and that this enabled a Warm Restart to be
  243 0066              ;   performed at any time, even while playing machine code games, or while
  244 0066              ;   another Spectrum has been allowed to gain control of this one.
  245 0066              ;
  246 0066              ;   Software houses would have been able to protect their games from attack by
  247 0066              ;   placing two zeros in the NMIADD system variable.
  248 0066
  249 0066              ;; RESET
  250 0066 F5           L0066:  PUSH    AF              ; save the
  251 0067 E5                   PUSH    HL              ; registers.
  252 0068 2A B0 5C             LD      HL,($5CB0)      ; fetch the system variable NMIADD.
  253 006B 7C                   LD      A,H             ; test address
  254 006C B5                   OR      L               ; for zero.
  255 006D
  256 006D 20 01                JR      NZ,L0070        ; skip to NO-RESET if NOT ZERO
  257 006F
  258 006F E9                   JP      (HL)            ; jump to routine ( i.e. L0000 )
  259 0070
  260 0070              ;; NO-RESET
  261 0070 E1           L0070:  POP     HL              ; restore the
  262 0071 F1                   POP     AF              ; registers.
  263 0072 ED 45                RETN                    ; return to previous interrupt state.
  264 0074
  265 0074              ; ---------------------------
  266 0074              ; THE 'CH ADD + 1' SUBROUTINE
  267 0074              ; ---------------------------
  268 0074              ;   This subroutine is called from RST 20, and three times from elsewhere
  269 0074              ;   to fetch the next immediate character following the current valid character
  270 0074              ;   address and update the associated system variable.
  271 0074              ;   The entry point TEMP-PTR1 is used from the SCANNING routine.
  272 0074              ;   Both TEMP-PTR1 and TEMP-PTR2 are used by the READ command routine.
  273 0074
  274 0074              ;; CH-ADD+1
  275 0074 2A 5D 5C     L0074:  LD      HL,($5C5D)      ; fetch address from CH_ADD.
  276 0077
  277 0077              ;; TEMP-PTR1
  278 0077 23           L0077:  INC     HL              ; increase the character address by one.
  279 0078
  280 0078              ;; TEMP-PTR2
  281 0078 22 5D 5C     L0078:  LD      ($5C5D),HL      ; update CH_ADD with character address.
  282 007B
  283 007B 7E           X007B:  LD      A,(HL)          ; load character to A from HL.
  284 007C C9                   RET                     ; and return.
  285 007D
  286 007D              ; --------------------------
  287 007D              ; THE 'SKIP OVER' SUBROUTINE
  288 007D              ; --------------------------
  289 007D              ;   This subroutine is called once from RST 18 to skip over white-space and
  290 007D              ;   other characters irrelevant to the parsing of a BASIC line etc. .
  291 007D              ;   Initially the A register holds the character to be considered
  292 007D              ;   and HL holds its address which will not be within quoted text
  293 007D              ;   when a BASIC line is parsed.
  294 007D              ;   Although the 'tab' and 'at' characters will not appear in a BASIC line,
  295 007D              ;   they could be present in a string expression, and in other situations.
  296 007D              ;   Note. although white-space is usually placed in a program to indent loops
  297 007D              ;   and make it more readable, it can also be used for the opposite effect and
  298 007D              ;   spaces may appear in variable names although the parser never sees them.
  299 007D              ;   It is this routine that helps make the variables 'Anum bEr5 3BUS' and
  300 007D              ;   'a number 53 bus' appear the same to the parser.
  301 007D
  302 007D              ;; SKIP-OVER
  303 007D FE 21        L007D:  CP      $21             ; test if higher than space.
  304 007F D0                   RET     NC              ; return with carry clear if so.
  305 0080
  306 0080 FE 0D                CP      $0D             ; carriage return ?
  307 0082 C8                   RET     Z               ; return also with carry clear if so.
  308 0083
  309 0083                                              ; all other characters have no relevance
  310 0083                                              ; to the parser and must be returned with
  311 0083                                              ; carry set.
  312 0083
  313 0083 FE 10                CP      $10             ; test if 0-15d
  314 0085 D8                   RET     C               ; return, if so, with carry set.
  315 0086
  316 0086 FE 18                CP      $18             ; test if 24-32d
  317 0088 3F                   CCF                     ; complement carry flag.
  318 0089 D8                   RET     C               ; return with carry set if so.
  319 008A
  320 008A                                              ; now leaves 16d-23d
  321 008A
  322 008A 23                   INC     HL              ; all above have at least one extra character
  323 008B                                              ; to be stepped over.
  324 008B
  325 008B FE 16                CP      $16             ; controls 22d ('at') and 23d ('tab') have two.
  326 008D 38 01                JR      C,L0090         ; forward to SKIPS with ink, paper, flash,
  327 008F                                              ; bright, inverse or over controls.
  328 008F                                              ; Note. the high byte of tab is for RS232 only.
  329 008F                                              ; it has no relevance on this machine.
  330 008F
  331 008F 23                   INC     HL              ; step over the second character of 'at'/'tab'.
  332 0090
  333 0090              ;; SKIPS
  334 0090 37           L0090:  SCF                     ; set the carry flag
  335 0091 22 5D 5C             LD      ($5C5D),HL      ; update the CH_ADD system variable.
  336 0094 C9                   RET                     ; return with carry set.
  337 0095
  338 0095
  339 0095              ; ------------------
  340 0095              ; THE 'TOKEN' TABLES
  341 0095              ; ------------------
  342 0095              ;   The tokenized characters 134d (RND) to 255d (COPY) are expanded using
  343 0095              ;   this table. The last byte of a token is inverted to denote the end of
  344 0095              ;   the word. The first is an inverted step-over byte.
  345 0095
  346 0095              ;; TKN-TABLE
  347 0095 BF           L0095:  DEFB    '?'+$80
  348 0096 52 4E                DEFM    "RN"
  349 0098 C4                   DEFB    'D'+$80
  350 0099 49 4E 4B 45          DEFM    "INKEY"
  350 009D 59
  351 009E A4                   DEFB    '$'+$80
  352 009F 50 C9                DEFB    'P','I'+$80
  353 00A1 46 CE                DEFB    'F','N'+$80
  354 00A3 50 4F 49 4E          DEFM    "POIN"
  355 00A7 D4                   DEFB    'T'+$80
  356 00A8 53 43 52 45          DEFM    "SCREEN"
  356 00AC 45 4E
  357 00AE A4                   DEFB    '$'+$80
  358 00AF 41 54 54             DEFM    "ATT"
  359 00B2 D2                   DEFB    'R'+$80
  360 00B3 41 D4                DEFB    'A','T'+$80
  361 00B5 54 41                DEFM    "TA"
  362 00B7 C2                   DEFB    'B'+$80
  363 00B8 56 41 4C             DEFM    "VAL"
  364 00BB A4                   DEFB    '$'+$80
  365 00BC 43 4F 44             DEFM    "COD"
  366 00BF C5                   DEFB    'E'+$80
  367 00C0 56 41                DEFM    "VA"
  368 00C2 CC                   DEFB    'L'+$80
  369 00C3 4C 45                DEFM    "LE"
  370 00C5 CE                   DEFB    'N'+$80
  371 00C6 53 49                DEFM    "SI"
  372 00C8 CE                   DEFB    'N'+$80
  373 00C9 43 4F                DEFM    "CO"
  374 00CB D3                   DEFB    'S'+$80
  375 00CC 54 41                DEFM    "TA"
  376 00CE CE                   DEFB    'N'+$80
  377 00CF 41 53                DEFM    "AS"
  378 00D1 CE                   DEFB    'N'+$80
  379 00D2 41 43                DEFM    "AC"
  380 00D4 D3                   DEFB    'S'+$80
  381 00D5 41 54                DEFM    "AT"
  382 00D7 CE                   DEFB    'N'+$80
  383 00D8 4C CE                DEFB    'L','N'+$80
  384 00DA 45 58                DEFM    "EX"
  385 00DC D0                   DEFB    'P'+$80
  386 00DD 49 4E                DEFM    "IN"
  387 00DF D4                   DEFB    'T'+$80
  388 00E0 53 51                DEFM    "SQ"
  389 00E2 D2                   DEFB    'R'+$80
  390 00E3 53 47                DEFM    "SG"
  391 00E5 CE                   DEFB    'N'+$80
  392 00E6 41 42                DEFM    "AB"
  393 00E8 D3                   DEFB    'S'+$80
  394 00E9 50 45 45             DEFM    "PEE"
  395 00EC CB                   DEFB    'K'+$80
  396 00ED 49 CE                DEFB    'I','N'+$80
  397 00EF 55 53                DEFM    "US"
  398 00F1 D2                   DEFB    'R'+$80
  399 00F2 53 54 52             DEFM    "STR"
  400 00F5 A4                   DEFB    '$'+$80
  401 00F6 43 48 52             DEFM    "CHR"
  402 00F9 A4                   DEFB    '$'+$80
  403 00FA 4E 4F                DEFM    "NO"
  404 00FC D4                   DEFB    'T'+$80
  405 00FD 42 49                DEFM    "BI"
  406 00FF CE                   DEFB    'N'+$80
  407 0100
  408 0100              ;   The previous 32 function-type words are printed without a leading space
  409 0100              ;   The following have a leading space if they begin with a letter
  410 0100
  411 0100 4F D2                DEFB    'O','R'+$80
  412 0102 41 4E                DEFM    "AN"
  413 0104 C4                   DEFB    'D'+$80
  414 0105 3C BD                DEFB    $3C,'='+$80             ; <=
  415 0107 3E BD                DEFB    $3E,'='+$80             ; >=
  416 0109 3C BE                DEFB    $3C,$3E+$80             ; <>
  417 010B 4C 49 4E             DEFM    "LIN"
  418 010E C5                   DEFB    'E'+$80
  419 010F 54 48 45             DEFM    "THE"
  420 0112 CE                   DEFB    'N'+$80
  421 0113 54 CF                DEFB    'T','O'+$80
  422 0115 53 54 45             DEFM    "STE"
  423 0118 D0                   DEFB    'P'+$80
  424 0119 44 45 46 20          DEFM    "DEF F"
  424 011D 46
  425 011E CE                   DEFB    'N'+$80
  426 011F 43 41                DEFM    "CA"
  427 0121 D4                   DEFB    'T'+$80
  428 0122 46 4F 52 4D          DEFM    "FORMA"
  428 0126 41
  429 0127 D4                   DEFB    'T'+$80
  430 0128 4D 4F 56             DEFM    "MOV"
  431 012B C5                   DEFB    'E'+$80
  432 012C 45 52 41 53          DEFM    "ERAS"
  433 0130 C5                   DEFB    'E'+$80
  434 0131 4F 50 45 4E          DEFM    "OPEN "
  434 0135 20
  435 0136 A3                   DEFB    '#'+$80
  436 0137 43 4C 4F 53          DEFM    "CLOSE "
  436 013B 45 20
  437 013D A3                   DEFB    '#'+$80
  438 013E 4D 45 52 47          DEFM    "MERG"
  439 0142 C5                   DEFB    'E'+$80
  440 0143 56 45 52 49          DEFM    "VERIF"
  440 0147 46
  441 0148 D9                   DEFB    'Y'+$80
  442 0149 42 45 45             DEFM    "BEE"
  443 014C D0                   DEFB    'P'+$80
  444 014D 43 49 52 43          DEFM    "CIRCL"
  444 0151 4C
  445 0152 C5                   DEFB    'E'+$80
  446 0153 49 4E                DEFM    "IN"
  447 0155 CB                   DEFB    'K'+$80
  448 0156 50 41 50 45          DEFM    "PAPE"
  449 015A D2                   DEFB    'R'+$80
  450 015B 46 4C 41 53          DEFM    "FLAS"
  451 015F C8                   DEFB    'H'+$80
  452 0160 42 52 49 47          DEFM    "BRIGH"
  452 0164 48
  453 0165 D4                   DEFB    'T'+$80
  454 0166 49 4E 56 45          DEFM    "INVERS"
  454 016A 52 53
  455 016C C5                   DEFB    'E'+$80
  456 016D 4F 56 45             DEFM    "OVE"
  457 0170 D2                   DEFB    'R'+$80
  458 0171 4F 55                DEFM    "OU"
  459 0173 D4                   DEFB    'T'+$80
  460 0174 4C 50 52 49          DEFM    "LPRIN"
  460 0178 4E
  461 0179 D4                   DEFB    'T'+$80
  462 017A 4C 4C 49 53          DEFM    "LLIS"
  463 017E D4                   DEFB    'T'+$80
  464 017F 53 54 4F             DEFM    "STO"
  465 0182 D0                   DEFB    'P'+$80
  466 0183 52 45 41             DEFM    "REA"
  467 0186 C4                   DEFB    'D'+$80
  468 0187 44 41 54             DEFM    "DAT"
  469 018A C1                   DEFB    'A'+$80
  470 018B 52 45 53 54          DEFM    "RESTOR"
  470 018F 4F 52
  471 0191 C5                   DEFB    'E'+$80
  472 0192 4E 45                DEFM    "NE"
  473 0194 D7                   DEFB    'W'+$80
  474 0195 42 4F 52 44          DEFM    "BORDE"
  474 0199 45
  475 019A D2                   DEFB    'R'+$80
  476 019B 43 4F 4E 54          DEFM    "CONTINU"
  476 019F 49 4E 55
  477 01A2 C5                   DEFB    'E'+$80
  478 01A3 44 49                DEFM    "DI"
  479 01A5 CD                   DEFB    'M'+$80
  480 01A6 52 45                DEFM    "RE"
  481 01A8 CD                   DEFB    'M'+$80
  482 01A9 46 4F                DEFM    "FO"
  483 01AB D2                   DEFB    'R'+$80
  484 01AC 47 4F 20 54          DEFM    "GO T"
  485 01B0 CF                   DEFB    'O'+$80
  486 01B1 47 4F 20 53          DEFM    "GO SU"
  486 01B5 55
  487 01B6 C2                   DEFB    'B'+$80
  488 01B7 49 4E 50 55          DEFM    "INPU"
  489 01BB D4                   DEFB    'T'+$80
  490 01BC 4C 4F 41             DEFM    "LOA"
  491 01BF C4                   DEFB    'D'+$80
  492 01C0 4C 49 53             DEFM    "LIS"
  493 01C3 D4                   DEFB    'T'+$80
  494 01C4 4C 45                DEFM    "LE"
  495 01C6 D4                   DEFB    'T'+$80
  496 01C7 50 41 55 53          DEFM    "PAUS"
  497 01CB C5                   DEFB    'E'+$80
  498 01CC 4E 45 58             DEFM    "NEX"
  499 01CF D4                   DEFB    'T'+$80
  500 01D0 50 4F 4B             DEFM    "POK"
  501 01D3 C5                   DEFB    'E'+$80
  502 01D4 50 52 49 4E          DEFM    "PRIN"
  503 01D8 D4                   DEFB    'T'+$80
  504 01D9 50 4C 4F             DEFM    "PLO"
  505 01DC D4                   DEFB    'T'+$80
  506 01DD 52 55                DEFM    "RU"
  507 01DF CE                   DEFB    'N'+$80
  508 01E0 53 41 56             DEFM    "SAV"
  509 01E3 C5                   DEFB    'E'+$80
  510 01E4 52 41 4E 44          DEFM    "RANDOMIZ"
  510 01E8 4F 4D 49 5A
  511 01EC C5                   DEFB    'E'+$80
  512 01ED 49 C6                DEFB    'I','F'+$80
  513 01EF 43 4C                DEFM    "CL"
  514 01F1 D3                   DEFB    'S'+$80
  515 01F2 44 52 41             DEFM    "DRA"
  516 01F5 D7                   DEFB    'W'+$80
  517 01F6 43 4C 45 41          DEFM    "CLEA"
  518 01FA D2                   DEFB    'R'+$80
  519 01FB 52 45 54 55          DEFM    "RETUR"
  519 01FF 52
  520 0200 CE                   DEFB    'N'+$80
  521 0201 43 4F 50             DEFM    "COP"
  522 0204 D9                   DEFB    'Y'+$80
  523 0205
  524 0205              ; ----------------
  525 0205              ; THE 'KEY' TABLES
  526 0205              ; ----------------
  527 0205              ;   These six look-up tables are used by the keyboard reading routine
  528 0205              ;   to decode the key values.
  529 0205              ;
  530 0205              ;   The first table contains the maps for the 39 keys of the standard
  531 0205              ;   40-key Spectrum keyboard. The remaining key [SHIFT $27] is read directly.
  532 0205              ;   The keys consist of the 26 upper-case alphabetic characters, the 10 digit
  533 0205              ;   keys and the space, ENTER and symbol shift key.
  534 0205              ;   Unshifted alphabetic keys have $20 added to the value.
  535 0205              ;   The keywords for the main alphabetic keys are obtained by adding $A5 to
  536 0205              ;   the values obtained from this table.
  537 0205
  538 0205              ;; MAIN-KEYS
  539 0205 42           L0205:  DEFB    $42             ; B
  540 0206 48                   DEFB    $48             ; H
  541 0207 59                   DEFB    $59             ; Y
  542 0208 36                   DEFB    $36             ; 6
  543 0209 35                   DEFB    $35             ; 5
  544 020A 54                   DEFB    $54             ; T
  545 020B 47                   DEFB    $47             ; G
  546 020C 56                   DEFB    $56             ; V
  547 020D 4E                   DEFB    $4E             ; N
  548 020E 4A                   DEFB    $4A             ; J
  549 020F 55                   DEFB    $55             ; U
  550 0210 37                   DEFB    $37             ; 7
  551 0211 34                   DEFB    $34             ; 4
  552 0212 52                   DEFB    $52             ; R
  553 0213 46                   DEFB    $46             ; F
  554 0214 43                   DEFB    $43             ; C
  555 0215 4D                   DEFB    $4D             ; M
  556 0216 4B                   DEFB    $4B             ; K
  557 0217 49                   DEFB    $49             ; I
  558 0218 38                   DEFB    $38             ; 8
  559 0219 33                   DEFB    $33             ; 3
  560 021A 45                   DEFB    $45             ; E
  561 021B 44                   DEFB    $44             ; D
  562 021C 58                   DEFB    $58             ; X
  563 021D 0E                   DEFB    $0E             ; SYMBOL SHIFT
  564 021E 4C                   DEFB    $4C             ; L
  565 021F 4F                   DEFB    $4F             ; O
  566 0220 39                   DEFB    $39             ; 9
  567 0221 32                   DEFB    $32             ; 2
  568 0222 57                   DEFB    $57             ; W
  569 0223 53                   DEFB    $53             ; S
  570 0224 5A                   DEFB    $5A             ; Z
  571 0225 20                   DEFB    $20             ; SPACE
  572 0226 0D                   DEFB    $0D             ; ENTER
  573 0227 50                   DEFB    $50             ; P
  574 0228 30                   DEFB    $30             ; 0
  575 0229 31                   DEFB    $31             ; 1
  576 022A 51                   DEFB    $51             ; Q
  577 022B 41                   DEFB    $41             ; A
  578 022C
  579 022C
  580 022C              ;; E-UNSHIFT
  581 022C              ;  The 26 unshifted extended mode keys for the alphabetic characters.
  582 022C              ;  The green keywords on the original keyboard.
  583 022C E3           L022C:  DEFB    $E3             ; READ
  584 022D C4                   DEFB    $C4             ; BIN
  585 022E E0                   DEFB    $E0             ; LPRINT
  586 022F E4                   DEFB    $E4             ; DATA
  587 0230 B4                   DEFB    $B4             ; TAN
  588 0231 BC                   DEFB    $BC             ; SGN
  589 0232 BD                   DEFB    $BD             ; ABS
  590 0233 BB                   DEFB    $BB             ; SQR
  591 0234 AF                   DEFB    $AF             ; CODE
  592 0235 B0                   DEFB    $B0             ; VAL
  593 0236 B1                   DEFB    $B1             ; LEN
  594 0237 C0                   DEFB    $C0             ; USR
  595 0238 A7                   DEFB    $A7             ; PI
  596 0239 A6                   DEFB    $A6             ; INKEY$
  597 023A BE                   DEFB    $BE             ; PEEK
  598 023B AD                   DEFB    $AD             ; TAB
  599 023C B2                   DEFB    $B2             ; SIN
  600 023D BA                   DEFB    $BA             ; INT
  601 023E E5                   DEFB    $E5             ; RESTORE
  602 023F A5                   DEFB    $A5             ; RND
  603 0240 C2                   DEFB    $C2             ; CHR$
  604 0241 E1                   DEFB    $E1             ; LLIST
  605 0242 B3                   DEFB    $B3             ; COS
  606 0243 B9                   DEFB    $B9             ; EXP
  607 0244 C1                   DEFB    $C1             ; STR$
  608 0245 B8                   DEFB    $B8             ; LN
  609 0246
  610 0246
  611 0246              ;; EXT-SHIFT
  612 0246              ;  The 26 shifted extended mode keys for the alphabetic characters.
  613 0246              ;  The red keywords below keys on the original keyboard.
  614 0246 7E           L0246:  DEFB    $7E             ; ~
  615 0247 DC                   DEFB    $DC             ; BRIGHT
  616 0248 DA                   DEFB    $DA             ; PAPER
  617 0249 5C                   DEFB    $5C             ; \
  618 024A B7                   DEFB    $B7             ; ATN
  619 024B 7B                   DEFB    $7B             ; {
  620 024C 7D                   DEFB    $7D             ; }
  621 024D D8                   DEFB    $D8             ; CIRCLE
  622 024E BF                   DEFB    $BF             ; IN
  623 024F AE                   DEFB    $AE             ; VAL$
  624 0250 AA                   DEFB    $AA             ; SCREEN$
  625 0251 AB                   DEFB    $AB             ; ATTR
  626 0252 DD                   DEFB    $DD             ; INVERSE
  627 0253 DE                   DEFB    $DE             ; OVER
  628 0254 DF                   DEFB    $DF             ; OUT
  629 0255 7F                   DEFB    $7F             ; (Copyright character)
  630 0256 B5                   DEFB    $B5             ; ASN
  631 0257 D6                   DEFB    $D6             ; VERIFY
  632 0258 7C                   DEFB    $7C             ; |
  633 0259 D5                   DEFB    $D5             ; MERGE
  634 025A 5D                   DEFB    $5D             ; ]
  635 025B DB                   DEFB    $DB             ; FLASH
  636 025C B6                   DEFB    $B6             ; ACS
  637 025D D9                   DEFB    $D9             ; INK
  638 025E 5B                   DEFB    $5B             ; [
  639 025F D7                   DEFB    $D7             ; BEEP
  640 0260
  641 0260
  642 0260              ;; CTL-CODES
  643 0260              ;  The ten control codes assigned to the top line of digits when the shift
  644 0260              ;  key is pressed.
  645 0260 0C           L0260:  DEFB    $0C             ; DELETE
  646 0261 07                   DEFB    $07             ; EDIT
  647 0262 06                   DEFB    $06             ; CAPS LOCK
  648 0263 04                   DEFB    $04             ; TRUE VIDEO
  649 0264 05                   DEFB    $05             ; INVERSE VIDEO
  650 0265 08                   DEFB    $08             ; CURSOR LEFT
  651 0266 0A                   DEFB    $0A             ; CURSOR DOWN
  652 0267 0B                   DEFB    $0B             ; CURSOR UP
  653 0268 09                   DEFB    $09             ; CURSOR RIGHT
  654 0269 0F                   DEFB    $0F             ; GRAPHICS
  655 026A
  656 026A
  657 026A              ;; SYM-CODES
  658 026A              ;  The 26 red symbols assigned to the alphabetic characters of the keyboard.
  659 026A              ;  The ten single-character digit symbols are converted without the aid of
  660 026A              ;  a table using subtraction and minor manipulation.
  661 026A E2           L026A:  DEFB    $E2             ; STOP
  662 026B 2A                   DEFB    $2A             ; *
  663 026C 3F                   DEFB    $3F             ; ?
  664 026D CD                   DEFB    $CD             ; STEP
  665 026E C8                   DEFB    $C8             ; >=
  666 026F CC                   DEFB    $CC             ; TO
  667 0270 CB                   DEFB    $CB             ; THEN
  668 0271 5E                   DEFB    $5E             ; ^
  669 0272 AC                   DEFB    $AC             ; AT
  670 0273 2D                   DEFB    $2D             ; -
  671 0274 2B                   DEFB    $2B             ; +
  672 0275 3D                   DEFB    $3D             ; =
  673 0276 2E                   DEFB    $2E             ; .
  674 0277 2C                   DEFB    $2C             ; ,
  675 0278 3B                   DEFB    $3B             ; ;
  676 0279 22                   DEFB    $22             ; "
  677 027A C7                   DEFB    $C7             ; <=
  678 027B 3C                   DEFB    $3C             ; <
  679 027C C3                   DEFB    $C3             ; NOT
  680 027D 3E                   DEFB    $3E             ; >
  681 027E C5                   DEFB    $C5             ; OR
  682 027F 2F                   DEFB    $2F             ; /
  683 0280 C9                   DEFB    $C9             ; <>
  684 0281 60                   DEFB    $60             ; pound
  685 0282 C6                   DEFB    $C6             ; AND
  686 0283 3A                   DEFB    $3A             ; :
  687 0284
  688 0284              ;; E-DIGITS
  689 0284              ;  The ten keywords assigned to the digits in extended mode.
  690 0284              ;  The remaining red keywords below the keys.
  691 0284 D0           L0284:  DEFB    $D0             ; FORMAT
  692 0285 CE                   DEFB    $CE             ; DEF FN
  693 0286 A8                   DEFB    $A8             ; FN
  694 0287 CA                   DEFB    $CA             ; LINE
  695 0288 D3                   DEFB    $D3             ; OPEN #
  696 0289 D4                   DEFB    $D4             ; CLOSE #
  697 028A D1                   DEFB    $D1             ; MOVE
  698 028B D2                   DEFB    $D2             ; ERASE
  699 028C A9                   DEFB    $A9             ; POINT
  700 028D CF                   DEFB    $CF             ; CAT
  701 028E
  702 028E
  703 028E              ;*******************************
  704 028E              ;** Part 2. KEYBOARD ROUTINES **
  705 028E              ;*******************************
  706 028E
  707 028E              ;   Using shift keys and a combination of modes the Spectrum 40-key keyboard
  708 028E              ;   can be mapped to 256 input characters
  709 028E
  710 028E              ; ---------------------------------------------------------------------------
  711 028E              ;
  712 028E              ;         0     1     2     3     4 -Bits-  4     3     2     1     0
  713 028E              ; PORT                                                                    PORT
  714 028E              ;
  715 028E              ; F7FE  [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ]  |  [ 6 ] [ 7 ] [ 8 ] [ 9 ] [ 0 ]   EFFE
  716 028E              ;  ^                                   |                                   v
  717 028E              ; FBFE  [ Q ] [ W ] [ E ] [ R ] [ T ]  |  [ Y ] [ U ] [ I ] [ O ] [ P ]   DFFE
  718 028E              ;  ^                                   |                                   v
  719 028E              ; FDFE  [ A ] [ S ] [ D ] [ F ] [ G ]  |  [ H ] [ J ] [ K ] [ L ] [ ENT ] BFFE
  720 028E              ;  ^                                   |                                   v
  721 028E              ; FEFE  [SHI] [ Z ] [ X ] [ C ] [ V ]  |  [ B ] [ N ] [ M ] [sym] [ SPC ] 7FFE
  722 028E              ;  ^     $27                                                 $18           v
  723 028E              ; Start                                                                   End
  724 028E              ;        00100111                                            00011000
  725 028E              ;
  726 028E              ; ---------------------------------------------------------------------------
  727 028E              ;   The above map may help in reading.
  728 028E              ;   The neat arrangement of ports means that the B register need only be
  729 028E              ;   rotated left to work up the left hand side and then down the right
  730 028E              ;   hand side of the keyboard. When the reset bit drops into the carry
  731 028E              ;   then all 8 half-rows have been read. Shift is the first key to be
  732 028E              ;   read. The lower six bits of the shifts are unambiguous.
  733 028E
  734 028E              ; -------------------------------
  735 028E              ; THE 'KEYBOARD SCANNING' ROUTINE
  736 028E              ; -------------------------------
  737 028E              ;   From keyboard and s-inkey$
  738 028E              ;   Returns 1 or 2 keys in DE, most significant shift first if any
  739 028E              ;   key values 0-39 else 255
  740 028E
  741 028E              ;; KEY-SCAN
  742 028E 2E 2F        L028E:  LD      L,$2F           ; initial key value
  743 0290                                              ; valid values are obtained by subtracting
  744 0290                                              ; eight five times.
  745 0290 11 FF FF             LD      DE,$FFFF        ; a buffer to receive 2 keys.
  746 0293
  747 0293 01 FE FE             LD      BC,$FEFE        ; the commencing port address
  748 0296                                              ; B holds 11111110 initially and is also
  749 0296                                              ; used to count the 8 half-rows
  750 0296              ;; KEY-LINE
  751 0296 ED 78        L0296:  IN      A,(C)           ; read the port to A - bits will be reset
  752 0298                                              ; if a key is pressed else set.
  753 0298 2F                   CPL                     ; complement - pressed key-bits are now set
  754 0299 E6 1F                AND     $1F             ; apply 00011111 mask to pick up the
  755 029B                                              ; relevant set bits.
  756 029B
  757 029B 28 0E                JR      Z,L02AB         ; forward to KEY-DONE if zero and therefore
  758 029D                                              ; no keys pressed in row at all.
  759 029D
  760 029D 67                   LD      H,A             ; transfer row bits to H
  761 029E 7D                   LD      A,L             ; load the initial key value to A
  762 029F
  763 029F              ;; KEY-3KEYS
  764 029F 14           L029F:  INC     D               ; now test the key buffer
  765 02A0 C0                   RET     NZ              ; if we have collected 2 keys already
  766 02A1                                              ; then too many so quit.
  767 02A1
  768 02A1              ;; KEY-BITS
  769 02A1 D6 08        L02A1:  SUB     $08             ; subtract 8 from the key value
  770 02A3                                              ; cycling through key values (top = $27)
  771 02A3                                              ; e.g. 2F>   27>1F>17>0F>07
  772 02A3                                              ;      2E>   26>1E>16>0E>06
  773 02A3 CB 3C                SRL     H               ; shift key bits right into carry.
  774 02A5 30 FA                JR      NC,L02A1        ; back to KEY-BITS if not pressed
  775 02A7                                              ; but if pressed we have a value (0-39d)
  776 02A7
  777 02A7 53                   LD      D,E             ; transfer a possible previous key to D
  778 02A8 5F                   LD      E,A             ; transfer the new key to E
  779 02A9 20 F4                JR      NZ,L029F        ; back to KEY-3KEYS if there were more
  780 02AB                                              ; set bits - H was not yet zero.
  781 02AB
  782 02AB              ;; KEY-DONE
  783 02AB 2D           L02AB:  DEC     L               ; cycles 2F>2E>2D>2C>2B>2A>29>28 for
  784 02AC                                              ; each half-row.
  785 02AC CB 00                RLC     B               ; form next port address e.g. FEFE > FDFE
  786 02AE 38 E6                JR      C,L0296         ; back to KEY-LINE if still more rows to do.
  787 02B0
  788 02B0 7A                   LD      A,D             ; now test if D is still FF ?
  789 02B1 3C                   INC     A               ; if it is zero we have at most 1 key
  790 02B2                                              ; range now $01-$28  (1-40d)
  791 02B2 C8                   RET     Z               ; return if one key or no key.
  792 02B3
  793 02B3 FE 28                CP      $28             ; is it capsshift (was $27) ?
  794 02B5 C8                   RET     Z               ; return if so.
  795 02B6
  796 02B6 FE 19                CP      $19             ; is it symbol shift (was $18) ?
  797 02B8 C8                   RET     Z               ; return also
  798 02B9
  799 02B9 7B                   LD      A,E             ; now test E
  800 02BA 5A                   LD      E,D             ; but first switch
  801 02BB 57                   LD      D,A             ; the two keys.
  802 02BC FE 18                CP      $18             ; is it symbol shift ?
  803 02BE C9                   RET                     ; return (with zero set if it was).
  804 02BF                                              ; but with symbol shift now in D
  805 02BF
  806 02BF              ; ----------------------
  807 02BF              ; THE 'KEYBOARD' ROUTINE
  808 02BF              ; ----------------------
  809 02BF              ;   Called from the interrupt 50 times a second.
  810 02BF              ;
  811 02BF
  812 02BF              ;; KEYBOARD
  813 02BF CD 8E 02     L02BF:  CALL    L028E           ; routine KEY-SCAN
  814 02C2 C0                   RET     NZ              ; return if invalid combinations
  815 02C3
  816 02C3              ;   then decrease the counters within the two key-state maps
  817 02C3              ;   as this could cause one to become free.
  818 02C3              ;   if the keyboard has not been pressed during the last five interrupts
  819 02C3              ;   then both sets will be free.
  820 02C3
  821 02C3
  822 02C3 21 00 5C             LD      HL,$5C00        ; point to KSTATE-0
  823 02C6
  824 02C6              ;; K-ST-LOOP
  825 02C6 CB 7E        L02C6:  BIT     7,(HL)          ; is it free ?  (i.e. $FF)
  826 02C8 20 07                JR      NZ,L02D1        ; forward to K-CH-SET if so
  827 02CA
  828 02CA 23                   INC     HL              ; address the 5-counter
  829 02CB 35                   DEC     (HL)            ; decrease the counter
  830 02CC 2B                   DEC     HL              ; step back
  831 02CD
  832 02CD 20 02                JR      NZ,L02D1        ; forward to K-CH-SET if not at end of count
  833 02CF
  834 02CF 36 FF                LD      (HL),$FF        ; else mark this particular map free.
  835 02D1
  836 02D1              ;; K-CH-SET
  837 02D1 7D           L02D1:  LD      A,L             ; make a copy of the low address byte.
  838 02D2 21 04 5C             LD      HL,$5C04        ; point to KSTATE-4
  839 02D5                                              ; (ld l,$04 would do)
  840 02D5 BD                   CP      L               ; have both sets been considered ?
  841 02D6 20 EE                JR      NZ,L02C6        ; back to K-ST-LOOP to consider this 2nd set
  842 02D8
  843 02D8              ;   now the raw key (0-38d) is converted to a main key (uppercase).
  844 02D8
  845 02D8 CD 1E 03             CALL    L031E           ; routine K-TEST to get main key in A
  846 02DB
  847 02DB D0                   RET     NC              ; return if just a single shift
  848 02DC
  849 02DC 21 00 5C             LD      HL,$5C00        ; point to KSTATE-0
  850 02DF BE                   CP      (HL)            ; does the main key code match ?
  851 02E0 28 2E                JR      Z,L0310         ; forward to K-REPEAT if so
  852 02E2
  853 02E2              ;   if not consider the second key map.
  854 02E2
  855 02E2 EB                   EX      DE,HL           ; save kstate-0 in de
  856 02E3 21 04 5C             LD      HL,$5C04        ; point to KSTATE-4
  857 02E6 BE                   CP      (HL)            ; does the main key code match ?
  858 02E7 28 27                JR      Z,L0310         ; forward to K-REPEAT if so
  859 02E9
  860 02E9              ;   having excluded a repeating key we can now consider a new key.
  861 02E9              ;   the second set is always examined before the first.
  862 02E9
  863 02E9 CB 7E                BIT     7,(HL)          ; is the key map free ?
  864 02EB 20 04                JR      NZ,L02F1        ; forward to K-NEW if so.
  865 02ED
  866 02ED EB                   EX      DE,HL           ; bring back KSTATE-0
  867 02EE CB 7E                BIT     7,(HL)          ; is it free ?
  868 02F0 C8                   RET     Z               ; return if not.
  869 02F1                                              ; as we have a key but nowhere to put it yet.
  870 02F1
  871 02F1              ;   continue or jump to here if one of the buffers was free.
  872 02F1
  873 02F1              ;; K-NEW
  874 02F1 5F           L02F1:  LD      E,A             ; store key in E
  875 02F2 77                   LD      (HL),A          ; place in free location
  876 02F3 23                   INC     HL              ; advance to the interrupt counter
  877 02F4 36 05                LD      (HL),$05        ; and initialize counter to 5
  878 02F6 23                   INC     HL              ; advance to the delay
  879 02F7 3A 09 5C             LD      A,($5C09)       ; pick up the system variable REPDEL
  880 02FA 77                   LD      (HL),A          ; and insert that for first repeat delay.
  881 02FB 23                   INC     HL              ; advance to last location of state map.
  882 02FC
  883 02FC FD 4E 07             LD      C,(IY+$07)      ; pick up MODE  (3 bytes)
  884 02FF FD 56 01             LD      D,(IY+$01)      ; pick up FLAGS (3 bytes)
  885 0302 E5                   PUSH    HL              ; save state map location
  886 0303                                              ; Note. could now have used, to avoid IY,
  887 0303                                              ; ld l,$41; ld c,(hl); ld l,$3B; ld d,(hl).
  888 0303                                              ; six and two threes of course.
  889 0303
  890 0303 CD 33 03             CALL    L0333           ; routine K-DECODE
  891 0306
  892 0306 E1                   POP     HL              ; restore map pointer
  893 0307 77                   LD      (HL),A          ; put the decoded key in last location of map.
  894 0308
  895 0308              ;; K-END
  896 0308 32 08 5C     L0308:  LD      ($5C08),A       ; update LASTK system variable.
  897 030B FD CB 01 EE          SET     5,(IY+$01)      ; update FLAGS  - signal a new key.
  898 030F C9                   RET                     ; return to interrupt routine.
  899 0310
  900 0310              ; -----------------------
  901 0310              ; THE 'REPEAT KEY' BRANCH
  902 0310              ; -----------------------
  903 0310              ;   A possible repeat has been identified. HL addresses the raw key.
  904 0310              ;   The last location of the key map holds the decoded key from the first
  905 0310              ;   context.  This could be a keyword and, with the exception of NOT a repeat
  906 0310              ;   is syntactically incorrect and not really desirable.
  907 0310
  908 0310              ;; K-REPEAT
  909 0310 23           L0310:  INC     HL              ; increment the map pointer to second location.
  910 0311 36 05                LD      (HL),$05        ; maintain interrupt counter at 5.
  911 0313 23                   INC     HL              ; now point to third location.
  912 0314 35                   DEC     (HL)            ; decrease the REPDEL value which is used to
  913 0315                                              ; time the delay of a repeat key.
  914 0315
  915 0315 C0                   RET     NZ              ; return if not yet zero.
  916 0316
  917 0316 3A 0A 5C             LD      A,($5C0A)       ; fetch the system variable value REPPER.
  918 0319 77                   LD      (HL),A          ; for subsequent repeats REPPER will be used.
  919 031A
  920 031A 23                   INC     HL              ; advance
  921 031B                                              ;
  922 031B 7E                   LD      A,(HL)          ; pick up the key decoded possibly in another
  923 031C                                              ; context.
  924 031C                                              ; Note. should compare with $A5 (RND) and make
  925 031C                                              ; a simple return if this is a keyword.
  926 031C                                              ; e.g. cp $a5; ret nc; (3 extra bytes)
  927 031C 18 EA                JR      L0308           ; back to K-END
  928 031E
  929 031E              ; ----------------------
  930 031E              ; THE 'KEY-TEST' ROUTINE
  931 031E              ; ----------------------
  932 031E              ;   also called from s-inkey$
  933 031E              ;   begin by testing for a shift with no other.
  934 031E
  935 031E              ;; K-TEST
  936 031E 42           L031E:  LD      B,D             ; load most significant key to B
  937 031F                                              ; will be $FF if not shift.
  938 031F 16 00                LD      D,$00           ; and reset D to index into main table
  939 0321 7B                   LD      A,E             ; load least significant key from E
  940 0322 FE 27                CP      $27             ; is it higher than 39d   i.e. FF
  941 0324 D0                   RET     NC              ; return with just a shift (in B now)
  942 0325
  943 0325 FE 18                CP      $18             ; is it symbol shift ?
  944 0327 20 03                JR      NZ,L032C        ; forward to K-MAIN if not
  945 0329
  946 0329              ;   but we could have just symbol shift and no other
  947 0329
  948 0329 CB 78                BIT     7,B             ; is other key $FF (ie not shift)
  949 032B C0                   RET     NZ              ; return with solitary symbol shift
  950 032C
  951 032C
  952 032C              ;; K-MAIN
  953 032C 21 05 02     L032C:  LD      HL,L0205        ; address: MAIN-KEYS
  954 032F 19                   ADD     HL,DE           ; add offset 0-38
  955 0330 7E                   LD      A,(HL)          ; pick up main key value
  956 0331 37                   SCF                     ; set carry flag
  957 0332 C9                   RET                     ; return    (B has other key still)
  958 0333
  959 0333              ; ----------------------------------
  960 0333              ; THE 'KEYBOARD DECODING' SUBROUTINE
  961 0333              ; ----------------------------------
  962 0333              ;   also called from s-inkey$
  963 0333
  964 0333              ;; K-DECODE
  965 0333 7B           L0333:  LD      A,E             ; pick up the stored main key
  966 0334 FE 3A                CP      $3A             ; an arbitrary point between digits and letters
  967 0336 38 2F                JR      C,L0367         ; forward to K-DIGIT with digits, space, enter.
  968 0338
  969 0338 0D                   DEC     C               ; decrease MODE ( 0='KLC', 1='E', 2='G')
  970 0339
  971 0339 FA 4F 03             JP      M,L034F         ; to K-KLC-LET if was zero
  972 033C
  973 033C 28 03                JR      Z,L0341         ; to K-E-LET if was 1 for extended letters.
  974 033E
  975 033E              ;   proceed with graphic codes.
  976 033E              ;   Note. should selectively drop return address if code > 'U' ($55).
  977 033E              ;   i.e. abort the KEYBOARD call.
  978 033E              ;   e.g. cp 'V'; jr c,addit; pop af ;pop af ;;addit etc. (6 extra bytes).
  979 033E              ;   (s-inkey$ never gets into graphics mode.)
  980 033E
  981 033E              ;; addit
  982 033E C6 4F                ADD     A,$4F           ; add offset to augment 'A' to graphics A say.
  983 0340 C9                   RET                     ; return.
  984 0341                                              ; Note. ( but [GRAPH] V gives RND, etc ).
  985 0341
  986 0341              ; ---
  987 0341
  988 0341              ;   the jump was to here with extended mode with uppercase A-Z.
  989 0341
  990 0341              ;; K-E-LET
  991 0341 21 EB 01     L0341:  LD      HL,L022C-$41    ; base address of E-UNSHIFT L022c.
  992 0344                                              ; ( $01EB in standard ROM ).
  993 0344 04                   INC     B               ; test B is it empty i.e. not a shift.
  994 0345 28 03                JR      Z,L034A         ; forward to K-LOOK-UP if neither shift.
  995 0347
  996 0347 21 05 02             LD      HL,L0246-$41    ; Address: $0205 L0246-$41 EXT-SHIFT base
  997 034A
  998 034A              ;; K-LOOK-UP
  999 034A 16 00        L034A:  LD      D,$00           ; prepare to index.
 1000 034C 19                   ADD     HL,DE           ; add the main key value.
 1001 034D 7E                   LD      A,(HL)          ; pick up other mode value.
 1002 034E C9                   RET                     ; return.
 1003 034F
 1004 034F              ; ---
 1005 034F
 1006 034F              ;   the jump was here with mode = 0
 1007 034F
 1008 034F              ;; K-KLC-LET
 1009 034F 21 29 02     L034F:  LD      HL,L026A-$41    ; prepare base of sym-codes
 1010 0352 CB 40                BIT     0,B             ; shift=$27 sym-shift=$18
 1011 0354 28 F4                JR      Z,L034A         ; back to K-LOOK-UP with symbol-shift
 1012 0356
 1013 0356 CB 5A                BIT     3,D             ; test FLAGS is it 'K' mode (from OUT-CURS)
 1014 0358 28 0A                JR      Z,L0364         ; skip to K-TOKENS if so
 1015 035A
 1016 035A FD CB 30 5E          BIT     3,(IY+$30)      ; test FLAGS2 - consider CAPS LOCK ?
 1017 035E C0                   RET     NZ              ; return if so with main code.
 1018 035F
 1019 035F 04                   INC     B               ; is shift being pressed ?
 1020 0360                                              ; result zero if not
 1021 0360 C0                   RET     NZ              ; return if shift pressed.
 1022 0361
 1023 0361 C6 20                ADD     A,$20           ; else convert the code to lower case.
 1024 0363 C9                   RET                     ; return.
 1025 0364
 1026 0364              ; ---
 1027 0364
 1028 0364              ;   the jump was here for tokens
 1029 0364
 1030 0364              ;; K-TOKENS
 1031 0364 C6 A5        L0364:  ADD     A,$A5           ; add offset to main code so that 'A'
 1032 0366                                              ; becomes 'NEW' etc.
 1033 0366
 1034 0366 C9                   RET                     ; return.
 1035 0367
 1036 0367              ; ---
 1037 0367
 1038 0367              ;   the jump was here with digits, space, enter and symbol shift (< $xx)
 1039 0367
 1040 0367              ;; K-DIGIT
 1041 0367 FE 30        L0367:  CP      $30             ; is it '0' or higher ?
 1042 0369 D8                   RET     C               ; return with space, enter and symbol-shift
 1043 036A
 1044 036A 0D                   DEC     C               ; test MODE (was 0='KLC', 1='E', 2='G')
 1045 036B FA 9D 03             JP      M,L039D         ; jump to K-KLC-DGT if was 0.
 1046 036E
 1047 036E 20 19                JR      NZ,L0389        ; forward to K-GRA-DGT if mode was 2.
 1048 0370
 1049 0370              ;   continue with extended digits 0-9.
 1050 0370
 1051 0370 21 54 02             LD      HL,L0284-$30    ; $0254 - base of E-DIGITS
 1052 0373 CB 68                BIT     5,B             ; test - shift=$27 sym-shift=$18
 1053 0375 28 D3                JR      Z,L034A         ; to K-LOOK-UP if sym-shift
 1054 0377
 1055 0377 FE 38                CP      $38             ; is character '8' ?
 1056 0379 30 07                JR      NC,L0382        ; to K-8-&-9 if greater than '7'
 1057 037B
 1058 037B D6 20                SUB     $20             ; reduce to ink range $10-$17
 1059 037D 04                   INC     B               ; shift ?
 1060 037E C8                   RET     Z               ; return if not.
 1061 037F
 1062 037F C6 08                ADD     A,$08           ; add 8 to give paper range $18 - $1F
 1063 0381 C9                   RET                     ; return
 1064 0382
 1065 0382              ; ---
 1066 0382
 1067 0382              ;   89
 1068 0382
 1069 0382              ;; K-8-&-9
 1070 0382 D6 36        L0382:  SUB     $36             ; reduce to 02 and 03  bright codes
 1071 0384 04                   INC     B               ; test if shift pressed.
 1072 0385 C8                   RET     Z               ; return if not.
 1073 0386
 1074 0386 C6 FE                ADD     A,$FE           ; subtract 2 setting carry
 1075 0388 C9                   RET                     ; to give 0 and 1    flash codes.
 1076 0389
 1077 0389              ; ---
 1078 0389
 1079 0389              ;   graphics mode with digits
 1080 0389
 1081 0389              ;; K-GRA-DGT
 1082 0389 21 30 02     L0389:  LD      HL,L0260-$30    ; $0230 base address of CTL-CODES
 1083 038C
 1084 038C FE 39                CP      $39             ; is key '9' ?
 1085 038E 28 BA                JR      Z,L034A         ; back to K-LOOK-UP - changed to $0F, GRAPHICS.
 1086 0390
 1087 0390 FE 30                CP      $30             ; is key '0' ?
 1088 0392 28 B6                JR      Z,L034A         ; back to K-LOOK-UP - changed to $0C, delete.
 1089 0394
 1090 0394              ;   for keys '0' - '7' we assign a mosaic character depending on shift.
 1091 0394
 1092 0394 E6 07                AND     $07             ; convert character to number. 0 - 7.
 1093 0396 C6 80                ADD     A,$80           ; add offset - they start at $80
 1094 0398
 1095 0398 04                   INC     B               ; destructively test for shift
 1096 0399 C8                   RET     Z               ; and return if not pressed.
 1097 039A
 1098 039A EE 0F                XOR     $0F             ; toggle bits becomes range $88-$8F
 1099 039C C9                   RET                     ; return.
 1100 039D
 1101 039D              ; ---
 1102 039D
 1103 039D              ;   now digits in 'KLC' mode
 1104 039D
 1105 039D              ;; K-KLC-DGT
 1106 039D 04           L039D:  INC     B               ; return with digit codes if neither
 1107 039E C8                   RET     Z               ; shift key pressed.
 1108 039F
 1109 039F CB 68                BIT     5,B             ; test for caps shift.
 1110 03A1
 1111 03A1 21 30 02             LD      HL,L0260-$30    ; prepare base of table CTL-CODES.
 1112 03A4 20 A4                JR      NZ,L034A        ; back to K-LOOK-UP if shift pressed.
 1113 03A6
 1114 03A6              ;   must have been symbol shift
 1115 03A6
 1116 03A6 D6 10                SUB     $10             ; for ASCII most will now be correct
 1117 03A8                                              ; on a standard typewriter.
 1118 03A8
 1119 03A8 FE 22                CP      $22             ; but '@' is not - see below.
 1120 03AA 28 06                JR      Z,L03B2         ; forward to K-@-CHAR if so
 1121 03AC
 1122 03AC FE 20                CP      $20             ; '_' is the other one that fails
 1123 03AE C0                   RET     NZ              ; return if not.
 1124 03AF
 1125 03AF 3E 5F                LD      A,$5F           ; substitute ASCII '_'
 1126 03B1 C9                   RET                     ; return.
 1127 03B2
 1128 03B2              ; ---
 1129 03B2
 1130 03B2              ;; K-@-CHAR
 1131 03B2 3E 40        L03B2:  LD      A,$40           ; substitute ASCII '@'
 1132 03B4 C9                   RET                     ; return.
 1133 03B5
 1134 03B5
 1135 03B5              ; ------------------------------------------------------------------------
 1136 03B5              ;   The Spectrum Input character keys. One or two are abbreviated.
 1137 03B5              ;   From $00 Flash 0 to $FF COPY. The routine above has decoded all these.
 1138 03B5
 1139 03B5              ;  | 00 Fl0| 01 Fl1| 02 Br0| 03 Br1| 04 In0| 05 In1| 06 CAP| 07 EDT|
 1140 03B5              ;  | 08 LFT| 09 RIG| 0A DWN| 0B UP | 0C DEL| 0D ENT| 0E SYM| 0F GRA|
 1141 03B5              ;  | 10 Ik0| 11 Ik1| 12 Ik2| 13 Ik3| 14 Ik4| 15 Ik5| 16 Ik6| 17 Ik7|
 1142 03B5              ;  | 18 Pa0| 19 Pa1| 1A Pa2| 1B Pa3| 1C Pa4| 1D Pa5| 1E Pa6| 1F Pa7|
 1143 03B5              ;  | 20 SP | 21  ! | 22  " | 23  # | 24  $ | 25  % | 26  & | 27  ' |
 1144 03B5              ;  | 28  ( | 29  ) | 2A  * | 2B  + | 2C  , | 2D  - | 2E  . | 2F  / |
 1145 03B5              ;  | 30  0 | 31  1 | 32  2 | 33  3 | 34  4 | 35  5 | 36  6 | 37  7 |
 1146 03B5              ;  | 38  8 | 39  9 | 3A  : | 3B  ; | 3C  < | 3D  = | 3E  > | 3F  ? |
 1147 03B5              ;  | 40  @ | 41  A | 42  B | 43  C | 44  D | 45  E | 46  F | 47  G |
 1148 03B5              ;  | 48  H | 49  I | 4A  J | 4B  K | 4C  L | 4D  M | 4E  N | 4F  O |
 1149 03B5              ;  | 50  P | 51  Q | 52  R | 53  S | 54  T | 55  U | 56  V | 57  W |
 1150 03B5              ;  | 58  X | 59  Y | 5A  Z | 5B  [ | 5C  \ | 5D  ] | 5E  ^ | 5F  _ |
 1151 03B5              ;  | 60   | 61  a | 62  b | 63  c | 64  d | 65  e | 66  f | 67  g |
 1152 03B5              ;  | 68  h | 69  i | 6A  j | 6B  k | 6C  l | 6D  m | 6E  n | 6F  o |
 1153 03B5              ;  | 70  p | 71  q | 72  r | 73  s | 74  t | 75  u | 76  v | 77  w |
 1154 03B5              ;  | 78  x | 79  y | 7A  z | 7B  { | 7C  | | 7D  } | 7E  ~ | 7F   |
 1155 03B5              ;  | 80 128| 81 129| 82 130| 83 131| 84 132| 85 133| 86 134| 87 135|
 1156 03B5              ;  | 88 136| 89 137| 8A 138| 8B 139| 8C 140| 8D 141| 8E 142| 8F 143|
 1157 03B5              ;  | 90 [A]| 91 [B]| 92 [C]| 93 [D]| 94 [E]| 95 [F]| 96 [G]| 97 [H]|
 1158 03B5              ;  | 98 [I]| 99 [J]| 9A [K]| 9B [L]| 9C [M]| 9D [N]| 9E [O]| 9F [P]|
 1159 03B5              ;  | A0 [Q]| A1 [R]| A2 [S]| A3 [T]| A4 [U]| A5 RND| A6 IK$| A7 PI |
 1160 03B5              ;  | A8 FN | A9 PNT| AA SC$| AB ATT| AC AT | AD TAB| AE VL$| AF COD|
 1161 03B5              ;  | B0 VAL| B1 LEN| B2 SIN| B3 COS| B4 TAN| B5 ASN| B6 ACS| B7 ATN|
 1162 03B5              ;  | B8 LN | B9 EXP| BA INT| BB SQR| BC SGN| BD ABS| BE PEK| BF IN |
 1163 03B5              ;  | C0 USR| C1 ST$| C2 CH$| C3 NOT| C4 BIN| C5 OR | C6 AND| C7 <= |
 1164 03B5              ;  | C8 >= | C9 <> | CA LIN| CB THN| CC TO | CD STP| CE DEF| CF CAT|
 1165 03B5              ;  | D0 FMT| D1 MOV| D2 ERS| D3 OPN| D4 CLO| D5 MRG| D6 VFY| D7 BEP|
 1166 03B5              ;  | D8 CIR| D9 INK| DA PAP| DB FLA| DC BRI| DD INV| DE OVR| DF OUT|
 1167 03B5              ;  | E0 LPR| E1 LLI| E2 STP| E3 REA| E4 DAT| E5 RES| E6 NEW| E7 BDR|
 1168 03B5              ;  | E8 CON| E9 DIM| EA REM| EB FOR| EC GTO| ED GSB| EE INP| EF LOA|
 1169 03B5              ;  | F0 LIS| F1 LET| F2 PAU| F3 NXT| F4 POK| F5 PRI| F6 PLO| F7 RUN|
 1170 03B5              ;  | F8 SAV| F9 RAN| FA IF | FB CLS| FC DRW| FD CLR| FE RET| FF CPY|
 1171 03B5
 1172 03B5              ;   Note that for simplicity, Sinclair have located all the control codes
 1173 03B5              ;   below the space character.
 1174 03B5              ;   ASCII DEL, $7F, has been made a copyright symbol.
 1175 03B5              ;   Also $60, '`', not used in BASIC but used in other languages, has been
 1176 03B5              ;   allocated the local currency symbol for the relevant country -
 1177 03B5              ;      in most Spectrums.
 1178 03B5
 1179 03B5              ; ------------------------------------------------------------------------
 1180 03B5
 1181 03B5
 1182 03B5              ;**********************************
 1183 03B5              ;** Part 3. LOUDSPEAKER ROUTINES **
 1184 03B5              ;**********************************
 1185 03B5
 1186 03B5              ; Documented by Alvin Albrecht.
 1187 03B5
 1188 03B5              ; ------------------------------
 1189 03B5              ; Routine to control loudspeaker
 1190 03B5              ; ------------------------------
 1191 03B5              ; Outputs a square wave of given duration and frequency
 1192 03B5              ; to the loudspeaker.
 1193 03B5              ;   Enter with: DE = #cycles - 1
 1194 03B5              ;               HL = tone period as described next
 1195 03B5              ;
 1196 03B5              ; The tone period is measured in T states and consists of
 1197 03B5              ; three parts: a coarse part (H register), a medium part
 1198 03B5              ; (bits 7..2 of L) and a fine part (bits 1..0 of L) which
 1199 03B5              ; contribute to the waveform timing as follows:
 1200 03B5              ;
 1201 03B5              ;                          coarse    medium       fine
 1202 03B5              ; duration of low  = 118 + 1024*H + 16*(L>>2) + 4*(L&0x3)
 1203 03B5              ; duration of hi   = 118 + 1024*H + 16*(L>>2) + 4*(L&0x3)
 1204 03B5              ; Tp = tone period = 236 + 2048*H + 32*(L>>2) + 8*(L&0x3)
 1205 03B5              ;                  = 236 + 2048*H + 8*L = 236 + 8*HL
 1206 03B5              ;
 1207 03B5              ; As an example, to output five seconds of middle C (261.624 Hz):
 1208 03B5              ;   (a) Tone period = 1/261.624 = 3.822ms
 1209 03B5              ;   (b) Tone period in T-States = 3.822ms*fCPU = 13378
 1210 03B5              ;         where fCPU = clock frequency of the CPU = 3.5MHz
 1211 03B5              ;      Find H and L for desired tone period:
 1212 03B5              ;         HL = (Tp - 236) / 8 = (13378 - 236) / 8 = 1643 = 0x066B
 1213 03B5              ;   (d) Tone duration in cycles = 5s/3.822ms = 1308 cycles
 1214 03B5              ;         DE = 1308 - 1 = 0x051B
 1215 03B5              ;
 1216 03B5              ; The resulting waveform has a duty ratio of exactly 50%.
 1217 03B5              ;
 1218 03B5              ;
 1219 03B5              ;; BEEPER
 1220 03B5 F3           L03B5:  DI                      ; Disable Interrupts so they don't disturb timing
 1221 03B6 7D                   LD      A,L             ;
 1222 03B7 CB 3D                SRL     L               ;
 1223 03B9 CB 3D                SRL     L               ; L = medium part of tone period
 1224 03BB 2F                   CPL                     ;
 1225 03BC E6 03                AND     $03             ; A = 3 - fine part of tone period
 1226 03BE 4F                   LD      C,A             ;
 1227 03BF 06 00                LD      B,$00           ;
 1228 03C1 DD 21 D1 03          LD      IX,L03D1        ; Address: BE-IX+3
 1229 03C5 DD 09                ADD     IX,BC           ;   IX holds address of entry into the loop
 1230 03C7                                              ;   the loop will contain 0-3 NOPs, implementing
 1231 03C7                                              ;   the fine part of the tone period.
 1232 03C7 3A 48 5C             LD      A,($5C48)       ; BORDCR
 1233 03CA E6 38                AND     $38             ; bits 5..3 contain border colour
 1234 03CC 0F                   RRCA                    ; border colour bits moved to 2..0
 1235 03CD 0F                   RRCA                    ;   to match border bits on port #FE
 1236 03CE 0F                   RRCA                    ;
 1237 03CF F6 08                OR       $08            ; bit 3 set (tape output bit on port #FE)
 1238 03D1                                              ;   for loud sound output
 1239 03D1              ;; BE-IX+3
 1240 03D1 00           L03D1:  NOP              ;(4)   ; optionally executed NOPs for small
 1241 03D2                                              ;   adjustments to tone period
 1242 03D2              ;; BE-IX+2
 1243 03D2 00           L03D2:  NOP              ;(4)   ;
 1244 03D3
 1245 03D3              ;; BE-IX+1
 1246 03D3 00           L03D3:  NOP              ;(4)   ;
 1247 03D4
 1248 03D4              ;; BE-IX+0
 1249 03D4 04           L03D4:  INC     B        ;(4)   ;
 1250 03D5 0C                   INC     C        ;(4)   ;
 1251 03D6
 1252 03D6              ;; BE-H&L-LP
 1253 03D6 0D           L03D6:  DEC     C        ;(4)   ; timing loop for duration of
 1254 03D7 20 FD                JR      NZ,L03D6 ;(12/7);   high or low pulse of waveform
 1255 03D9
 1256 03D9 0E 3F                LD      C,$3F    ;(7)   ;
 1257 03DB 05                   DEC     B        ;(4)   ;
 1258 03DC C2 D6 03             JP      NZ,L03D6 ;(10)  ; to BE-H&L-LP
 1259 03DF
 1260 03DF EE 10                XOR     $10      ;(7)   ; toggle output beep bit
 1261 03E1 D3 FE                OUT     ($FE),A  ;(11)  ; output pulse
 1262 03E3 44                   LD      B,H      ;(4)   ; B = coarse part of tone period
 1263 03E4 4F                   LD      C,A      ;(4)   ; save port #FE output byte
 1264 03E5 CB 67                BIT     4,A      ;(8)   ; if new output bit is high, go
 1265 03E7 20 09                JR      NZ,L03F2 ;(12/7);   to BE-AGAIN
 1266 03E9
 1267 03E9 7A                   LD      A,D      ;(4)   ; one cycle of waveform has completed
 1268 03EA B3                   OR      E        ;(4)   ;   (low->low). if cycle countdown = 0
 1269 03EB 28 09                JR      Z,L03F6  ;(12/7);   go to BE-END
 1270 03ED
 1271 03ED 79                   LD      A,C      ;(4)   ; restore output byte for port #FE
 1272 03EE 4D                   LD      C,L      ;(4)   ; C = medium part of tone period
 1273 03EF 1B                   DEC     DE       ;(6)   ; decrement cycle count
 1274 03F0 DD E9                JP      (IX)     ;(8)   ; do another cycle
 1275 03F2
 1276 03F2              ;; BE-AGAIN                     ; halfway through cycle
 1277 03F2 4D           L03F2:  LD      C,L      ;(4)   ; C = medium part of tone period
 1278 03F3 0C                   INC     C        ;(4)   ; adds 16 cycles to make duration of high = duration of low
 1279 03F4 DD E9                JP      (IX)     ;(8)   ; do high pulse of tone
 1280 03F6
 1281 03F6              ;; BE-END
 1282 03F6 FB           L03F6:  EI                      ; Enable Interrupts
 1283 03F7 C9                   RET                     ;
 1284 03F8
 1285 03F8
 1286 03F8              ; ------------------
 1287 03F8              ; THE 'BEEP' COMMAND
 1288 03F8              ; ------------------
 1289 03F8              ; BASIC interface to BEEPER subroutine.
 1290 03F8              ; Invoked in BASIC with:
 1291 03F8              ;   BEEP dur, pitch
 1292 03F8              ;   where dur   = duration in seconds
 1293 03F8              ;         pitch = # of semitones above/below middle C
 1294 03F8              ;
 1295 03F8              ; Enter with: pitch on top of calculator stack
 1296 03F8              ;             duration next on calculator stack
 1297 03F8              ;
 1298 03F8              ;; beep
 1299 03F8 EF           L03F8:  RST     28H             ;; FP-CALC
 1300 03F9 31                   DEFB    $31             ;;duplicate                  ; duplicate pitch
 1301 03FA 27                   DEFB    $27             ;;int                        ; convert to integer
 1302 03FB C0                   DEFB    $C0             ;;st-mem-0                   ; store integer pitch to memory 0
 1303 03FC 03                   DEFB    $03             ;;subtract                   ; calculate fractional part of pitch = fp_pitch - int_pitch
 1304 03FD 34                   DEFB    $34             ;;stk-data                   ; push constant
 1305 03FE EC                   DEFB    $EC             ;;Exponent: $7C, Bytes: 4    ; constant = 0.05762265
 1306 03FF 6C 98 1F F5          DEFB    $6C,$98,$1F,$F5 ;;($6C,$98,$1F,$F5)
 1307 0403 04                   DEFB    $04             ;;multiply                   ; compute:
 1308 0404 A1                   DEFB    $A1             ;;stk-one                    ; 1 + 0.05762265 * fraction_part(pitch)
 1309 0405 0F                   DEFB    $0F             ;;addition
 1310 0406 38                   DEFB    $38             ;;end-calc                   ; leave on calc stack
 1311 0407
 1312 0407 21 92 5C             LD      HL,$5C92        ; MEM-0: number stored here is in 16 bit integer format (pitch)
 1313 040A                                              ;   0, 0/FF (pos/neg), LSB, MSB, 0
 1314 040A                                              ;   LSB/MSB is stored in two's complement
 1315 040A                                              ; In the following, the pitch is checked if it is in the range -128<=p<=127
 1316 040A 7E                   LD      A,(HL)          ; First byte must be zero, otherwise
 1317 040B A7                   AND     A               ;   error in integer conversion
 1318 040C 20 5E                JR      NZ,L046C        ; to REPORT-B
 1319 040E
 1320 040E 23                   INC     HL              ;
 1321 040F 4E                   LD      C,(HL)          ; C = pos/neg flag = 0/FF
 1322 0410 23                   INC     HL              ;
 1323 0411 46                   LD      B,(HL)          ; B = LSB, two's complement
 1324 0412 78                   LD      A,B             ;
 1325 0413 17                   RLA                     ;
 1326 0414 9F                   SBC     A,A             ; A = 0/FF if B is pos/neg
 1327 0415 B9                   CP      C               ; must be the same as C if the pitch is -128<=p<=127
 1328 0416 20 54                JR      NZ,L046C        ; if no, error REPORT-B
 1329 0418
 1330 0418 23                   INC     HL              ; if -128<=p<=127, MSB will be 0/FF if B is pos/neg
 1331 0419 BE                   CP      (HL)            ; verify this
 1332 041A 20 50                JR      NZ,L046C        ; if no, error REPORT-B
 1333 041C                                              ; now we know -128<=p<=127
 1334 041C 78                   LD      A,B             ; A = pitch + 60
 1335 041D C6 3C                ADD     A,$3C           ; if -60<=pitch<=67,
 1336 041F F2 25 04             JP      P,L0425         ;   goto BE-i-OK
 1337 0422
 1338 0422 E2 6C 04             JP      PO,L046C        ; if pitch <= 67 goto REPORT-B
 1339 0425                                              ;   lower bound of pitch set at -60
 1340 0425
 1341 0425              ;; BE-I-OK                      ; here, -60<=pitch<=127
 1342 0425                                              ; and A=pitch+60 -> 0<=A<=187
 1343 0425
 1344 0425 06 FA        L0425:  LD      B,$FA           ; 6 octaves below middle C
 1345 0427
 1346 0427              ;; BE-OCTAVE                    ; A=# semitones above 5 octaves below middle C
 1347 0427 04           L0427:  INC     B               ; increment octave
 1348 0428 D6 0C                SUB     $0C             ; 12 semitones = one octave
 1349 042A 30 FB                JR      NC,L0427        ; to BE-OCTAVE
 1350 042C
 1351 042C C6 0C                ADD     A,$0C           ; A = # semitones above C (0-11)
 1352 042E C5                   PUSH    BC              ; B = octave displacement from middle C, 2's complement: -5<=B<=10
 1353 042F 21 6E 04             LD      HL,L046E        ; Address: semi-tone
 1354 0432 CD 06 34             CALL    L3406           ; routine LOC-MEM
 1355 0435                                              ;   HL = 5*A + $046E
 1356 0435 CD B4 33             CALL    L33B4           ; routine STACK-NUM
 1357 0438                                              ;   read FP value (freq) from semitone table (HL) and push onto calc stack
 1358 0438
 1359 0438 EF                   RST     28H             ;; FP-CALC
 1360 0439 04                   DEFB    $04             ;;multiply   mult freq by 1 + 0.0576 * fraction_part(pitch) stacked earlier
 1361 043A                                              ;;             thus taking into account fractional part of pitch.
 1362 043A                                              ;;           the number 0.0576*frequency is the distance in Hz to the next
 1363 043A                                              ;;             note (verify with the frequencies recorded in the semitone
 1364 043A                                              ;;             table below) so that the fraction_part of the pitch does
 1365 043A                                              ;;             indeed represent a fractional distance to the next note.
 1366 043A 38                   DEFB    $38             ;;end-calc   HL points to first byte of fp num on stack = middle frequency to generate
 1367 043B
 1368 043B F1                   POP     AF              ; A = octave displacement from middle C, 2's complement: -5<=A<=10
 1369 043C 86                   ADD     A,(HL)          ; increase exponent by A (equivalent to multiplying by 2^A)
 1370 043D 77                   LD      (HL),A          ;
 1371 043E
 1372 043E EF                   RST     28H             ;; FP-CALC
 1373 043F C0                   DEFB    $C0             ;;st-mem-0          ; store frequency in memory 0
 1374 0440 02                   DEFB    $02             ;;delete            ; remove from calc stack
 1375 0441 31                   DEFB    $31             ;;duplicate         ; duplicate duration (seconds)
 1376 0442 38                   DEFB    $38             ;;end-calc
 1377 0443
 1378 0443 CD 94 1E             CALL    L1E94           ; routine FIND-INT1 ; FP duration to A
 1379 0446 FE 0B                CP      $0B             ; if dur > 10 seconds,
 1380 0448 30 22                JR      NC,L046C        ;   goto REPORT-B
 1381 044A
 1382 044A                      ;;; The following calculation finds the tone period for HL and the cycle count
 1383 044A                      ;;; for DE expected in the BEEPER subroutine.  From the example in the BEEPER comments,
 1384 044A                      ;;;
 1385 044A                      ;;; HL = ((fCPU / f) - 236) / 8 = fCPU/8/f - 236/8 = 437500/f -29.5
 1386 044A                      ;;; DE = duration * frequency - 1
 1387 044A                      ;;;
 1388 044A                      ;;; Note the different constant (30.125) used in the calculation of HL
 1389 044A                      ;;; below.  This is probably an error.
 1390 044A
 1391 044A EF                   RST     28H             ;; FP-CALC
 1392 044B E0                   DEFB    $E0             ;;get-mem-0                 ; push frequency
 1393 044C 04                   DEFB    $04             ;;multiply                  ; result1: #cycles = duration * frequency
 1394 044D E0                   DEFB    $E0             ;;get-mem-0                 ; push frequency
 1395 044E 34                   DEFB    $34             ;;stk-data                  ; push constant
 1396 044F 80                   DEFB    $80             ;;Exponent $93, Bytes: 3    ; constant = 437500
 1397 0450 43 55 9F 80          DEFB    $43,$55,$9F,$80 ;;($55,$9F,$80,$00)
 1398 0454 01                   DEFB    $01             ;;exchange                  ; frequency on top
 1399 0455 05                   DEFB    $05             ;;division                  ; 437500 / frequency
 1400 0456 34                   DEFB    $34             ;;stk-data                  ; push constant
 1401 0457 35                   DEFB    $35             ;;Exponent: $85, Bytes: 1   ; constant = 30.125
 1402 0458 71                   DEFB    $71             ;;($71,$00,$00,$00)
 1403 0459 03                   DEFB    $03             ;;subtract                  ; result2: tone_period(HL) = 437500 / freq - 30.125
 1404 045A 38                   DEFB    $38             ;;end-calc
 1405 045B
 1406 045B CD 99 1E             CALL    L1E99           ; routine FIND-INT2
 1407 045E C5                   PUSH    BC              ;   BC = tone_period(HL)
 1408 045F CD 99 1E             CALL    L1E99           ; routine FIND-INT2, BC = #cycles to generate
 1409 0462 E1                   POP     HL              ; HL = tone period
 1410 0463 50                   LD      D,B             ;
 1411 0464 59                   LD      E,C             ; DE = #cycles
 1412 0465 7A                   LD      A,D             ;
 1413 0466 B3                   OR      E               ;
 1414 0467 C8                   RET     Z               ; if duration = 0, skip BEEP and avoid 65536 cycle
 1415 0468                                              ;   boondoggle that would occur next
 1416 0468 1B                   DEC     DE              ; DE = #cycles - 1
 1417 0469 C3 B5 03             JP      L03B5           ; to BEEPER
 1418 046C
 1419 046C              ; ---
 1420 046C
 1421 046C
 1422 046C              ;; REPORT-B
 1423 046C CF           L046C:  RST     08H             ; ERROR-1
 1424 046D 0A                   DEFB    $0A             ; Error Report: Integer out of range
 1425 046E
 1426 046E
 1427 046E
 1428 046E              ; ---------------------
 1429 046E              ; THE 'SEMI-TONE' TABLE
 1430 046E              ; ---------------------
 1431 046E              ;
 1432 046E              ;   Holds frequencies corresponding to semitones in middle octave.
 1433 046E              ;   To move n octaves higher or lower, frequencies are multiplied by 2^n.
 1434 046E
 1435 046E              ;; semi-tone         five byte fp         decimal freq     note (middle)
 1436 046E 89 02 D0 12  L046E:  DEFB    $89, $02, $D0, $12, $86;  261.625565290         C
 1436 0472 86
 1437 0473 89 0A 97 60          DEFB    $89, $0A, $97, $60, $75;  277.182631135         C#
 1437 0477 75
 1438 0478 89 12 D5 17          DEFB    $89, $12, $D5, $17, $1F;  293.664768100         D
 1438 047C 1F
 1439 047D 89 1B 90 41          DEFB    $89, $1B, $90, $41, $02;  311.126983881         D#
 1439 0481 02
 1440 0482 89 24 D0 53          DEFB    $89, $24, $D0, $53, $CA;  329.627557039         E
 1440 0486 CA
 1441 0487 89 2E 9D 36          DEFB    $89, $2E, $9D, $36, $B1;  349.228231549         F
 1441 048B B1
 1442 048C 89 38 FF 49          DEFB    $89, $38, $FF, $49, $3E;  369.994422674         F#
 1442 0490 3E
 1443 0491 89 43 FF 6A          DEFB    $89, $43, $FF, $6A, $73;  391.995436072         G
 1443 0495 73
 1444 0496 89 4F A7 00          DEFB    $89, $4F, $A7, $00, $54;  415.304697513         G#
 1444 049A 54
 1445 049B 89 5C 00 00          DEFB    $89, $5C, $00, $00, $00;  440.000000000         A
 1445 049F 00
 1446 04A0 89 69 14 F6          DEFB    $89, $69, $14, $F6, $24;  466.163761616         A#
 1446 04A4 24
 1447 04A5 89 76 F1 10          DEFB    $89, $76, $F1, $10, $05;  493.883301378         B
 1447 04A9 05
 1448 04AA
 1449 04AA
 1450 04AA              ;   "Music is the hidden mathematical endeavour of a soul unconscious it
 1451 04AA              ;    is calculating" - Gottfried Wilhelm Liebnitz 1646 - 1716
 1452 04AA
 1453 04AA
 1454 04AA              ;****************************************
 1455 04AA              ;** Part 4. CASSETTE HANDLING ROUTINES **
 1456 04AA              ;****************************************
 1457 04AA
 1458 04AA              ;   These routines begin with the service routines followed by a single
 1459 04AA              ;   command entry point.
 1460 04AA              ;   The first of these service routines is a curiosity.
 1461 04AA
 1462 04AA              ; -----------------------
 1463 04AA              ; THE 'ZX81 NAME' ROUTINE
 1464 04AA              ; -----------------------
 1465 04AA              ;   This routine fetches a filename in ZX81 format and is not used by the
 1466 04AA              ;   cassette handling routines in this ROM.
 1467 04AA
 1468 04AA              ;; zx81-name
 1469 04AA CD FB 24     L04AA:  CALL    L24FB           ; routine SCANNING to evaluate expression.
 1470 04AD 3A 3B 5C             LD      A,($5C3B)       ; fetch system variable FLAGS.
 1471 04B0 87                   ADD     A,A             ; test bit 7 - syntax, bit 6 - result type.
 1472 04B1 FA 8A 1C             JP      M,L1C8A         ; to REPORT-C if not string result
 1473 04B4                                              ; 'Nonsense in BASIC'.
 1474 04B4
 1475 04B4 E1                   POP     HL              ; drop return address.
 1476 04B5 D0                   RET     NC              ; return early if checking syntax.
 1477 04B6
 1478 04B6 E5                   PUSH    HL              ; re-save return address.
 1479 04B7 CD F1 2B             CALL    L2BF1           ; routine STK-FETCH fetches string parameters.
 1480 04BA 62                   LD      H,D             ; transfer start of filename
 1481 04BB 6B                   LD      L,E             ; to the HL register.
 1482 04BC 0D                   DEC     C               ; adjust to point to last character and
 1483 04BD F8                   RET     M               ; return if the null string.
 1484 04BE                                              ; or multiple of 256!
 1485 04BE
 1486 04BE 09                   ADD     HL,BC           ; find last character of the filename.
 1487 04BF                                              ; and also clear carry.
 1488 04BF CB FE                SET     7,(HL)          ; invert it.
 1489 04C1 C9                   RET                     ; return.
 1490 04C2
 1491 04C2              ; =========================================
 1492 04C2              ;
 1493 04C2              ; PORT 254 ($FE)
 1494 04C2              ;
 1495 04C2              ;                      spk mic { border  }
 1496 04C2              ;          ___ ___ ___ ___ ___ ___ ___ ___
 1497 04C2              ; PORT    |   |   |   |   |   |   |   |   |
 1498 04C2              ; 254     |   |   |   |   |   |   |   |   |
 1499 04C2              ; $FE     |___|___|___|___|___|___|___|___|
 1500 04C2              ;           7   6   5   4   3   2   1   0
 1501 04C2              ;
 1502 04C2
 1503 04C2              ; ----------------------------------
 1504 04C2              ; Save header and program/data bytes
 1505 04C2              ; ----------------------------------
 1506 04C2              ;   This routine saves a section of data. It is called from SA-CTRL to save the
 1507 04C2              ;   seventeen bytes of header data. It is also the exit route from that routine
 1508 04C2              ;   when it is set up to save the actual data.
 1509 04C2              ;   On entry -
 1510 04C2              ;   HL points to start of data.
 1511 04C2              ;   IX points to descriptor.
 1512 04C2              ;   The accumulator is set to  $00 for a header, $FF for data.
 1513 04C2
 1514 04C2              ;; SA-BYTES
 1515 04C2 21 3F 05     L04C2:  LD      HL,L053F        ; address: SA/LD-RET
 1516 04C5 E5                   PUSH    HL              ; is pushed as common exit route.
 1517 04C6                                              ; however there is only one non-terminal exit
 1518 04C6                                              ; point.
 1519 04C6
 1520 04C6 21 80 1F             LD      HL,$1F80        ; a timing constant H=$1F, L=$80
 1521 04C9                                              ; inner and outer loop counters
 1522 04C9                                              ; a five second lead-in is used for a header.
 1523 04C9
 1524 04C9 CB 7F                BIT     7,A             ; test one bit of accumulator.
 1525 04CB                                              ; (AND A ?)
 1526 04CB 28 03                JR      Z,L04D0         ; skip to SA-FLAG if a header is being saved.
 1527 04CD
 1528 04CD              ;   else is data bytes and a shorter lead-in is used.
 1529 04CD
 1530 04CD 21 98 0C             LD      HL,$0C98        ; another timing value H=$0C, L=$98.
 1531 04D0                                              ; a two second lead-in is used for the data.
 1532 04D0
 1533 04D0
 1534 04D0              ;; SA-FLAG
 1535 04D0 08           L04D0:  EX      AF,AF'          ; save flag
 1536 04D1 13                   INC     DE              ; increase length by one.
 1537 04D2 DD 2B                DEC     IX              ; decrease start.
 1538 04D4
 1539 04D4 F3                   DI                      ; disable interrupts
 1540 04D5
 1541 04D5 3E 02                LD      A,$02           ; select red for border, microphone bit on.
 1542 04D7 47                   LD      B,A             ; also does as an initial slight counter value.
 1543 04D8
 1544 04D8              ;; SA-LEADER
 1545 04D8 10 FE        L04D8:  DJNZ    L04D8           ; self loop to SA-LEADER for delay.
 1546 04DA                                              ; after initial loop, count is $A4 (or $A3)
 1547 04DA
 1548 04DA D3 FE                OUT     ($FE),A         ; output byte $02/$0D to tape port.
 1549 04DC
 1550 04DC EE 0F                XOR     $0F             ; switch from RED (mic on) to CYAN (mic off).
 1551 04DE
 1552 04DE 06 A4                LD      B,$A4           ; hold count. also timed instruction.
 1553 04E0
 1554 04E0 2D                   DEC     L               ; originally $80 or $98.
 1555 04E1                                              ; but subsequently cycles 256 times.
 1556 04E1 20 F5                JR      NZ,L04D8        ; back to SA-LEADER until L is zero.
 1557 04E3
 1558 04E3              ;   the outer loop is counted by H
 1559 04E3
 1560 04E3 05                   DEC     B               ; decrement count
 1561 04E4 25                   DEC     H               ; originally  twelve or thirty-one.
 1562 04E5 F2 D8 04             JP      P,L04D8         ; back to SA-LEADER until H becomes $FF
 1563 04E8
 1564 04E8              ;   now send a sync pulse. At this stage mic is off and A holds value
 1565 04E8              ;   for mic on.
 1566 04E8              ;   A sync pulse is much shorter than the steady pulses of the lead-in.
 1567 04E8
 1568 04E8 06 2F                LD      B,$2F           ; another short timed delay.
 1569 04EA
 1570 04EA              ;; SA-SYNC-1
 1571 04EA 10 FE        L04EA:  DJNZ    L04EA           ; self loop to SA-SYNC-1
 1572 04EC
 1573 04EC D3 FE                OUT     ($FE),A         ; switch to mic on and red.
 1574 04EE 3E 0D                LD      A,$0D           ; prepare mic off - cyan
 1575 04F0 06 37                LD      B,$37           ; another short timed delay.
 1576 04F2
 1577 04F2              ;; SA-SYNC-2
 1578 04F2 10 FE        L04F2:  DJNZ    L04F2           ; self loop to SA-SYNC-2
 1579 04F4
 1580 04F4 D3 FE                OUT     ($FE),A         ; output mic off, cyan border.
 1581 04F6 01 0E 3B             LD      BC,$3B0E        ; B=$3B time(*), C=$0E, YELLOW, MIC OFF.
 1582 04F9
 1583 04F9              ;
 1584 04F9
 1585 04F9 08                   EX      AF,AF'          ; restore saved flag
 1586 04FA                                              ; which is 1st byte to be saved.
 1587 04FA
 1588 04FA 6F                   LD      L,A             ; and transfer to L.
 1589 04FB                                              ; the initial parity is A, $FF or $00.
 1590 04FB C3 07 05             JP      L0507           ; JUMP forward to SA-START     ->
 1591 04FE                                              ; the mid entry point of loop.
 1592 04FE
 1593 04FE              ; -------------------------
 1594 04FE              ;   During the save loop a parity byte is maintained in H.
 1595 04FE              ;   the save loop begins by testing if reduced length is zero and if so
 1596 04FE              ;   the final parity byte is saved reducing count to $FFFF.
 1597 04FE
 1598 04FE              ;; SA-LOOP
 1599 04FE 7A           L04FE:  LD      A,D             ; fetch high byte
 1600 04FF B3                   OR      E               ; test against low byte.
 1601 0500 28 0C                JR      Z,L050E         ; forward to SA-PARITY if zero.
 1602 0502
 1603 0502 DD 6E 00             LD      L,(IX+$00)      ; load currently addressed byte to L.
 1604 0505
 1605 0505              ;; SA-LOOP-P
 1606 0505 7C           L0505:  LD      A,H             ; fetch parity byte.
 1607 0506 AD                   XOR     L               ; exclusive or with new byte.
 1608 0507
 1609 0507              ; -> the mid entry point of loop.
 1610 0507
 1611 0507              ;; SA-START
 1612 0507 67           L0507:  LD      H,A             ; put parity byte in H.
 1613 0508 3E 01                LD      A,$01           ; prepare blue, mic=on.
 1614 050A 37                   SCF                     ; set carry flag ready to rotate in.
 1615 050B C3 25 05             JP      L0525           ; JUMP forward to SA-8-BITS            -8->
 1616 050E
 1617 050E              ; ---
 1618 050E
 1619 050E              ;; SA-PARITY
 1620 050E 6C           L050E:  LD      L,H             ; transfer the running parity byte to L and
 1621 050F 18 F4                JR      L0505           ; back to SA-LOOP-P
 1622 0511                                              ; to output that byte before quitting normally.
 1623 0511
 1624 0511              ; ---
 1625 0511
 1626 0511              ;   The entry point to save yellow part of bit.
 1627 0511              ;   A bit consists of a period with mic on and blue border followed by
 1628 0511              ;   a period of mic off with yellow border.
 1629 0511              ;   Note. since the DJNZ instruction does not affect flags, the zero flag is
 1630 0511              ;   used to indicate which of the two passes is in effect and the carry
 1631 0511              ;   maintains the state of the bit to be saved.
 1632 0511
 1633 0511              ;; SA-BIT-2
 1634 0511 79           L0511:  LD      A,C             ; fetch 'mic on and yellow' which is
 1635 0512                                              ; held permanently in C.
 1636 0512 CB 78                BIT     7,B             ; set the zero flag. B holds $3E.
 1637 0514
 1638 0514              ;   The entry point to save 1 entire bit. For first bit B holds $3B(*).
 1639 0514              ;   Carry is set if saved bit is 1. zero is reset NZ on entry.
 1640 0514
 1641 0514              ;; SA-BIT-1
 1642 0514 10 FE        L0514:  DJNZ    L0514           ; self loop for delay to SA-BIT-1
 1643 0516
 1644 0516 30 04                JR      NC,L051C        ; forward to SA-OUT if bit is 0.
 1645 0518
 1646 0518              ;   but if bit is 1 then the mic state is held for longer.
 1647 0518
 1648 0518 06 42                LD      B,$42           ; set timed delay. (66 decimal)
 1649 051A
 1650 051A              ;; SA-SET
 1651 051A 10 FE        L051A:  DJNZ    L051A           ; self loop to SA-SET
 1652 051C                                              ; (roughly an extra 66*13 clock cycles)
 1653 051C
 1654 051C              ;; SA-OUT
 1655 051C D3 FE        L051C:  OUT     ($FE),A         ; blue and mic on OR  yellow and mic off.
 1656 051E
 1657 051E 06 3E                LD      B,$3E           ; set up delay
 1658 0520 20 EF                JR      NZ,L0511        ; back to SA-BIT-2 if zero reset NZ (first pass)
 1659 0522
 1660 0522              ;   proceed when the blue and yellow bands have been output.
 1661 0522
 1662 0522 05                   DEC     B               ; change value $3E to $3D.
 1663 0523 AF                   XOR     A               ; clear carry flag (ready to rotate in).
 1664 0524 3C                   INC     A               ; reset zero flag i.e. NZ.
 1665 0525
 1666 0525              ; -8->
 1667 0525
 1668 0525              ;; SA-8-BITS
 1669 0525 CB 15        L0525:  RL      L               ; rotate left through carry
 1670 0527                                              ; C<76543210<C
 1671 0527 C2 14 05             JP      NZ,L0514        ; JUMP back to SA-BIT-1
 1672 052A                                              ; until all 8 bits done.
 1673 052A
 1674 052A              ;   when the initial set carry is passed out again then a byte is complete.
 1675 052A
 1676 052A 1B                   DEC     DE              ; decrease length
 1677 052B DD 23                INC     IX              ; increase byte pointer
 1678 052D 06 31                LD      B,$31           ; set up timing.
 1679 052F
 1680 052F 3E 7F                LD      A,$7F           ; test the space key and
 1681 0531 DB FE                IN      A,($FE)         ; return to common exit (to restore border)
 1682 0533 1F                   RRA                     ; if a space is pressed
 1683 0534 D0                   RET     NC              ; return to SA/LD-RET.   - - >
 1684 0535
 1685 0535              ;   now test if byte counter has reached $FFFF.
 1686 0535
 1687 0535 7A                   LD      A,D             ; fetch high byte
 1688 0536 3C                   INC     A               ; increment.
 1689 0537 C2 FE 04             JP      NZ,L04FE        ; JUMP to SA-LOOP if more bytes.
 1690 053A
 1691 053A 06 3B                LD      B,$3B           ; a final delay.
 1692 053C
 1693 053C              ;; SA-DELAY
 1694 053C 10 FE        L053C:  DJNZ    L053C           ; self loop to SA-DELAY
 1695 053E
 1696 053E C9                   RET                     ; return - - >
 1697 053F
 1698 053F              ; ------------------------------
 1699 053F              ; THE 'SAVE/LOAD RETURN' ROUTINE
 1700 053F              ; ------------------------------
 1701 053F              ;   The address of this routine is pushed on the stack prior to any load/save
 1702 053F              ;   operation and it handles normal completion with the restoration of the
 1703 053F              ;   border and also abnormal termination when the break key, or to be more
 1704 053F              ;   precise the space key is pressed during a tape operation.
 1705 053F              ;
 1706 053F              ; - - >
 1707 053F
 1708 053F              ;; SA/LD-RET
 1709 053F F5           L053F:  PUSH    AF              ; preserve accumulator throughout.
 1710 0540 3A 48 5C             LD      A,($5C48)       ; fetch border colour from BORDCR.
 1711 0543 E6 38                AND     $38             ; mask off paper bits.
 1712 0545 0F                   RRCA                    ; rotate
 1713 0546 0F                   RRCA                    ; to the
 1714 0547 0F                   RRCA                    ; range 0-7.
 1715 0548
 1716 0548 D3 FE                OUT     ($FE),A         ; change the border colour.
 1717 054A
 1718 054A 3E 7F                LD      A,$7F           ; read from port address $7FFE the
 1719 054C DB FE                IN      A,($FE)         ; row with the space key at outside.
 1720 054E
 1721 054E 1F                   RRA                     ; test for space key pressed.
 1722 054F FB                   EI                      ; enable interrupts
 1723 0550 38 02                JR      C,L0554         ; forward to SA/LD-END if not
 1724 0552
 1725 0552
 1726 0552              ;; REPORT-Da
 1727 0552 CF           L0552:  RST     08H             ; ERROR-1
 1728 0553 0C                   DEFB    $0C             ; Error Report: BREAK - CONT repeats
 1729 0554
 1730 0554              ; ---
 1731 0554
 1732 0554              ;; SA/LD-END
 1733 0554 F1           L0554:  POP     AF              ; restore the accumulator.
 1734 0555 C9                   RET                     ; return.
 1735 0556
 1736 0556              ; ------------------------------------
 1737 0556              ; Load header or block of information
 1738 0556              ; ------------------------------------
 1739 0556              ;   This routine is used to load bytes and on entry A is set to $00 for a
 1740 0556              ;   header or to $FF for data.  IX points to the start of receiving location
 1741 0556              ;   and DE holds the length of bytes to be loaded. If, on entry the carry flag
 1742 0556              ;   is set then data is loaded, if reset then it is verified.
 1743 0556
 1744 0556              ;; LD-BYTES
 1745 0556 14           L0556:  INC     D               ; reset the zero flag without disturbing carry.
 1746 0557 08                   EX      AF,AF'          ; preserve entry flags.
 1747 0558 15                   DEC     D               ; restore high byte of length.
 1748 0559
 1749 0559 F3                   DI                      ; disable interrupts
 1750 055A
 1751 055A 3E 0F                LD      A,$0F           ; make the border white and mic off.
 1752 055C D3 FE                OUT     ($FE),A         ; output to port.
 1753 055E
 1754 055E 21 3F 05             LD      HL,L053F        ; Address: SA/LD-RET
 1755 0561 E5                   PUSH    HL              ; is saved on stack as terminating routine.
 1756 0562
 1757 0562              ;   the reading of the EAR bit (D6) will always be preceded by a test of the
 1758 0562              ;   space key (D0), so store the initial post-test state.
 1759 0562
 1760 0562 DB FE                IN      A,($FE)         ; read the ear state - bit 6.
 1761 0564 1F                   RRA                     ; rotate to bit 5.
 1762 0565 E6 20                AND     $20             ; isolate this bit.
 1763 0567 F6 02                OR      $02             ; combine with red border colour.
 1764 0569 4F                   LD      C,A             ; and store initial state long-term in C.
 1765 056A BF                   CP      A               ; set the zero flag.
 1766 056B
 1767 056B              ;
 1768 056B
 1769 056B              ;; LD-BREAK
 1770 056B C0           L056B:  RET     NZ              ; return if at any time space is pressed.
 1771 056C
 1772 056C              ;; LD-START
 1773 056C CD E7 05     L056C:  CALL    L05E7           ; routine LD-EDGE-1
 1774 056F 30 FA                JR      NC,L056B        ; back to LD-BREAK with time out and no
 1775 0571                                              ; edge present on tape.
 1776 0571
 1777 0571              ;   but continue when a transition is found on tape.
 1778 0571
 1779 0571 21 15 04             LD      HL,$0415        ; set up 16-bit outer loop counter for
 1780 0574                                              ; approx 1 second delay.
 1781 0574
 1782 0574              ;; LD-WAIT
 1783 0574 10 FE        L0574:  DJNZ    L0574           ; self loop to LD-WAIT (for 256 times)
 1784 0576
 1785 0576 2B                   DEC     HL              ; decrease outer loop counter.
 1786 0577 7C                   LD      A,H             ; test for
 1787 0578 B5                   OR      L               ; zero.
 1788 0579 20 F9                JR      NZ,L0574        ; back to LD-WAIT, if not zero, with zero in B.
 1789 057B
 1790 057B              ;   continue after delay with H holding zero and B also.
 1791 057B              ;   sample 256 edges to check that we are in the middle of a lead-in section.
 1792 057B
 1793 057B CD E3 05             CALL    L05E3           ; routine LD-EDGE-2
 1794 057E 30 EB                JR      NC,L056B        ; back to LD-BREAK
 1795 0580                                              ; if no edges at all.
 1796 0580
 1797 0580              ;; LD-LEADER
 1798 0580 06 9C        L0580:  LD      B,$9C           ; set timing value.
 1799 0582 CD E3 05             CALL    L05E3           ; routine LD-EDGE-2
 1800 0585 30 E4                JR      NC,L056B        ; back to LD-BREAK if time-out
 1801 0587
 1802 0587 3E C6                LD      A,$C6           ; two edges must be spaced apart.
 1803 0589 B8                   CP      B               ; compare
 1804 058A 30 E0                JR      NC,L056C        ; back to LD-START if too close together for a
 1805 058C                                              ; lead-in.
 1806 058C
 1807 058C 24                   INC     H               ; proceed to test 256 edged sample.
 1808 058D 20 F1                JR      NZ,L0580        ; back to LD-LEADER while more to do.
 1809 058F
 1810 058F              ;   sample indicates we are in the middle of a two or five second lead-in.
 1811 058F              ;   Now test every edge looking for the terminal sync signal.
 1812 058F
 1813 058F              ;; LD-SYNC
 1814 058F 06 C9        L058F:  LD      B,$C9           ; initial timing value in B.
 1815 0591 CD E7 05             CALL    L05E7           ; routine LD-EDGE-1
 1816 0594 30 D5                JR      NC,L056B        ; back to LD-BREAK with time-out.
 1817 0596
 1818 0596 78                   LD      A,B             ; fetch augmented timing value from B.
 1819 0597 FE D4                CP      $D4             ; compare
 1820 0599 30 F4                JR      NC,L058F        ; back to LD-SYNC if gap too big, that is,
 1821 059B                                              ; a normal lead-in edge gap.
 1822 059B
 1823 059B              ;   but a short gap will be the sync pulse.
 1824 059B              ;   in which case another edge should appear before B rises to $FF
 1825 059B
 1826 059B CD E7 05             CALL    L05E7           ; routine LD-EDGE-1
 1827 059E D0                   RET     NC              ; return with time-out.
 1828 059F
 1829 059F              ; proceed when the sync at the end of the lead-in is found.
 1830 059F              ; We are about to load data so change the border colours.
 1831 059F
 1832 059F 79                   LD      A,C             ; fetch long-term mask from C
 1833 05A0 EE 03                XOR     $03             ; and make blue/yellow.
 1834 05A2
 1835 05A2 4F                   LD      C,A             ; store the new long-term byte.
 1836 05A3
 1837 05A3 26 00                LD      H,$00           ; set up parity byte as zero.
 1838 05A5 06 B0                LD      B,$B0           ; timing.
 1839 05A7 18 1F                JR      L05C8           ; forward to LD-MARKER
 1840 05A9                                              ; the loop mid entry point with the alternate
 1841 05A9                                              ; zero flag reset to indicate first byte
 1842 05A9                                              ; is discarded.
 1843 05A9
 1844 05A9              ; --------------
 1845 05A9              ;   the loading loop loads each byte and is entered at the mid point.
 1846 05A9
 1847 05A9              ;; LD-LOOP
 1848 05A9 08           L05A9:  EX      AF,AF'          ; restore entry flags and type in A.
 1849 05AA 20 07                JR      NZ,L05B3        ; forward to LD-FLAG if awaiting initial flag
 1850 05AC                                              ; which is to be discarded.
 1851 05AC
 1852 05AC 30 0F                JR      NC,L05BD        ; forward to LD-VERIFY if not to be loaded.
 1853 05AE
 1854 05AE DD 75 00             LD      (IX+$00),L      ; place loaded byte at memory location.
 1855 05B1 18 0F                JR      L05C2           ; forward to LD-NEXT
 1856 05B3
 1857 05B3              ; ---
 1858 05B3
 1859 05B3              ;; LD-FLAG
 1860 05B3 CB 11        L05B3:  RL      C               ; preserve carry (verify) flag in long-term
 1861 05B5                                              ; state byte. Bit 7 can be lost.
 1862 05B5
 1863 05B5 AD                   XOR     L               ; compare type in A with first byte in L.
 1864 05B6 C0                   RET     NZ              ; return if no match e.g. CODE vs. DATA.
 1865 05B7
 1866 05B7              ;   continue when data type matches.
 1867 05B7
 1868 05B7 79                   LD      A,C             ; fetch byte with stored carry
 1869 05B8 1F                   RRA                     ; rotate it to carry flag again
 1870 05B9 4F                   LD      C,A             ; restore long-term port state.
 1871 05BA
 1872 05BA 13                   INC     DE              ; increment length ??
 1873 05BB 18 07                JR      L05C4           ; forward to LD-DEC.
 1874 05BD                                              ; but why not to location after ?
 1875 05BD
 1876 05BD              ; ---
 1877 05BD              ;   for verification the byte read from tape is compared with that in memory.
 1878 05BD
 1879 05BD              ;; LD-VERIFY
 1880 05BD DD 7E 00     L05BD:  LD      A,(IX+$00)      ; fetch byte from memory.
 1881 05C0 AD                   XOR     L               ; compare with that on tape
 1882 05C1 C0                   RET     NZ              ; return if not zero.
 1883 05C2
 1884 05C2              ;; LD-NEXT
 1885 05C2 DD 23        L05C2:  INC     IX              ; increment byte pointer.
 1886 05C4
 1887 05C4              ;; LD-DEC
 1888 05C4 1B           L05C4:  DEC     DE              ; decrement length.
 1889 05C5 08                   EX      AF,AF'          ; store the flags.
 1890 05C6 06 B2                LD      B,$B2           ; timing.
 1891 05C8
 1892 05C8              ;   when starting to read 8 bits the receiving byte is marked with bit at right.
 1893 05C8              ;   when this is rotated out again then 8 bits have been read.
 1894 05C8
 1895 05C8              ;; LD-MARKER
 1896 05C8 2E 01        L05C8:  LD      L,$01           ; initialize as %00000001
 1897 05CA
 1898 05CA              ;; LD-8-BITS
 1899 05CA CD E3 05     L05CA:  CALL    L05E3           ; routine LD-EDGE-2 increments B relative to
 1900 05CD                                              ; gap between 2 edges.
 1901 05CD D0                   RET     NC              ; return with time-out.
 1902 05CE
 1903 05CE 3E CB                LD      A,$CB           ; the comparison byte.
 1904 05D0 B8                   CP      B               ; compare to incremented value of B.
 1905 05D1                                              ; if B is higher then bit on tape was set.
 1906 05D1                                              ; if <= then bit on tape is reset.
 1907 05D1
 1908 05D1 CB 15                RL      L               ; rotate the carry bit into L.
 1909 05D3
 1910 05D3 06 B0                LD      B,$B0           ; reset the B timer byte.
 1911 05D5 D2 CA 05             JP      NC,L05CA        ; JUMP back to LD-8-BITS
 1912 05D8
 1913 05D8              ;   when carry set then marker bit has been passed out and byte is complete.
 1914 05D8
 1915 05D8 7C                   LD      A,H             ; fetch the running parity byte.
 1916 05D9 AD                   XOR     L               ; include the new byte.
 1917 05DA 67                   LD      H,A             ; and store back in parity register.
 1918 05DB
 1919 05DB 7A                   LD      A,D             ; check length of
 1920 05DC B3                   OR      E               ; expected bytes.
 1921 05DD 20 CA                JR      NZ,L05A9        ; back to LD-LOOP
 1922 05DF                                              ; while there are more.
 1923 05DF
 1924 05DF              ;   when all bytes loaded then parity byte should be zero.
 1925 05DF
 1926 05DF 7C                   LD      A,H             ; fetch parity byte.
 1927 05E0 FE 01                CP      $01             ; set carry if zero.
 1928 05E2 C9                   RET                     ; return
 1929 05E3                                              ; in no carry then error as checksum disagrees.
 1930 05E3
 1931 05E3              ; -------------------------
 1932 05E3              ; Check signal being loaded
 1933 05E3              ; -------------------------
 1934 05E3              ;   An edge is a transition from one mic state to another.
 1935 05E3              ;   More specifically a change in bit 6 of value input from port $FE.
 1936 05E3              ;   Graphically it is a change of border colour, say, blue to yellow.
 1937 05E3              ;   The first entry point looks for two adjacent edges. The second entry point
 1938 05E3              ;   is used to find a single edge.
 1939 05E3              ;   The B register holds a count, up to 256, within which the edge (or edges)
 1940 05E3              ;   must be found. The gap between two edges will be more for a '1' than a '0'
 1941 05E3              ;   so the value of B denotes the state of the bit (two edges) read from tape.
 1942 05E3
 1943 05E3              ; ->
 1944 05E3
 1945 05E3              ;; LD-EDGE-2
 1946 05E3 CD E7 05     L05E3:  CALL    L05E7           ; call routine LD-EDGE-1 below.
 1947 05E6 D0                   RET     NC              ; return if space pressed or time-out.
 1948 05E7                                              ; else continue and look for another adjacent
 1949 05E7                                              ; edge which together represent a bit on the
 1950 05E7                                              ; tape.
 1951 05E7
 1952 05E7              ; ->
 1953 05E7              ;   this entry point is used to find a single edge from above but also
 1954 05E7              ;   when detecting a read-in signal on the tape.
 1955 05E7
 1956 05E7              ;; LD-EDGE-1
 1957 05E7 3E 16        L05E7:  LD      A,$16           ; a delay value of twenty two.
 1958 05E9
 1959 05E9              ;; LD-DELAY
 1960 05E9 3D           L05E9:  DEC     A               ; decrement counter
 1961 05EA 20 FD                JR      NZ,L05E9        ; loop back to LD-DELAY 22 times.
 1962 05EC
 1963 05EC A7                   AND      A              ; clear carry.
 1964 05ED
 1965 05ED              ;; LD-SAMPLE
 1966 05ED 04           L05ED:  INC     B               ; increment the time-out counter.
 1967 05EE C8                   RET     Z               ; return with failure when $FF passed.
 1968 05EF
 1969 05EF 3E 7F                LD      A,$7F           ; prepare to read keyboard and EAR port
 1970 05F1 DB FE                IN      A,($FE)         ; row $7FFE. bit 6 is EAR, bit 0 is SPACE key.
 1971 05F3 1F                   RRA                     ; test outer key the space. (bit 6 moves to 5)
 1972 05F4 D0                   RET     NC              ; return if space pressed.  >>>
 1973 05F5
 1974 05F5 A9                   XOR     C               ; compare with initial long-term state.
 1975 05F6 E6 20                AND     $20             ; isolate bit 5
 1976 05F8 28 F3                JR      Z,L05ED         ; back to LD-SAMPLE if no edge.
 1977 05FA
 1978 05FA              ;   but an edge, a transition of the EAR bit, has been found so switch the
 1979 05FA              ;   long-term comparison byte containing both border colour and EAR bit.
 1980 05FA
 1981 05FA 79                   LD      A,C             ; fetch comparison value.
 1982 05FB 2F                   CPL                     ; switch the bits
 1983 05FC 4F                   LD      C,A             ; and put back in C for long-term.
 1984 05FD
 1985 05FD E6 07                AND     $07             ; isolate new colour bits.
 1986 05FF F6 08                OR      $08             ; set bit 3 - MIC off.
 1987 0601 D3 FE                OUT     ($FE),A         ; send to port to effect the change of colour.
 1988 0603
 1989 0603 37                   SCF                     ; set carry flag signaling edge found within
 1990 0604                                              ; time allowed.
 1991 0604 C9                   RET                     ; return.
 1992 0605
 1993 0605              ; ---------------------------------
 1994 0605              ; Entry point for all tape commands
 1995 0605              ; ---------------------------------
 1996 0605              ;   This is the single entry point for the four tape commands.
 1997 0605              ;   The routine first determines in what context it has been called by examining
 1998 0605              ;   the low byte of the Syntax table entry which was stored in T_ADDR.
 1999 0605              ;   Subtracting $EO (the present arrangement) gives a value of
 2000 0605              ;   $00 - SAVE
 2001 0605              ;   $01 - LOAD
 2002 0605              ;   $02 - VERIFY
 2003 0605              ;   $03 - MERGE
 2004 0605              ;   As with all commands the address STMT-RET is on the stack.
 2005 0605
 2006 0605              ;; SAVE-ETC
 2007 0605 F1           L0605:  POP     AF              ; discard address STMT-RET.
 2008 0606 3A 74 5C             LD      A,($5C74)       ; fetch T_ADDR
 2009 0609
 2010 0609              ;   Now reduce the low byte of the Syntax table entry to give command.
 2011 0609              ;   Note. For ZASM use SUB $E0 as next instruction.
 2012 0609
spectrum_rom.asm(2013): warning: value 0x1AE0 is truncated to 8bit value: 0xE0
 2013 0609 D6 E0        L0609:  SUB     L1ADF + 1 % 256 ; subtract the known offset.
 2014 060B                                              ; ( is SUB $E0 in standard ROM )
 2015 060B
 2016 060B 32 74 5C             LD      ($5C74),A       ; and put back in T_ADDR as 0,1,2, or 3
 2017 060E                                              ; for future reference.
 2018 060E
 2019 060E CD 8C 1C             CALL    L1C8C           ; routine EXPT-EXP checks that a string
 2020 0611                                              ; expression follows and stacks the
 2021 0611                                              ; parameters in run-time.
 2022 0611
 2023 0611 CD 30 25             CALL    L2530           ; routine SYNTAX-Z
 2024 0614 28 3C                JR      Z,L0652         ; forward to SA-DATA if checking syntax.
 2025 0616
 2026 0616 01 11 00             LD      BC,$0011        ; presume seventeen bytes for a header.
 2027 0619 3A 74 5C             LD      A,($5C74)       ; fetch command from T_ADDR.
 2028 061C A7                   AND     A               ; test for zero - SAVE.
 2029 061D 28 02                JR      Z,L0621         ; forward to SA-SPACE if so.
 2030 061F
 2031 061F 0E 22                LD      C,$22           ; else double length to thirty four.
 2032 0621
 2033 0621              ;; SA-SPACE
 2034 0621 F7           L0621:  RST     30H             ; BC-SPACES creates 17/34 bytes in workspace.
 2035 0622
 2036 0622 D5                   PUSH    DE              ; transfer the start of new space to
 2037 0623 DD E1                POP     IX              ; the available index register.
 2038 0625
 2039 0625              ;   ten spaces are required for the default filename but it is simpler to
 2040 0625              ;   overwrite the first file-type indicator byte as well.
 2041 0625
 2042 0625 06 0B                LD      B,$0B           ; set counter to eleven.
 2043 0627 3E 20                LD      A,$20           ; prepare a space.
 2044 0629
 2045 0629              ;; SA-BLANK
 2046 0629 12           L0629:  LD      (DE),A          ; set workspace location to space.
 2047 062A 13                   INC     DE              ; next location.
 2048 062B 10 FC                DJNZ    L0629           ; loop back to SA-BLANK till all eleven done.
 2049 062D
 2050 062D DD 36 01 FF          LD      (IX+$01),$FF    ; set first byte of ten character filename
 2051 0631                                              ; to $FF as a default to signal null string.
 2052 0631
 2053 0631 CD F1 2B             CALL    L2BF1           ; routine STK-FETCH fetches the filename
 2054 0634                                              ; parameters from the calculator stack.
 2055 0634                                              ; length of string in BC.
 2056 0634                                              ; start of string in DE.
 2057 0634
 2058 0634 21 F6 FF             LD      HL,$FFF6        ; prepare the value minus ten.
 2059 0637 0B                   DEC     BC              ; decrement length.
 2060 0638                                              ; ten becomes nine, zero becomes $FFFF.
 2061 0638 09                   ADD     HL,BC           ; trial addition.
 2062 0639 03                   INC     BC              ; restore true length.
 2063 063A 30 0F                JR      NC,L064B        ; forward to SA-NAME if length is one to ten.
 2064 063C
 2065 063C              ;   the filename is more than ten characters in length or the null string.
 2066 063C
 2067 063C 3A 74 5C             LD      A,($5C74)       ; fetch command from T_ADDR.
 2068 063F A7                   AND     A               ; test for zero - SAVE.
 2069 0640 20 02                JR      NZ,L0644        ; forward to SA-NULL if not the SAVE command.
 2070 0642
 2071 0642              ;   but no more than ten characters are allowed for SAVE.
 2072 0642              ;   The first ten characters of any other command parameter are acceptable.
 2073 0642              ;   Weird, but necessary, if saving to sectors.
 2074 0642              ;   Note. the golden rule that there are no restriction on anything is broken.
 2075 0642
 2076 0642              ;; REPORT-Fa
 2077 0642 CF           L0642:  RST     08H             ; ERROR-1
 2078 0643 0E                   DEFB    $0E             ; Error Report: Invalid file name
 2079 0644
 2080 0644              ;   continue with LOAD, MERGE, VERIFY and also SAVE within ten character limit.
 2081 0644
 2082 0644              ;; SA-NULL
 2083 0644 78           L0644:  LD      A,B             ; test length of filename
 2084 0645 B1                   OR      C               ; for zero.
 2085 0646 28 0A                JR      Z,L0652         ; forward to SA-DATA if so using the 255
 2086 0648                                              ; indicator followed by spaces.
 2087 0648
 2088 0648 01 0A 00             LD      BC,$000A        ; else trim length to ten.
 2089 064B
 2090 064B              ;   other paths rejoin here with BC holding length in range 1 - 10.
 2091 064B
 2092 064B              ;; SA-NAME
 2093 064B DD E5        L064B:  PUSH    IX              ; push start of file descriptor.
 2094 064D E1                   POP     HL              ; and pop into HL.
 2095 064E
 2096 064E 23                   INC     HL              ; HL now addresses first byte of filename.
 2097 064F EB                   EX      DE,HL           ; transfer destination address to DE, start
 2098 0650                                              ; of string in command to HL.
 2099 0650 ED B0                LDIR                    ; copy up to ten bytes
 2100 0652                                              ; if less than ten then trailing spaces follow.
 2101 0652
 2102 0652              ;   the case for the null string rejoins here.
 2103 0652
 2104 0652              ;; SA-DATA
 2105 0652 DF           L0652:  RST     18H             ; GET-CHAR
 2106 0653 FE E4                CP      $E4             ; is character after filename the token 'DATA' ?
 2107 0655 20 49                JR      NZ,L06A0        ; forward to SA-SCR$ to consider SCREEN$ if
 2108 0657                                              ; not.
 2109 0657
 2110 0657              ;   continue to consider DATA.
 2111 0657
 2112 0657 3A 74 5C             LD      A,($5C74)       ; fetch command from T_ADDR
 2113 065A FE 03                CP      $03             ; is it 'VERIFY' ?
 2114 065C CA 8A 1C             JP      Z,L1C8A         ; jump forward to REPORT-C if so.
 2115 065F                                              ; 'Nonsense in BASIC'
 2116 065F                                              ; VERIFY "d" DATA is not allowed.
 2117 065F
 2118 065F              ;   continue with SAVE, LOAD, MERGE of DATA.
 2119 065F
 2120 065F E7                   RST     20H             ; NEXT-CHAR
 2121 0660 CD B2 28             CALL    L28B2           ; routine LOOK-VARS searches variables area
 2122 0663                                              ; returning with carry reset if found or
 2123 0663                                              ; checking syntax.
 2124 0663 CB F9                SET     7,C             ; this converts a simple string to a
 2125 0665                                              ; string array. The test for an array or string
 2126 0665                                              ; comes later.
 2127 0665 30 0B                JR      NC,L0672        ; forward to SA-V-OLD if variable found.
 2128 0667
 2129 0667 21 00 00             LD      HL,$0000        ; set destination to zero as not fixed.
 2130 066A 3A 74 5C             LD      A,($5C74)       ; fetch command from T_ADDR
 2131 066D 3D                   DEC     A               ; test for 1 - LOAD
 2132 066E 28 15                JR      Z,L0685         ; forward to SA-V-NEW with LOAD DATA.
 2133 0670                                              ; to load a new array.
 2134 0670
 2135 0670              ;   otherwise the variable was not found in run-time with SAVE/MERGE.
 2136 0670
 2137 0670              ;; REPORT-2a
 2138 0670 CF           L0670:  RST     08H             ; ERROR-1
 2139 0671 01                   DEFB    $01             ; Error Report: Variable not found
 2140 0672
 2141 0672              ;   continue with SAVE/LOAD  DATA
 2142 0672
 2143 0672              ;; SA-V-OLD
 2144 0672 C2 8A 1C     L0672:  JP      NZ,L1C8A        ; to REPORT-C if not an array variable.
 2145 0675                                              ; or erroneously a simple string.
 2146 0675                                              ; 'Nonsense in BASIC'
 2147 0675
 2148 0675
 2149 0675 CD 30 25             CALL    L2530           ; routine SYNTAX-Z
 2150 0678 28 18                JR      Z,L0692         ; forward to SA-DATA-1 if checking syntax.
 2151 067A
 2152 067A 23                   INC     HL              ; step past single character variable name.
 2153 067B 7E                   LD      A,(HL)          ; fetch low byte of length.
 2154 067C DD 77 0B             LD      (IX+$0B),A      ; place in descriptor.
 2155 067F 23                   INC     HL              ; point to high byte.
 2156 0680 7E                   LD      A,(HL)          ; and transfer that
 2157 0681 DD 77 0C             LD      (IX+$0C),A      ; to descriptor.
 2158 0684 23                   INC     HL              ; increase pointer within variable.
 2159 0685
 2160 0685              ;; SA-V-NEW
 2161 0685 DD 71 0E     L0685:  LD      (IX+$0E),C      ; place character array name in  header.
 2162 0688 3E 01                LD      A,$01           ; default to type numeric.
 2163 068A CB 71                BIT     6,C             ; test result from look-vars.
 2164 068C 28 01                JR      Z,L068F         ; forward to SA-V-TYPE if numeric.
 2165 068E
 2166 068E 3C                   INC     A               ; set type to 2 - string array.
 2167 068F
 2168 068F              ;; SA-V-TYPE
 2169 068F DD 77 00     L068F:  LD      (IX+$00),A      ; place type 0, 1 or 2 in descriptor.
 2170 0692
 2171 0692              ;; SA-DATA-1
 2172 0692 EB           L0692:  EX      DE,HL           ; save var pointer in DE
 2173 0693
 2174 0693 E7                   RST     20H             ; NEXT-CHAR
 2175 0694 FE 29                CP      $29             ; is character ')' ?
 2176 0696 20 DA                JR      NZ,L0672        ; back if not to SA-V-OLD to report
 2177 0698                                              ; 'Nonsense in BASIC'
 2178 0698
 2179 0698 E7                   RST     20H             ; NEXT-CHAR advances character address.
 2180 0699 CD EE 1B             CALL    L1BEE           ; routine CHECK-END errors if not end of
 2181 069C                                              ; the statement.
 2182 069C
 2183 069C EB                   EX      DE,HL           ; bring back variables data pointer.
 2184 069D C3 5A 07             JP      L075A           ; jump forward to SA-ALL
 2185 06A0
 2186 06A0              ; ---
 2187 06A0              ;   the branch was here to consider a 'SCREEN$', the display file.
 2188 06A0
 2189 06A0              ;; SA-SCR$
 2190 06A0 FE AA        L06A0:  CP      $AA             ; is character the token 'SCREEN$' ?
 2191 06A2 20 1F                JR      NZ,L06C3        ; forward to SA-CODE if not.
 2192 06A4
 2193 06A4 3A 74 5C             LD      A,($5C74)       ; fetch command from T_ADDR
 2194 06A7 FE 03                CP      $03             ; is it MERGE ?
 2195 06A9 CA 8A 1C             JP       Z,L1C8A        ; jump to REPORT-C if so.
 2196 06AC                                              ; 'Nonsense in BASIC'
 2197 06AC
 2198 06AC              ;   continue with SAVE/LOAD/VERIFY SCREEN$.
 2199 06AC
 2200 06AC E7                   RST     20H             ; NEXT-CHAR
 2201 06AD CD EE 1B             CALL    L1BEE           ; routine CHECK-END errors if not at end of
 2202 06B0                                              ; statement.
 2203 06B0
 2204 06B0              ;   continue in runtime.
 2205 06B0
 2206 06B0 DD 36 0B 00          LD      (IX+$0B),$00    ; set descriptor length
 2207 06B4 DD 36 0C 1B          LD      (IX+$0C),$1B    ; to $1b00 to include bitmaps and attributes.
 2208 06B8
 2209 06B8 21 00 40             LD      HL,$4000        ; set start to display file start.
 2210 06BB DD 75 0D             LD      (IX+$0D),L      ; place start in
 2211 06BE DD 74 0E             LD      (IX+$0E),H      ; the descriptor.
 2212 06C1 18 4D                JR      L0710           ; forward to SA-TYPE-3
 2213 06C3
 2214 06C3              ; ---
 2215 06C3              ;   the branch was here to consider CODE.
 2216 06C3
 2217 06C3              ;; SA-CODE
 2218 06C3 FE AF        L06C3:  CP      $AF             ; is character the token 'CODE' ?
 2219 06C5 20 4F                JR      NZ,L0716        ; forward if not to SA-LINE to consider an
 2220 06C7                                              ; auto-started BASIC program.
 2221 06C7
 2222 06C7 3A 74 5C             LD      A,($5C74)       ; fetch command from T_ADDR
 2223 06CA FE 03                CP      $03             ; is it MERGE ?
 2224 06CC CA 8A 1C             JP      Z,L1C8A         ; jump forward to REPORT-C if so.
 2225 06CF                                              ; 'Nonsense in BASIC'
 2226 06CF
 2227 06CF
 2228 06CF E7                   RST     20H             ; NEXT-CHAR advances character address.
 2229 06D0 CD 48 20             CALL    L2048           ; routine PR-ST-END checks if a carriage
 2230 06D3                                              ; return or ':' follows.
 2231 06D3 20 0C                JR      NZ,L06E1        ; forward to SA-CODE-1 if there are parameters.
 2232 06D5
 2233 06D5 3A 74 5C             LD      A,($5C74)       ; else fetch the command from T_ADDR.
 2234 06D8 A7                   AND     A               ; test for zero - SAVE without a specification.
 2235 06D9 CA 8A 1C             JP      Z,L1C8A         ; jump to REPORT-C if so.
 2236 06DC                                              ; 'Nonsense in BASIC'
 2237 06DC
 2238 06DC              ;   for LOAD/VERIFY put zero on stack to signify handle at location saved from.
 2239 06DC
 2240 06DC CD E6 1C             CALL    L1CE6           ; routine USE-ZERO
 2241 06DF 18 0F                JR      L06F0           ; forward to SA-CODE-2
 2242 06E1
 2243 06E1              ; ---
 2244 06E1
 2245 06E1              ;   if there are more characters after CODE expect start and possibly length.
 2246 06E1
 2247 06E1              ;; SA-CODE-1
 2248 06E1 CD 82 1C     L06E1:  CALL    L1C82           ; routine EXPT-1NUM checks for numeric
 2249 06E4                                              ; expression and stacks it in run-time.
 2250 06E4
 2251 06E4 DF                   RST     18H             ; GET-CHAR
 2252 06E5 FE 2C                CP      $2C             ; does a comma follow ?
 2253 06E7 28 0C                JR      Z,L06F5         ; forward if so to SA-CODE-3
 2254 06E9
 2255 06E9              ;   else allow saved code to be loaded to a specified address.
 2256 06E9
 2257 06E9 3A 74 5C             LD      A,($5C74)       ; fetch command from T_ADDR.
 2258 06EC A7                   AND     A               ; is the command SAVE which requires length ?
 2259 06ED CA 8A 1C             JP      Z,L1C8A         ; jump to REPORT-C if so.
 2260 06F0                                              ; 'Nonsense in BASIC'
 2261 06F0
 2262 06F0              ;   the command LOAD code may rejoin here with zero stacked as start.
 2263 06F0
 2264 06F0              ;; SA-CODE-2
 2265 06F0 CD E6 1C     L06F0:  CALL    L1CE6           ; routine USE-ZERO stacks zero for length.
 2266 06F3 18 04                JR      L06F9           ; forward to SA-CODE-4
 2267 06F5
 2268 06F5              ; ---
 2269 06F5              ;   the branch was here with SAVE CODE start,
 2270 06F5
 2271 06F5              ;; SA-CODE-3
 2272 06F5 E7           L06F5:  RST     20H             ; NEXT-CHAR advances character address.
 2273 06F6 CD 82 1C             CALL    L1C82           ; routine EXPT-1NUM checks for expression
 2274 06F9                                              ; and stacks in run-time.
 2275 06F9
 2276 06F9              ;   paths converge here and nothing must follow.
 2277 06F9
 2278 06F9              ;; SA-CODE-4
 2279 06F9 CD EE 1B     L06F9:  CALL    L1BEE           ; routine CHECK-END errors with extraneous
 2280 06FC                                              ; characters and quits if checking syntax.
 2281 06FC
 2282 06FC              ;   in run-time there are two 16-bit parameters on the calculator stack.
 2283 06FC
 2284 06FC CD 99 1E             CALL    L1E99           ; routine FIND-INT2 gets length.
 2285 06FF DD 71 0B             LD      (IX+$0B),C      ; place length
 2286 0702 DD 70 0C             LD      (IX+$0C),B      ; in descriptor.
 2287 0705 CD 99 1E             CALL    L1E99           ; routine FIND-INT2 gets start.
 2288 0708 DD 71 0D             LD      (IX+$0D),C      ; place start
 2289 070B DD 70 0E             LD      (IX+$0E),B      ; in descriptor.
 2290 070E 60                   LD      H,B             ; transfer the
 2291 070F 69                   LD      L,C             ; start to HL also.
 2292 0710
 2293 0710              ;; SA-TYPE-3
 2294 0710 DD 36 00 03  L0710:  LD      (IX+$00),$03    ; place type 3 - code in descriptor.
 2295 0714 18 44                JR      L075A           ; forward to SA-ALL.
 2296 0716
 2297 0716              ; ---
 2298 0716              ;   the branch was here with BASIC to consider an optional auto-start line
 2299 0716              ;   number.
 2300 0716
 2301 0716              ;; SA-LINE
 2302 0716 FE CA        L0716:  CP      $CA             ; is character the token 'LINE' ?
 2303 0718 28 09                JR      Z,L0723         ; forward to SA-LINE-1 if so.
 2304 071A
 2305 071A              ;   else all possibilities have been considered and nothing must follow.
 2306 071A
 2307 071A CD EE 1B             CALL    L1BEE           ; routine CHECK-END
 2308 071D
 2309 071D              ;   continue in run-time to save BASIC without auto-start.
 2310 071D
 2311 071D DD 36 0E 80          LD      (IX+$0E),$80    ; place high line number in descriptor to
 2312 0721                                              ; disable auto-start.
 2313 0721 18 17                JR      L073A           ; forward to SA-TYPE-0 to save program.
 2314 0723
 2315 0723              ; ---
 2316 0723              ;   the branch was here to consider auto-start.
 2317 0723
 2318 0723              ;; SA-LINE-1
 2319 0723 3A 74 5C     L0723:  LD      A,($5C74)       ; fetch command from T_ADDR
 2320 0726 A7                   AND     A               ; test for SAVE.
 2321 0727 C2 8A 1C             JP      NZ,L1C8A        ; jump forward to REPORT-C with anything else.
 2322 072A                                              ; 'Nonsense in BASIC'
 2323 072A
 2324 072A              ;
 2325 072A
 2326 072A E7                   RST     20H             ; NEXT-CHAR
 2327 072B CD 82 1C             CALL    L1C82           ; routine EXPT-1NUM checks for numeric
 2328 072E                                              ; expression and stacks in run-time.
 2329 072E CD EE 1B             CALL    L1BEE           ; routine CHECK-END quits if syntax path.
 2330 0731 CD 99 1E             CALL    L1E99           ; routine FIND-INT2 fetches the numeric
 2331 0734                                              ; expression.
 2332 0734 DD 71 0D             LD      (IX+$0D),C      ; place the auto-start
 2333 0737 DD 70 0E             LD      (IX+$0E),B      ; line number in the descriptor.
 2334 073A
 2335 073A              ;   Note. this isn't checked, but is subsequently handled by the system.
 2336 073A              ;   If the user typed 40000 instead of 4000 then it won't auto-start
 2337 073A              ;   at line 4000, or indeed, at all.
 2338 073A
 2339 073A              ;   continue to save program and any variables.
 2340 073A
 2341 073A              ;; SA-TYPE-0
 2342 073A DD 36 00 00  L073A:  LD      (IX+$00),$00    ; place type zero - program in descriptor.
 2343 073E 2A 59 5C             LD      HL,($5C59)      ; fetch E_LINE to HL.
 2344 0741 ED 5B 53 5C          LD      DE,($5C53)      ; fetch PROG to DE.
 2345 0745 37                   SCF                     ; set carry flag to calculate from end of
 2346 0746                                              ; variables E_LINE -1.
 2347 0746 ED 52                SBC     HL,DE           ; subtract to give total length.
 2348 0748
 2349 0748 DD 75 0B             LD      (IX+$0B),L      ; place total length
 2350 074B DD 74 0C             LD      (IX+$0C),H      ; in descriptor.
 2351 074E 2A 4B 5C             LD      HL,($5C4B)      ; load HL from system variable VARS
 2352 0751 ED 52                SBC     HL,DE           ; subtract to give program length.
 2353 0753 DD 75 0F             LD      (IX+$0F),L      ; place length of program
 2354 0756 DD 74 10             LD      (IX+$10),H      ; in the descriptor.
 2355 0759 EB                   EX      DE,HL           ; start to HL, length to DE.
 2356 075A
 2357 075A              ;; SA-ALL
 2358 075A 3A 74 5C     L075A:  LD      A,($5C74)       ; fetch command from T_ADDR
 2359 075D A7                   AND     A               ; test for zero - SAVE.
 2360 075E CA 70 09             JP      Z,L0970         ; jump forward to SA-CONTRL with SAVE  ->
 2361 0761
 2362 0761              ; ---
 2363 0761              ;   continue with LOAD, MERGE and VERIFY.
 2364 0761
 2365 0761 E5                   PUSH    HL              ; save start.
 2366 0762 01 11 00             LD      BC,$0011        ; prepare to add seventeen
 2367 0765 DD 09                ADD     IX,BC           ; to point IX at second descriptor.
 2368 0767
 2369 0767              ;; LD-LOOK-H
 2370 0767 DD E5        L0767:  PUSH    IX              ; save IX
 2371 0769 11 11 00             LD      DE,$0011        ; seventeen bytes
 2372 076C AF                   XOR     A               ; reset zero flag
 2373 076D 37                   SCF                     ; set carry flag
 2374 076E CD 56 05             CALL    L0556           ; routine LD-BYTES loads a header from tape
 2375 0771                                              ; to second descriptor.
 2376 0771 DD E1                POP     IX              ; restore IX.
 2377 0773 30 F2                JR      NC,L0767        ; loop back to LD-LOOK-H until header found.
 2378 0775
 2379 0775 3E FE                LD      A,$FE           ; select system channel 'S'
 2380 0777 CD 01 16             CALL    L1601           ; routine CHAN-OPEN opens it.
 2381 077A
 2382 077A FD 36 52 03          LD      (IY+$52),$03    ; set SCR_CT to 3 lines.
 2383 077E
 2384 077E 0E 80                LD      C,$80           ; C has bit 7 set to indicate type mismatch as
 2385 0780                                              ; a default startpoint.
 2386 0780
 2387 0780 DD 7E 00             LD      A,(IX+$00)      ; fetch loaded header type to A
 2388 0783 DD BE EF             CP      (IX-$11)        ; compare with expected type.
 2389 0786 20 02                JR      NZ,L078A        ; forward to LD-TYPE with mis-match.
 2390 0788
 2391 0788 0E F6                LD      C,$F6           ; set C to minus ten - will count characters
 2392 078A                                              ; up to zero.
 2393 078A
 2394 078A              ;; LD-TYPE
 2395 078A FE 04        L078A:  CP      $04             ; check if type in acceptable range 0 - 3.
 2396 078C 30 D9                JR      NC,L0767        ; back to LD-LOOK-H with 4 and over.
 2397 078E
 2398 078E              ;   else A indicates type 0-3.
 2399 078E
 2400 078E 11 C0 09             LD      DE,L09C0        ; address base of last 4 tape messages
 2401 0791 C5                   PUSH    BC              ; save BC
 2402 0792 CD 0A 0C             CALL    L0C0A           ; routine PO-MSG outputs relevant message.
 2403 0795                                              ; Note. all messages have a leading newline.
 2404 0795 C1                   POP     BC              ; restore BC
 2405 0796
 2406 0796 DD E5                PUSH    IX              ; transfer IX,
 2407 0798 D1                   POP     DE              ; the 2nd descriptor, to DE.
 2408 0799 21 F0 FF             LD      HL,$FFF0        ; prepare minus seventeen.
 2409 079C 19                   ADD     HL,DE           ; add to point HL to 1st descriptor.
 2410 079D 06 0A                LD      B,$0A           ; the count will be ten characters for the
 2411 079F                                              ; filename.
 2412 079F
 2413 079F 7E                   LD      A,(HL)          ; fetch first character and test for
 2414 07A0 3C                   INC     A               ; value 255.
 2415 07A1 20 03                JR      NZ,L07A6        ; forward to LD-NAME if not the wildcard.
 2416 07A3
 2417 07A3              ;   but if it is the wildcard, then add ten to C which is minus ten for a type
 2418 07A3              ;   match or -128 for a type mismatch. Although characters have to be counted
 2419 07A3              ;   bit 7 of C will not alter from state set here.
 2420 07A3
 2421 07A3 79                   LD      A,C             ; transfer $F6 or $80 to A
 2422 07A4 80                   ADD     A,B             ; add $0A
 2423 07A5 4F                   LD      C,A             ; place result, zero or -118, in C.
 2424 07A6
 2425 07A6              ;   At this point we have either a type mismatch, a wildcard match or ten
 2426 07A6              ;   characters to be counted. The characters must be shown on the screen.
 2427 07A6
 2428 07A6              ;; LD-NAME
 2429 07A6 13           L07A6:  INC     DE              ; address next input character
 2430 07A7 1A                   LD      A,(DE)          ; fetch character
 2431 07A8 BE                   CP      (HL)            ; compare to expected
 2432 07A9 23                   INC     HL              ; address next expected character
 2433 07AA 20 01                JR      NZ,L07AD        ; forward to LD-CH-PR with mismatch
 2434 07AC
 2435 07AC 0C                   INC     C               ; increment matched character count
 2436 07AD
 2437 07AD              ;; LD-CH-PR
 2438 07AD D7           L07AD:  RST     10H             ; PRINT-A prints character
 2439 07AE 10 F6                DJNZ    L07A6           ; loop back to LD-NAME for ten characters.
 2440 07B0
 2441 07B0              ;   if ten characters matched and the types previously matched then C will
 2442 07B0              ;   now hold zero.
 2443 07B0
 2444 07B0 CB 79                BIT     7,C             ; test if all matched
 2445 07B2 20 B3                JR      NZ,L0767        ; back to LD-LOOK-H if not
 2446 07B4
 2447 07B4              ;   else print a terminal carriage return.
 2448 07B4
 2449 07B4 3E 0D                LD      A,$0D           ; prepare carriage return.
 2450 07B6 D7                   RST     10H             ; PRINT-A outputs it.
 2451 07B7
 2452 07B7              ;   The various control routines for LOAD, VERIFY and MERGE are executed
 2453 07B7              ;   during the one-second gap following the header on tape.
 2454 07B7
 2455 07B7 E1                   POP     HL              ; restore xx
 2456 07B8 DD 7E 00             LD      A,(IX+$00)      ; fetch incoming type
 2457 07BB FE 03                CP      $03             ; compare with CODE
 2458 07BD 28 0C                JR      Z,L07CB         ; forward to VR-CONTRL if it is CODE.
 2459 07BF
 2460 07BF              ;  type is a program or an array.
 2461 07BF
 2462 07BF 3A 74 5C             LD      A,($5C74)       ; fetch command from T_ADDR
 2463 07C2 3D                   DEC     A               ; was it LOAD ?
 2464 07C3 CA 08 08             JP      Z,L0808         ; JUMP forward to LD-CONTRL if so to
 2465 07C6                                              ; load BASIC or variables.
 2466 07C6
 2467 07C6 FE 02                CP      $02             ; was command MERGE ?
 2468 07C8 CA B6 08             JP      Z,L08B6         ; jump forward to ME-CONTRL if so.
 2469 07CB
 2470 07CB              ;   else continue into VERIFY control routine to verify.
 2471 07CB
 2472 07CB              ; ----------------------------
 2473 07CB              ; THE 'VERIFY CONTROL' ROUTINE
 2474 07CB              ; ----------------------------
 2475 07CB              ;   There are two branches to this routine.
 2476 07CB              ;   1) From above to verify a program or array
 2477 07CB              ;   2) from earlier with no carry to load or verify code.
 2478 07CB
 2479 07CB              ;; VR-CONTRL
 2480 07CB E5           L07CB:  PUSH    HL              ; save pointer to data.
 2481 07CC DD 6E FA             LD      L,(IX-$06)      ; fetch length of old data
 2482 07CF DD 66 FB             LD      H,(IX-$05)      ; to HL.
 2483 07D2 DD 5E 0B             LD      E,(IX+$0B)      ; fetch length of new data
 2484 07D5 DD 56 0C             LD      D,(IX+$0C)      ; to DE.
 2485 07D8 7C                   LD      A,H             ; check length of old
 2486 07D9 B5                   OR      L               ; for zero.
 2487 07DA 28 0D                JR      Z,L07E9         ; forward to VR-CONT-1 if length unspecified
 2488 07DC                                              ; e.g. LOAD "x" CODE
 2489 07DC
 2490 07DC              ;   as opposed to, say, LOAD 'x' CODE 32768,300.
 2491 07DC
 2492 07DC ED 52                SBC     HL,DE           ; subtract the two lengths.
 2493 07DE 38 26                JR      C,L0806         ; forward to REPORT-R if the length on tape is
 2494 07E0                                              ; larger than that specified in command.
 2495 07E0                                              ; 'Tape loading error'
 2496 07E0
 2497 07E0 28 07                JR      Z,L07E9         ; forward to VR-CONT-1 if lengths match.
 2498 07E2
 2499 07E2              ;   a length on tape shorter than expected is not allowed for CODE
 2500 07E2
 2501 07E2 DD 7E 00             LD      A,(IX+$00)      ; else fetch type from tape.
 2502 07E5 FE 03                CP      $03             ; is it CODE ?
 2503 07E7 20 1D                JR      NZ,L0806        ; forward to REPORT-R if so
 2504 07E9                                              ; 'Tape loading error'
 2505 07E9
 2506 07E9              ;; VR-CONT-1
 2507 07E9 E1           L07E9:  POP     HL              ; pop pointer to data
 2508 07EA 7C                   LD      A,H             ; test for zero
 2509 07EB B5                   OR      L               ; e.g. LOAD 'x' CODE
 2510 07EC 20 06                JR      NZ,L07F4        ; forward to VR-CONT-2 if destination specified.
 2511 07EE
 2512 07EE DD 6E 0D             LD      L,(IX+$0D)      ; else use the destination in the header
 2513 07F1 DD 66 0E             LD      H,(IX+$0E)      ; and load code at address saved from.
 2514 07F4
 2515 07F4              ;; VR-CONT-2
 2516 07F4 E5           L07F4:  PUSH    HL              ; push pointer to start of data block.
 2517 07F5 DD E1                POP     IX              ; transfer to IX.
 2518 07F7 3A 74 5C             LD      A,($5C74)       ; fetch reduced command from T_ADDR
 2519 07FA FE 02                CP      $02             ; is it VERIFY ?
 2520 07FC 37                   SCF                     ; prepare a set carry flag
 2521 07FD 20 01                JR      NZ,L0800        ; skip to VR-CONT-3 if not
 2522 07FF
 2523 07FF A7                   AND     A               ; clear carry flag for VERIFY so that
 2524 0800                                              ; data is not loaded.
 2525 0800
 2526 0800              ;; VR-CONT-3
 2527 0800 3E FF        L0800:  LD      A,$FF           ; signal data block to be loaded
 2528 0802
 2529 0802              ; -----------------
 2530 0802              ; Load a data block
 2531 0802              ; -----------------
 2532 0802              ;   This routine is called from 3 places other than above to load a data block.
 2533 0802              ;   In all cases the accumulator is first set to $FF so the routine could be
 2534 0802              ;   called at the previous instruction.
 2535 0802
 2536 0802              ;; LD-BLOCK
 2537 0802 CD 56 05     L0802:  CALL    L0556           ; routine LD-BYTES
 2538 0805 D8                   RET     C               ; return if successful.
 2539 0806
 2540 0806
 2541 0806              ;; REPORT-R
 2542 0806 CF           L0806:  RST     08H             ; ERROR-1
 2543 0807 1A                   DEFB    $1A             ; Error Report: Tape loading error
 2544 0808
 2545 0808              ; --------------------------
 2546 0808              ; THE 'LOAD CONTROL' ROUTINE
 2547 0808              ; --------------------------
 2548 0808              ;   This branch is taken when the command is LOAD with type 0, 1 or 2.
 2549 0808
 2550 0808              ;; LD-CONTRL
 2551 0808 DD 5E 0B     L0808:  LD      E,(IX+$0B)      ; fetch length of found data block
 2552 080B DD 56 0C             LD      D,(IX+$0C)      ; from 2nd descriptor.
 2553 080E E5                   PUSH    HL              ; save destination
 2554 080F 7C                   LD      A,H             ; test for zero
 2555 0810 B5                   OR      L               ;
 2556 0811 20 06                JR      NZ,L0819        ; forward if not to LD-CONT-1
 2557 0813
 2558 0813 13                   INC     DE              ; increase length
 2559 0814 13                   INC     DE              ; for letter name
 2560 0815 13                   INC     DE              ; and 16-bit length
 2561 0816 EB                   EX      DE,HL           ; length to HL,
 2562 0817 18 0C                JR      L0825           ; forward to LD-CONT-2
 2563 0819
 2564 0819              ; ---
 2565 0819
 2566 0819              ;; LD-CONT-1
 2567 0819 DD 6E FA     L0819:  LD      L,(IX-$06)      ; fetch length from
 2568 081C DD 66 FB             LD      H,(IX-$05)      ; the first header.
 2569 081F EB                   EX      DE,HL           ;
 2570 0820 37                   SCF                     ; set carry flag
 2571 0821 ED 52                SBC     HL,DE           ;
 2572 0823 38 09                JR      C,L082E         ; to LD-DATA
 2573 0825
 2574 0825              ;; LD-CONT-2
 2575 0825 11 05 00     L0825:  LD      DE,$0005        ; allow overhead of five bytes.
 2576 0828 19                   ADD     HL,DE           ; add in the difference in data lengths.
 2577 0829 44                   LD      B,H             ; transfer to
 2578 082A 4D                   LD      C,L             ; the BC register pair
 2579 082B CD 05 1F             CALL    L1F05           ; routine TEST-ROOM fails if not enough room.
 2580 082E
 2581 082E              ;; LD-DATA
 2582 082E E1           L082E:  POP     HL              ; pop destination
 2583 082F DD 7E 00             LD      A,(IX+$00)      ; fetch type 0, 1 or 2.
 2584 0832 A7                   AND     A               ; test for program and variables.
 2585 0833 28 3E                JR      Z,L0873         ; forward if so to LD-PROG
 2586 0835
 2587 0835              ;   the type is a numeric or string array.
 2588 0835
 2589 0835 7C                   LD      A,H             ; test the destination for zero
 2590 0836 B5                   OR      L               ; indicating variable does not already exist.
 2591 0837 28 13                JR      Z,L084C         ; forward if so to LD-DATA-1
 2592 0839
 2593 0839              ;   else the destination is the first dimension within the array structure
 2594 0839
 2595 0839 2B                   DEC     HL              ; address high byte of total length
 2596 083A 46                   LD      B,(HL)          ; transfer to B.
 2597 083B 2B                   DEC     HL              ; address low byte of total length.
 2598 083C 4E                   LD      C,(HL)          ; transfer to C.
 2599 083D 2B                   DEC     HL              ; point to letter of variable.
 2600 083E 03                   INC     BC              ; adjust length to
 2601 083F 03                   INC     BC              ; include these
 2602 0840 03                   INC     BC              ; three bytes also.
 2603 0841 DD 22 5F 5C          LD      ($5C5F),IX      ; save header pointer in X_PTR.
 2604 0845 CD E8 19             CALL    L19E8           ; routine RECLAIM-2 reclaims the old variable
 2605 0848                                              ; sliding workspace including the two headers
 2606 0848                                              ; downwards.
 2607 0848 DD 2A 5F 5C          LD      IX,($5C5F)      ; reload IX from X_PTR which will have been
 2608 084C                                              ; adjusted down by POINTERS routine.
 2609 084C
 2610 084C              ;; LD-DATA-1
 2611 084C 2A 59 5C     L084C:  LD      HL,($5C59)      ; address E_LINE
 2612 084F 2B                   DEC     HL              ; now point to the $80 variables end-marker.
 2613 0850 DD 4E 0B             LD      C,(IX+$0B)      ; fetch new data length
 2614 0853 DD 46 0C             LD      B,(IX+$0C)      ; from 2nd header.
 2615 0856 C5                   PUSH    BC              ; * save it.
 2616 0857 03                   INC     BC              ; adjust the
 2617 0858 03                   INC     BC              ; length to include
 2618 0859 03                   INC     BC              ; letter name and total length.
 2619 085A DD 7E FD             LD      A,(IX-$03)      ; fetch letter name from old header.
 2620 085D F5                   PUSH    AF              ; preserve accumulator though not corrupted.
 2621 085E
 2622 085E CD 55 16             CALL    L1655           ; routine MAKE-ROOM creates space for variable
 2623 0861                                              ; sliding workspace up. IX no longer addresses
 2624 0861                                              ; anywhere meaningful.
 2625 0861 23                   INC     HL              ; point to first new location.
 2626 0862
 2627 0862 F1                   POP     AF              ; fetch back the letter name.
 2628 0863 77                   LD      (HL),A          ; place in first new location.
 2629 0864 D1                   POP     DE              ; * pop the data length.
 2630 0865 23                   INC     HL              ; address 2nd location
 2631 0866 73                   LD      (HL),E          ; store low byte of length.
 2632 0867 23                   INC     HL              ; address next.
 2633 0868 72                   LD      (HL),D          ; store high byte.
 2634 0869 23                   INC     HL              ; address start of data.
 2635 086A E5                   PUSH    HL              ; transfer address
 2636 086B DD E1                POP     IX              ; to IX register pair.
 2637 086D 37                   SCF                     ; set carry flag indicating load not verify.
 2638 086E 3E FF                LD      A,$FF           ; signal data not header.
 2639 0870 C3 02 08             JP      L0802           ; JUMP back to LD-BLOCK
 2640 0873
 2641 0873              ; -----------------
 2642 0873              ;   the branch is here when a program as opposed to an array is to be loaded.
 2643 0873
 2644 0873              ;; LD-PROG
 2645 0873 EB           L0873:  EX      DE,HL           ; transfer dest to DE.
 2646 0874 2A 59 5C             LD      HL,($5C59)      ; address E_LINE
 2647 0877 2B                   DEC     HL              ; now variables end-marker.
 2648 0878 DD 22 5F 5C          LD      ($5C5F),IX      ; place the IX header pointer in X_PTR
 2649 087C DD 4E 0B             LD      C,(IX+$0B)      ; get new length
 2650 087F DD 46 0C             LD      B,(IX+$0C)      ; from 2nd header
 2651 0882 C5                   PUSH    BC              ; and save it.
 2652 0883
 2653 0883 CD E5 19             CALL    L19E5           ; routine RECLAIM-1 reclaims program and vars.
 2654 0886                                              ; adjusting X-PTR.
 2655 0886
 2656 0886 C1                   POP     BC              ; restore new length.
 2657 0887 E5                   PUSH    HL              ; * save start
 2658 0888 C5                   PUSH    BC              ; ** and length.
 2659 0889
 2660 0889 CD 55 16             CALL    L1655           ; routine MAKE-ROOM creates the space.
 2661 088C
 2662 088C DD 2A 5F 5C          LD      IX,($5C5F)      ; reload IX from adjusted X_PTR
 2663 0890 23                   INC     HL              ; point to start of new area.
 2664 0891 DD 4E 0F             LD      C,(IX+$0F)      ; fetch length of BASIC on tape
 2665 0894 DD 46 10             LD      B,(IX+$10)      ; from 2nd descriptor
 2666 0897 09                   ADD     HL,BC           ; add to address the start of variables.
 2667 0898 22 4B 5C             LD      ($5C4B),HL      ; set system variable VARS
 2668 089B
 2669 089B DD 66 0E             LD      H,(IX+$0E)      ; fetch high byte of autostart line number.
 2670 089E 7C                   LD      A,H             ; transfer to A
 2671 089F E6 C0                AND     $C0             ; test if greater than $3F.
 2672 08A1 20 0A                JR      NZ,L08AD        ; forward to LD-PROG-1 if so with no autostart.
 2673 08A3
 2674 08A3 DD 6E 0D             LD      L,(IX+$0D)      ; else fetch the low byte.
 2675 08A6 22 42 5C             LD      ($5C42),HL      ; set system variable to line number NEWPPC
 2676 08A9 FD 36 0A 00          LD      (IY+$0A),$00    ; set statement NSPPC to zero.
 2677 08AD
 2678 08AD              ;; LD-PROG-1
 2679 08AD D1           L08AD:  POP     DE              ; ** pop the length
 2680 08AE DD E1                POP     IX              ; * and start.
 2681 08B0 37                   SCF                     ; set carry flag
 2682 08B1 3E FF                LD      A,$FF           ; signal data as opposed to a header.
 2683 08B3 C3 02 08             JP      L0802           ; jump back to LD-BLOCK
 2684 08B6
 2685 08B6              ; ---------------------------
 2686 08B6              ; THE 'MERGE CONTROL' ROUTINE
 2687 08B6              ; ---------------------------
 2688 08B6              ;   the branch was here to merge a program and its variables or an array.
 2689 08B6              ;
 2690 08B6
 2691 08B6              ;; ME-CONTRL
 2692 08B6 DD 4E 0B     L08B6:  LD      C,(IX+$0B)      ; fetch length
 2693 08B9 DD 46 0C             LD      B,(IX+$0C)      ; of data block on tape.
 2694 08BC C5                   PUSH    BC              ; save it.
 2695 08BD 03                   INC     BC              ; one for the pot.
 2696 08BE
 2697 08BE F7                   RST     30H             ; BC-SPACES creates room in workspace.
 2698 08BF                                              ; HL addresses last new location.
 2699 08BF 36 80                LD      (HL),$80        ; place end-marker at end.
 2700 08C1 EB                   EX      DE,HL           ; transfer first location to HL.
 2701 08C2 D1                   POP     DE              ; restore length to DE.
 2702 08C3 E5                   PUSH    HL              ; save start.
 2703 08C4
 2704 08C4 E5                   PUSH    HL              ; and transfer it
 2705 08C5 DD E1                POP     IX              ; to IX register.
 2706 08C7 37                   SCF                     ; set carry flag to load data on tape.
 2707 08C8 3E FF                LD      A,$FF           ; signal data not a header.
 2708 08CA CD 02 08             CALL    L0802           ; routine LD-BLOCK loads to workspace.
 2709 08CD E1                   POP     HL              ; restore first location in workspace to HL.
 2710 08CE ED 5B 53 5C  X08CE   LD      DE,($5C53)      ; set DE from system variable PROG.
 2711 08D2
 2712 08D2              ;   now enter a loop to merge the data block in workspace with the program and
 2713 08D2              ;   variables.
 2714 08D2
 2715 08D2              ;; ME-NEW-LP
 2716 08D2 7E           L08D2:  LD      A,(HL)          ; fetch next byte from workspace.
 2717 08D3 E6 C0                AND     $C0             ; compare with $3F.
 2718 08D5 20 19                JR      NZ,L08F0        ; forward to ME-VAR-LP if a variable or
 2719 08D7                                              ; end-marker.
 2720 08D7
 2721 08D7              ;   continue when HL addresses a BASIC line number.
 2722 08D7
 2723 08D7              ;; ME-OLD-LP
 2724 08D7 1A           L08D7:  LD      A,(DE)          ; fetch high byte from program area.
 2725 08D8 13                   INC     DE              ; bump prog address.
 2726 08D9 BE                   CP      (HL)            ; compare with that in workspace.
 2727 08DA 23                   INC     HL              ; bump workspace address.
 2728 08DB 20 02                JR      NZ,L08DF        ; forward to ME-OLD-L1 if high bytes don't match
 2729 08DD
 2730 08DD 1A                   LD      A,(DE)          ; fetch the low byte of program line number.
 2731 08DE BE                   CP      (HL)            ; compare with that in workspace.
 2732 08DF
 2733 08DF              ;; ME-OLD-L1
 2734 08DF 1B           L08DF:  DEC     DE              ; point to start of
 2735 08E0 2B                   DEC     HL              ; respective lines again.
 2736 08E1 30 08                JR      NC,L08EB        ; forward to ME-NEW-L2 if line number in
 2737 08E3                                              ; workspace is less than or equal to current
 2738 08E3                                              ; program line as has to be added to program.
 2739 08E3
 2740 08E3 E5                   PUSH    HL              ; else save workspace pointer.
 2741 08E4 EB                   EX      DE,HL           ; transfer prog pointer to HL
 2742 08E5 CD B8 19             CALL    L19B8           ; routine NEXT-ONE finds next line in DE.
 2743 08E8 E1                   POP     HL              ; restore workspace pointer
 2744 08E9 18 EC                JR      L08D7           ; back to ME-OLD-LP until destination position
 2745 08EB                                              ; in program area found.
 2746 08EB
 2747 08EB              ; ---
 2748 08EB              ;   the branch was here with an insertion or replacement point.
 2749 08EB
 2750 08EB              ;; ME-NEW-L2
 2751 08EB CD 2C 09     L08EB:  CALL    L092C           ; routine ME-ENTER enters the line
 2752 08EE 18 E2                JR      L08D2           ; loop back to ME-NEW-LP.
 2753 08F0
 2754 08F0              ; ---
 2755 08F0              ;   the branch was here when the location in workspace held a variable.
 2756 08F0
 2757 08F0              ;; ME-VAR-LP
 2758 08F0 7E           L08F0:  LD      A,(HL)          ; fetch first byte of workspace variable.
 2759 08F1 4F                   LD      C,A             ; copy to C also.
 2760 08F2 FE 80                CP      $80             ; is it the end-marker ?
 2761 08F4 C8                   RET     Z               ; return if so as complete.  >>>>>
 2762 08F5
 2763 08F5 E5                   PUSH    HL              ; save workspace area pointer.
 2764 08F6 2A 4B 5C             LD      HL,($5C4B)      ; load HL with VARS - start of variables area.
 2765 08F9
 2766 08F9              ;; ME-OLD-VP
 2767 08F9 7E           L08F9:  LD      A,(HL)          ; fetch first byte.
 2768 08FA FE 80                CP      $80             ; is it the end-marker ?
 2769 08FC 28 25                JR      Z,L0923         ; forward if so to ME-VAR-L2 to add
 2770 08FE                                              ; variable at end of variables area.
 2771 08FE
 2772 08FE B9                   CP      C               ; compare with variable in workspace area.
 2773 08FF 28 08                JR      Z,L0909         ; forward to ME-OLD-V2 if a match to replace.
 2774 0901
 2775 0901              ;   else entire variables area has to be searched.
 2776 0901
 2777 0901              ;; ME-OLD-V1
 2778 0901 C5           L0901:  PUSH    BC              ; save character in C.
 2779 0902 CD B8 19             CALL    L19B8           ; routine NEXT-ONE gets following variable
 2780 0905                                              ; address in DE.
 2781 0905 C1                   POP     BC              ; restore character in C
 2782 0906 EB                   EX      DE,HL           ; transfer next address to HL.
 2783 0907 18 F0                JR      L08F9           ; loop back to ME-OLD-VP
 2784 0909
 2785 0909              ; ---
 2786 0909              ;   the branch was here when first characters of name matched.
 2787 0909
 2788 0909              ;; ME-OLD-V2
 2789 0909 E6 E0        L0909:  AND     $E0             ; keep bits 11100000
 2790 090B FE A0                CP      $A0             ; compare   10100000 - a long-named variable.
 2791 090D
 2792 090D 20 12                JR      NZ,L0921        ; forward to ME-VAR-L1 if just one-character.
 2793 090F
 2794 090F              ;   but long-named variables have to be matched character by character.
 2795 090F
 2796 090F D1                   POP     DE              ; fetch workspace 1st character pointer
 2797 0910 D5                   PUSH    DE              ; and save it on the stack again.
 2798 0911 E5                   PUSH    HL              ; save variables area pointer on stack.
 2799 0912
 2800 0912              ;; ME-OLD-V3
 2801 0912 23           L0912:  INC     HL              ; address next character in vars area.
 2802 0913 13                   INC     DE              ; address next character in workspace area.
 2803 0914 1A                   LD      A,(DE)          ; fetch workspace character.
 2804 0915 BE                   CP      (HL)            ; compare to variables character.
 2805 0916 20 06                JR      NZ,L091E        ; forward to ME-OLD-V4 with a mismatch.
 2806 0918
 2807 0918 17                   RLA                     ; test if the terminal inverted character.
 2808 0919 30 F7                JR      NC,L0912        ; loop back to ME-OLD-V3 if more to test.
 2809 091B
 2810 091B              ;   otherwise the long name matches in its entirety.
 2811 091B
 2812 091B E1                   POP     HL              ; restore pointer to first character of variable
 2813 091C 18 03                JR      L0921           ; forward to ME-VAR-L1
 2814 091E
 2815 091E              ; ---
 2816 091E              ;   the branch is here when two characters don't match
 2817 091E
 2818 091E              ;; ME-OLD-V4
 2819 091E E1           L091E:  POP     HL              ; restore the prog/vars pointer.
 2820 091F 18 E0                JR      L0901           ; back to ME-OLD-V1 to resume search.
 2821 0921
 2822 0921              ; ---
 2823 0921              ;   branch here when variable is to replace an existing one
 2824 0921
 2825 0921              ;; ME-VAR-L1
 2826 0921 3E FF        L0921:  LD      A,$FF           ; indicate a replacement.
 2827 0923
 2828 0923              ;   this entry point is when A holds $80 indicating a new variable.
 2829 0923
 2830 0923              ;; ME-VAR-L2
 2831 0923 D1           L0923:  POP     DE              ; pop workspace pointer.
 2832 0924 EB                   EX      DE,HL           ; now make HL workspace pointer, DE vars pointer
 2833 0925 3C                   INC     A               ; zero flag set if replacement.
 2834 0926 37                   SCF                     ; set carry flag indicating a variable not a
 2835 0927                                              ; program line.
 2836 0927 CD 2C 09             CALL    L092C           ; routine ME-ENTER copies variable in.
 2837 092A 18 C4                JR      L08F0           ; loop back to ME-VAR-LP
 2838 092C
 2839 092C              ; ------------------------
 2840 092C              ; Merge a Line or Variable
 2841 092C              ; ------------------------
 2842 092C              ;   A BASIC line or variable is inserted at the current point. If the line
 2843 092C              ;   number or variable names match (zero flag set) then a replacement takes
 2844 092C              ;   place.
 2845 092C
 2846 092C              ;; ME-ENTER
 2847 092C 20 10        L092C:  JR      NZ,L093E        ; forward to ME-ENT-1 for insertion only.
 2848 092E
 2849 092E              ;   but the program line or variable matches so old one is reclaimed.
 2850 092E
 2851 092E 08                   EX      AF,AF'          ; save flag??
 2852 092F 22 5F 5C             LD      ($5C5F),HL      ; preserve workspace pointer in dynamic X_PTR
 2853 0932 EB                   EX      DE,HL           ; transfer program dest pointer to HL.
 2854 0933 CD B8 19             CALL    L19B8           ; routine NEXT-ONE finds following location
 2855 0936                                              ; in program or variables area.
 2856 0936 CD E8 19             CALL    L19E8           ; routine RECLAIM-2 reclaims the space between.
 2857 0939 EB                   EX      DE,HL           ; transfer program dest pointer back to DE.
 2858 093A 2A 5F 5C             LD      HL,($5C5F)      ; fetch adjusted workspace pointer from X_PTR
 2859 093D 08                   EX      AF,AF'          ; restore flags.
 2860 093E
 2861 093E              ;   now the new line or variable is entered.
 2862 093E
 2863 093E              ;; ME-ENT-1
 2864 093E 08           L093E:  EX      AF,AF'          ; save or re-save flags.
 2865 093F D5                   PUSH    DE              ; save dest pointer in prog/vars area.
 2866 0940 CD B8 19             CALL    L19B8           ; routine NEXT-ONE finds next in workspace.
 2867 0943                                              ; gets next in DE, difference in BC.
 2868 0943                                              ; prev addr in HL
 2869 0943 22 5F 5C             LD      ($5C5F),HL      ; store pointer in X_PTR
 2870 0946 2A 53 5C             LD      HL,($5C53)      ; load HL from system variable PROG
 2871 0949 E3                   EX      (SP),HL         ; swap with prog/vars pointer on stack.
 2872 094A C5                   PUSH    BC              ; ** save length of new program line/variable.
 2873 094B 08                   EX      AF,AF'          ; fetch flags back.
 2874 094C 38 07                JR      C,L0955         ; skip to ME-ENT-2 if variable
 2875 094E
 2876 094E 2B                   DEC     HL              ; address location before pointer
 2877 094F CD 55 16             CALL    L1655           ; routine MAKE-ROOM creates room for BASIC line
 2878 0952 23                   INC     HL              ; address next.
 2879 0953 18 03                JR      L0958           ; forward to ME-ENT-3
 2880 0955
 2881 0955              ; ---
 2882 0955
 2883 0955              ;; ME-ENT-2
 2884 0955 CD 55 16     L0955:  CALL    L1655           ; routine MAKE-ROOM creates room for variable.
 2885 0958
 2886 0958              ;; ME-ENT-3
 2887 0958 23           L0958:  INC     HL              ; address next?
 2888 0959
 2889 0959 C1                   POP     BC              ; ** pop length
 2890 095A D1                   POP     DE              ; * pop value for PROG which may have been
 2891 095B                                              ; altered by POINTERS if first line.
 2892 095B ED 53 53 5C          LD      ($5C53),DE      ; set PROG to original value.
 2893 095F ED 5B 5F 5C          LD      DE,($5C5F)      ; fetch adjusted workspace pointer from X_PTR
 2894 0963 C5                   PUSH    BC              ; save length
 2895 0964 D5                   PUSH    DE              ; and workspace pointer
 2896 0965 EB                   EX      DE,HL           ; make workspace pointer source, prog/vars
 2897 0966                                              ; pointer the destination
 2898 0966 ED B0                LDIR                    ; copy bytes of line or variable into new area.
 2899 0968 E1                   POP     HL              ; restore workspace pointer.
 2900 0969 C1                   POP     BC              ; restore length.
 2901 096A D5                   PUSH    DE              ; save new prog/vars pointer.
 2902 096B CD E8 19             CALL    L19E8           ; routine RECLAIM-2 reclaims the space used
 2903 096E                                              ; by the line or variable in workspace block
 2904 096E                                              ; as no longer required and space could be
 2905 096E                                              ; useful for adding more lines.
 2906 096E D1                   POP     DE              ; restore the prog/vars pointer
 2907 096F C9                   RET                     ; return.
 2908 0970
 2909 0970              ; --------------------------
 2910 0970              ; THE 'SAVE CONTROL' ROUTINE
 2911 0970              ; --------------------------
 2912 0970              ;   A branch from the main SAVE-ETC routine at SAVE-ALL.
 2913 0970              ;   First the header data is saved. Then after a wait of 1 second
 2914 0970              ;   the data itself is saved.
 2915 0970              ;   HL points to start of data.
 2916 0970              ;   IX points to start of descriptor.
 2917 0970
 2918 0970              ;; SA-CONTRL
 2919 0970 E5           L0970:  PUSH    HL              ; save start of data
 2920 0971
 2921 0971 3E FD                LD      A,$FD           ; select system channel 'S'
 2922 0973 CD 01 16             CALL    L1601           ; routine CHAN-OPEN
 2923 0976
 2924 0976 AF                   XOR     A               ; clear to address table directly
 2925 0977 11 A1 09             LD      DE,L09A1        ; address: tape-msgs
 2926 097A CD 0A 0C             CALL    L0C0A           ; routine PO-MSG -
 2927 097D                                              ; 'Start tape then press any key.'
 2928 097D
 2929 097D FD CB 02 EE          SET     5,(IY+$02)      ; TV_FLAG  - Signal lower screen requires
 2930 0981                                              ; clearing
 2931 0981 CD D4 15             CALL    L15D4           ; routine WAIT-KEY
 2932 0984
 2933 0984 DD E5                PUSH    IX              ; save pointer to descriptor.
 2934 0986 11 11 00             LD      DE,$0011        ; there are seventeen bytes.
 2935 0989 AF                   XOR     A               ; signal a header.
 2936 098A CD C2 04             CALL    L04C2           ; routine SA-BYTES
 2937 098D
 2938 098D DD E1                POP     IX              ; restore descriptor pointer.
 2939 098F
 2940 098F 06 32                LD      B,$32           ; wait for a second - 50 interrupts.
 2941 0991
 2942 0991              ;; SA-1-SEC
 2943 0991 76           L0991:  HALT                    ; wait for interrupt
 2944 0992 10 FD                DJNZ    L0991           ; back to SA-1-SEC until pause complete.
 2945 0994
 2946 0994 DD 5E 0B             LD      E,(IX+$0B)      ; fetch length of bytes from the
 2947 0997 DD 56 0C             LD      D,(IX+$0C)      ; descriptor.
 2948 099A
 2949 099A 3E FF                LD      A,$FF           ; signal data bytes.
 2950 099C
 2951 099C DD E1                POP     IX              ; retrieve pointer to start
 2952 099E C3 C2 04             JP      L04C2           ; jump back to SA-BYTES
 2953 09A1
 2954 09A1
 2955 09A1              ;   Arrangement of two headers in workspace.
 2956 09A1              ;   Originally IX addresses first location and only one header is required
 2957 09A1              ;   when saving.
 2958 09A1              ;
 2959 09A1              ;   OLD     NEW         PROG   DATA  DATA  CODE
 2960 09A1              ;   HEADER  HEADER             num   chr          NOTES.
 2961 09A1              ;   ------  ------      ----   ----  ----  ----   -----------------------------
 2962 09A1              ;   IX-$11  IX+$00      0      1     2     3      Type.
 2963 09A1              ;   IX-$10  IX+$01      x      x     x     x      F  ($FF if filename is null).
 2964 09A1              ;   IX-$0F  IX+$02      x      x     x     x      i
 2965 09A1              ;   IX-$0E  IX+$03      x      x     x     x      l
 2966 09A1              ;   IX-$0D  IX+$04      x      x     x     x      e
 2967 09A1              ;   IX-$0C  IX+$05      x      x     x     x      n
 2968 09A1              ;   IX-$0B  IX+$06      x      x     x     x      a
 2969 09A1              ;   IX-$0A  IX+$07      x      x     x     x      m
 2970 09A1              ;   IX-$09  IX+$08      x      x     x     x      e
 2971 09A1              ;   IX-$08  IX+$09      x      x     x     x      .
 2972 09A1              ;   IX-$07  IX+$0A      x      x     x     x      (terminal spaces).
 2973 09A1              ;   IX-$06  IX+$0B      lo     lo    lo    lo     Total
 2974 09A1              ;   IX-$05  IX+$0C      hi     hi    hi    hi     Length of datablock.
 2975 09A1              ;   IX-$04  IX+$0D      Auto   -     -     Start  Various
 2976 09A1              ;   IX-$03  IX+$0E      Start  a-z   a-z   addr   ($80 if no autostart).
 2977 09A1              ;   IX-$02  IX+$0F      lo     -     -     -      Length of Program
 2978 09A1              ;   IX-$01  IX+$10      hi     -     -     -      only i.e. without variables.
 2979 09A1              ;
 2980 09A1
 2981 09A1
 2982 09A1              ; ------------------------
 2983 09A1              ; Canned cassette messages
 2984 09A1              ; ------------------------
 2985 09A1              ;   The last-character-inverted Cassette messages.
 2986 09A1              ;   Starts with normal initial step-over byte.
 2987 09A1
 2988 09A1              ;; tape-msgs
 2989 09A1 80           L09A1:  DEFB    $80
 2990 09A2 53 74 61 72          DEFM    "Start tape, then press any key"
 2990 09A6 74 20 74 61
 2990 09AA 70 65 2C 20
 2990 09AE 74 68 65 6E
 2990 09B2 20 70 72 65
 2990 09B6 73 73 20 61
 2990 09BA 6E 79 20 6B
 2990 09BE 65 79
 2991 09C0 AE           L09C0:  DEFB    '.'+$80
 2992 09C1 0D                   DEFB    $0D
 2993 09C2 50 72 6F 67          DEFM    "Program:"
 2993 09C6 72 61 6D 3A
 2994 09CA A0                   DEFB    ' '+$80
 2995 09CB 0D                   DEFB    $0D
 2996 09CC 4E 75 6D 62          DEFM    "Number array:"
 2996 09D0 65 72 20 61
 2996 09D4 72 72 61 79
 2996 09D8 3A
 2997 09D9 A0                   DEFB    ' '+$80
 2998 09DA 0D                   DEFB    $0D
 2999 09DB 43 68 61 72          DEFM    "Character array:"
 2999 09DF 61 63 74 65
 2999 09E3 72 20 61 72
 2999 09E7 72 61 79 3A
 3000 09EB A0                   DEFB    ' '+$80
 3001 09EC 0D                   DEFB    $0D
 3002 09ED 42 79 74 65          DEFM    "Bytes:"
 3002 09F1 73 3A
 3003 09F3 A0                   DEFB    ' '+$80
 3004 09F4
 3005 09F4
 3006 09F4              ;**************************************************
 3007 09F4              ;** Part 5. SCREEN AND PRINTER HANDLING ROUTINES **
 3008 09F4              ;**************************************************
 3009 09F4
 3010 09F4              ; --------------------------
 3011 09F4              ; THE 'PRINT OUTPUT' ROUTINE
 3012 09F4              ; --------------------------
 3013 09F4              ;   This is the routine most often used by the RST 10 restart although the
 3014 09F4              ;   subroutine is on two occasions called directly when it is known that
 3015 09F4              ;   output will definitely be to the lower screen.
 3016 09F4
 3017 09F4              ;; PRINT-OUT
 3018 09F4 CD 03 0B     L09F4:  CALL    L0B03           ; routine PO-FETCH fetches print position
 3019 09F7                                              ; to HL register pair.
 3020 09F7 FE 20                CP      $20             ; is character a space or higher ?
 3021 09F9 D2 D9 0A             JP      NC,L0AD9        ; jump forward to PO-ABLE if so.
 3022 09FC
 3023 09FC FE 06                CP      $06             ; is character in range 00-05 ?
 3024 09FE 38 69                JR      C,L0A69         ; to PO-QUEST to print '?' if so.
 3025 0A00
 3026 0A00 FE 18                CP      $18             ; is character in range 24d - 31d ?
 3027 0A02 30 65                JR      NC,L0A69        ; to PO-QUEST to also print '?' if so.
 3028 0A04
 3029 0A04 21 0B 0A             LD      HL,L0A11 - 6    ; address 0A0B - the base address of control
 3030 0A07                                              ; character table - where zero would be.
 3031 0A07 5F                   LD      E,A             ; control character 06 - 23d
 3032 0A08 16 00                LD      D,$00           ; is transferred to DE.
 3033 0A0A
 3034 0A0A 19                   ADD     HL,DE           ; index into table.
 3035 0A0B
 3036 0A0B 5E                   LD      E,(HL)          ; fetch the offset to routine.
 3037 0A0C 19                   ADD     HL,DE           ; add to make HL the address.
 3038 0A0D E5                   PUSH    HL              ; push the address.
 3039 0A0E
 3040 0A0E C3 03 0B             JP      L0B03           ; Jump forward to PO-FETCH,
 3041 0A11                                              ; as the screen/printer position has been
 3042 0A11                                              ; disturbed, and then indirectly to the PO-STORE
 3043 0A11                                              ; routine on stack.
 3044 0A11
 3045 0A11              ; -----------------------------
 3046 0A11              ; THE 'CONTROL CHARACTER' TABLE
 3047 0A11              ; -----------------------------
 3048 0A11              ;   For control characters in the range 6 - 23d the following table
 3049 0A11              ;   is indexed to provide an offset to the handling routine that
 3050 0A11              ;   follows the table.
 3051 0A11
 3052 0A11              ;; ctlchrtab
 3053 0A11 4E           L0A11:  DEFB    L0A5F - $       ; 06d offset $4E to Address: PO-COMMA
 3054 0A12 57                   DEFB    L0A69 - $       ; 07d offset $57 to Address: PO-QUEST
 3055 0A13 10                   DEFB    L0A23 - $       ; 08d offset $10 to Address: PO-BACK-1
 3056 0A14 29                   DEFB    L0A3D - $       ; 09d offset $29 to Address: PO-RIGHT
 3057 0A15 54                   DEFB    L0A69 - $       ; 10d offset $54 to Address: PO-QUEST
 3058 0A16 53                   DEFB    L0A69 - $       ; 11d offset $53 to Address: PO-QUEST
 3059 0A17 52                   DEFB    L0A69 - $       ; 12d offset $52 to Address: PO-QUEST
 3060 0A18 37                   DEFB    L0A4F - $       ; 13d offset $37 to Address: PO-ENTER
 3061 0A19 50                   DEFB    L0A69 - $       ; 14d offset $50 to Address: PO-QUEST
 3062 0A1A 4F                   DEFB    L0A69 - $       ; 15d offset $4F to Address: PO-QUEST
 3063 0A1B 5F                   DEFB    L0A7A - $       ; 16d offset $5F to Address: PO-1-OPER
 3064 0A1C 5E                   DEFB    L0A7A - $       ; 17d offset $5E to Address: PO-1-OPER
 3065 0A1D 5D                   DEFB    L0A7A - $       ; 18d offset $5D to Address: PO-1-OPER
 3066 0A1E 5C                   DEFB    L0A7A - $       ; 19d offset $5C to Address: PO-1-OPER
 3067 0A1F 5B                   DEFB    L0A7A - $       ; 20d offset $5B to Address: PO-1-OPER
 3068 0A20 5A                   DEFB    L0A7A - $       ; 21d offset $5A to Address: PO-1-OPER
 3069 0A21 54                   DEFB    L0A75 - $       ; 22d offset $54 to Address: PO-2-OPER
 3070 0A22 53                   DEFB    L0A75 - $       ; 23d offset $53 to Address: PO-2-OPER
 3071 0A23
 3072 0A23
 3073 0A23              ; -------------------------
 3074 0A23              ; THE 'CURSOR LEFT' ROUTINE
 3075 0A23              ; -------------------------
 3076 0A23              ;   Backspace and up a line if that action is from the left of screen.
 3077 0A23              ;   For ZX printer backspace up to first column but not beyond.
 3078 0A23
 3079 0A23              ;; PO-BACK-1
 3080 0A23 0C           L0A23:  INC     C               ; move left one column.
 3081 0A24 3E 22                LD      A,$22           ; value $21 is leftmost column.
 3082 0A26 B9                   CP      C               ; have we passed ?
 3083 0A27 20 11                JR      NZ,L0A3A        ; to PO-BACK-3 if not and store new position.
 3084 0A29
 3085 0A29 FD CB 01 4E          BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?
 3086 0A2D 20 09                JR      NZ,L0A38        ; to PO-BACK-2 if so, as we are unable to
 3087 0A2F                                              ; backspace from the leftmost position.
 3088 0A2F
 3089 0A2F
 3090 0A2F 04                   INC     B               ; move up one screen line
 3091 0A30 0E 02                LD      C,$02           ; the rightmost column position.
 3092 0A32 3E 18                LD      A,$18           ; Note. This should be $19
 3093 0A34                                              ; credit. Dr. Frank O'Hara, 1982
 3094 0A34
 3095 0A34 B8                   CP      B               ; has position moved past top of screen ?
 3096 0A35 20 03                JR      NZ,L0A3A        ; to PO-BACK-3 if not and store new position.
 3097 0A37
 3098 0A37 05                   DEC     B               ; else back to $18.
 3099 0A38
 3100 0A38              ;; PO-BACK-2
 3101 0A38 0E 21        L0A38:  LD      C,$21           ; the leftmost column position.
 3102 0A3A
 3103 0A3A              ;; PO-BACK-3
 3104 0A3A C3 D9 0D     L0A3A:  JP      L0DD9           ; to CL-SET and PO-STORE to save new
 3105 0A3D                                              ; position in system variables.
 3106 0A3D
 3107 0A3D              ; --------------------------
 3108 0A3D              ; THE 'CURSOR RIGHT' ROUTINE
 3109 0A3D              ; --------------------------
 3110 0A3D              ;   This moves the print position to the right leaving a trail in the
 3111 0A3D              ;   current background colour.
 3112 0A3D              ;   "However the programmer has failed to store the new print position
 3113 0A3D              ;   so CHR$ 9 will only work if the next print position is at a newly
 3114 0A3D              ;   defined place.
 3115 0A3D              ;   e.g. PRINT PAPER 2; CHR$ 9; AT 4,0;
 3116 0A3D              ;   does work but is not very helpful"
 3117 0A3D              ;   - Dr. Ian Logan, Understanding Your Spectrum, 1982.
 3118 0A3D
 3119 0A3D              ;; PO-RIGHT
 3120 0A3D 3A 91 5C     L0A3D:  LD      A,($5C91)       ; fetch P_FLAG value
 3121 0A40 F5                   PUSH    AF              ; and save it on stack.
 3122 0A41
 3123 0A41 FD 36 57 01          LD      (IY+$57),$01    ; temporarily set P_FLAG 'OVER 1'.
 3124 0A45 3E 20                LD      A,$20           ; prepare a space.
 3125 0A47 CD 65 0B             CALL    L0B65           ; routine PO-CHAR to print it.
 3126 0A4A                                              ; Note. could be PO-ABLE which would update
 3127 0A4A                                              ; the column position.
 3128 0A4A
 3129 0A4A F1                   POP     AF              ; restore the permanent flag.
 3130 0A4B 32 91 5C             LD      ($5C91),A       ; and restore system variable P_FLAG
 3131 0A4E
 3132 0A4E C9                   RET                     ; return without updating column position
 3133 0A4F
 3134 0A4F              ; -----------------------
 3135 0A4F              ; Perform carriage return
 3136 0A4F              ; -----------------------
 3137 0A4F              ; A carriage return is 'printed' to screen or printer buffer.
 3138 0A4F
 3139 0A4F              ;; PO-ENTER
 3140 0A4F FD CB 01 4E  L0A4F:  BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?
 3141 0A53 C2 CD 0E             JP      NZ,L0ECD        ; to COPY-BUFF if so, to flush buffer and reset
 3142 0A56                                              ; the print position.
 3143 0A56
 3144 0A56 0E 21                LD      C,$21           ; the leftmost column position.
 3145 0A58 CD 55 0C             CALL    L0C55           ; routine PO-SCR handles any scrolling required.
 3146 0A5B 05                   DEC     B               ; to next screen line.
 3147 0A5C C3 D9 0D             JP      L0DD9           ; jump forward to CL-SET to store new position.
 3148 0A5F
 3149 0A5F              ; -----------
 3150 0A5F              ; Print comma
 3151 0A5F              ; -----------
 3152 0A5F              ; The comma control character. The 32 column screen has two 16 character
 3153 0A5F              ; tabstops.  The routine is only reached via the control character table.
 3154 0A5F
 3155 0A5F              ;; PO-COMMA
 3156 0A5F CD 03 0B     L0A5F:  CALL    L0B03           ; routine PO-FETCH - seems unnecessary.
 3157 0A62
 3158 0A62 79                   LD      A,C             ; the column position. $21-$01
 3159 0A63 3D                   DEC     A               ; move right. $20-$00
 3160 0A64 3D                   DEC     A               ; and again   $1F-$00 or $FF if trailing
 3161 0A65 E6 10                AND     $10             ; will be $00 or $10.
 3162 0A67 18 5A                JR      L0AC3           ; forward to PO-FILL
 3163 0A69
 3164 0A69              ; -------------------
 3165 0A69              ; Print question mark
 3166 0A69              ; -------------------
 3167 0A69              ; This routine prints a question mark which is commonly
 3168 0A69              ; used to print an unassigned control character in range 0-31d.
 3169 0A69              ; there are a surprising number yet to be assigned.
 3170 0A69
 3171 0A69              ;; PO-QUEST
 3172 0A69 3E 3F        L0A69:  LD      A,$3F           ; prepare the character '?'.
 3173 0A6B 18 6C                JR      L0AD9           ; forward to PO-ABLE.
 3174 0A6D
 3175 0A6D              ; --------------------------------
 3176 0A6D              ; Control characters with operands
 3177 0A6D              ; --------------------------------
 3178 0A6D              ; Certain control characters are followed by 1 or 2 operands.
 3179 0A6D              ; The entry points from control character table are PO-2-OPER and PO-1-OPER.
 3180 0A6D              ; The routines alter the output address of the current channel so that
 3181 0A6D              ; subsequent RST $10 instructions take the appropriate action
 3182 0A6D              ; before finally resetting the output address back to PRINT-OUT.
 3183 0A6D
 3184 0A6D              ;; PO-TV-2
 3185 0A6D 11 87 0A     L0A6D:  LD      DE,L0A87        ; address: PO-CONT will be next output routine
 3186 0A70 32 0F 5C             LD      ($5C0F),A       ; store first operand in TVDATA-hi
 3187 0A73 18 0B                JR      L0A80           ; forward to PO-CHANGE >>
 3188 0A75
 3189 0A75              ; ---
 3190 0A75
 3191 0A75              ; -> This initial entry point deals with two operands - AT or TAB.
 3192 0A75
 3193 0A75              ;; PO-2-OPER
 3194 0A75 11 6D 0A     L0A75:  LD      DE,L0A6D        ; address: PO-TV-2 will be next output routine
 3195 0A78 18 03                JR      L0A7D           ; forward to PO-TV-1
 3196 0A7A
 3197 0A7A              ; ---
 3198 0A7A
 3199 0A7A              ; -> This initial entry point deals with one operand INK to OVER.
 3200 0A7A
 3201 0A7A              ;; PO-1-OPER
 3202 0A7A 11 87 0A     L0A7A:  LD      DE,L0A87        ; address: PO-CONT will be next output routine
 3203 0A7D
 3204 0A7D              ;; PO-TV-1
 3205 0A7D 32 0E 5C     L0A7D:  LD      ($5C0E),A       ; store control code in TVDATA-lo
 3206 0A80
 3207 0A80              ;; PO-CHANGE
 3208 0A80 2A 51 5C     L0A80:  LD      HL,($5C51)      ; use CURCHL to find current output channel.
 3209 0A83 73                   LD      (HL),E          ; make it
 3210 0A84 23                   INC     HL              ; the supplied
 3211 0A85 72                   LD      (HL),D          ; address from DE.
 3212 0A86 C9                   RET                     ; return.
 3213 0A87
 3214 0A87              ; ---
 3215 0A87
 3216 0A87              ;; PO-CONT
 3217 0A87 11 F4 09     L0A87:  LD      DE,L09F4        ; Address: PRINT-OUT
 3218 0A8A CD 80 0A             CALL    L0A80           ; routine PO-CHANGE to restore normal channel.
 3219 0A8D 2A 0E 5C             LD      HL,($5C0E)      ; TVDATA gives control code and possible
 3220 0A90                                              ; subsequent character
 3221 0A90 57                   LD      D,A             ; save current character
 3222 0A91 7D                   LD      A,L             ; the stored control code
 3223 0A92 FE 16                CP      $16             ; was it INK to OVER (1 operand) ?
 3224 0A94 DA 11 22             JP      C,L2211         ; to CO-TEMP-5
 3225 0A97
 3226 0A97 20 29                JR      NZ,L0AC2        ; to PO-TAB if not 22d i.e. 23d TAB.
 3227 0A99
 3228 0A99                                              ; else must have been 22d AT.
 3229 0A99 44                   LD      B,H             ; line to H   (0-23d)
 3230 0A9A 4A                   LD      C,D             ; column to C (0-31d)
 3231 0A9B 3E 1F                LD      A,$1F           ; the value 31d
 3232 0A9D 91                   SUB     C               ; reverse the column number.
 3233 0A9E 38 0C                JR      C,L0AAC         ; to PO-AT-ERR if C was greater than 31d.
 3234 0AA0
 3235 0AA0 C6 02                ADD     A,$02           ; transform to system range $02-$21
 3236 0AA2 4F                   LD      C,A             ; and place in column register.
 3237 0AA3
 3238 0AA3 FD CB 01 4E          BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?
 3239 0AA7 20 16                JR      NZ,L0ABF        ; to PO-AT-SET as line can be ignored.
 3240 0AA9
 3241 0AA9 3E 16                LD      A,$16           ; 22 decimal
 3242 0AAB 90                   SUB     B               ; subtract line number to reverse
 3243 0AAC                                              ; 0 - 22 becomes 22 - 0.
 3244 0AAC
 3245 0AAC              ;; PO-AT-ERR
 3246 0AAC DA 9F 1E     L0AAC:  JP      C,L1E9F         ; to REPORT-B if higher than 22 decimal
 3247 0AAF                                              ; Integer out of range.
 3248 0AAF
 3249 0AAF 3C                   INC     A               ; adjust for system range $01-$17
 3250 0AB0 47                   LD      B,A             ; place in line register
 3251 0AB1 04                   INC     B               ; adjust to system range  $02-$18
 3252 0AB2 FD CB 02 46          BIT     0,(IY+$02)      ; TV_FLAG  - Lower screen in use ?
 3253 0AB6 C2 55 0C             JP      NZ,L0C55        ; exit to PO-SCR to test for scrolling
 3254 0AB9
 3255 0AB9 FD BE 31             CP      (IY+$31)        ; Compare against DF_SZ
 3256 0ABC DA 86 0C             JP      C,L0C86         ; to REPORT-5 if too low
 3257 0ABF                                              ; Out of screen.
 3258 0ABF
 3259 0ABF              ;; PO-AT-SET
 3260 0ABF C3 D9 0D     L0ABF:  JP      L0DD9           ; print position is valid so exit via CL-SET
 3261 0AC2
 3262 0AC2              ; ---
 3263 0AC2
 3264 0AC2              ; Continue here when dealing with TAB.
 3265 0AC2              ; Note. In BASIC, TAB is followed by a 16-bit number and was initially
 3266 0AC2              ; designed to work with any output device.
 3267 0AC2
 3268 0AC2              ;; PO-TAB
 3269 0AC2 7C           L0AC2:  LD      A,H             ; transfer parameter to A
 3270 0AC3                                              ; Losing current character -
 3271 0AC3                                              ; High byte of TAB parameter.
 3272 0AC3
 3273 0AC3
 3274 0AC3              ;; PO-FILL
 3275 0AC3 CD 03 0B     L0AC3:  CALL    L0B03           ; routine PO-FETCH, HL-addr, BC=line/column.
 3276 0AC6                                              ; column 1 (right), $21 (left)
 3277 0AC6 81                   ADD     A,C             ; add operand to current column
 3278 0AC7 3D                   DEC     A               ; range 0 - 31+
 3279 0AC8 E6 1F                AND     $1F             ; make range 0 - 31d
 3280 0ACA C8                   RET     Z               ; return if result zero
 3281 0ACB
 3282 0ACB 57                   LD      D,A             ; Counter to D
 3283 0ACC FD CB 01 C6          SET     0,(IY+$01)      ; update FLAGS  - signal suppress leading space.
 3284 0AD0
 3285 0AD0              ;; PO-SPACE
 3286 0AD0 3E 20        L0AD0:  LD      A,$20           ; space character.
 3287 0AD2
 3288 0AD2 CD 3B 0C             CALL    L0C3B           ; routine PO-SAVE prints the character
 3289 0AD5                                              ; using alternate set (normal output routine)
 3290 0AD5
 3291 0AD5 15                   DEC     D               ; decrement counter.
 3292 0AD6 20 F8                JR      NZ,L0AD0        ; to PO-SPACE until done
 3293 0AD8
 3294 0AD8 C9                   RET                     ; return
 3295 0AD9
 3296 0AD9              ; ----------------------
 3297 0AD9              ; Printable character(s)
 3298 0AD9              ; ----------------------
 3299 0AD9              ; This routine prints printable characters and continues into
 3300 0AD9              ; the position store routine
 3301 0AD9
 3302 0AD9              ;; PO-ABLE
 3303 0AD9 CD 24 0B     L0AD9:  CALL    L0B24           ; routine PO-ANY
 3304 0ADC                                              ; and continue into position store routine.
 3305 0ADC
 3306 0ADC              ; ----------------------------
 3307 0ADC              ; THE 'POSITION STORE' ROUTINE
 3308 0ADC              ; ----------------------------
 3309 0ADC              ;   This routine updates the system variables associated with the main screen,
 3310 0ADC              ;   the lower screen/input buffer or the ZX printer.
 3311 0ADC
 3312 0ADC              ;; PO-STORE
 3313 0ADC FD CB 01 4E  L0ADC:  BIT     1,(IY+$01)      ; Test FLAGS - is printer in use ?
 3314 0AE0 20 1A                JR      NZ,L0AFC        ; Forward, if so, to PO-ST-PR
 3315 0AE2
 3316 0AE2 FD CB 02 46          BIT     0,(IY+$02)      ; Test TV_FLAG - is lower screen in use ?
 3317 0AE6 20 08                JR      NZ,L0AF0        ; Forward, if so, to PO-ST-E
 3318 0AE8
 3319 0AE8              ;   This section deals with the upper screen.
 3320 0AE8
 3321 0AE8 ED 43 88 5C          LD      ($5C88),BC      ; Update S_POSN - line/column upper screen
 3322 0AEC 22 84 5C             LD      ($5C84),HL      ; Update DF_CC - upper display file address
 3323 0AEF
 3324 0AEF C9                   RET                     ; Return.
 3325 0AF0
 3326 0AF0              ; ---
 3327 0AF0
 3328 0AF0              ;   This section deals with the lower screen.
 3329 0AF0
 3330 0AF0              ;; PO-ST-E
 3331 0AF0 ED 43 8A 5C  L0AF0:  LD      ($5C8A),BC      ; Update SPOSNL line/column lower screen
 3332 0AF4 ED 43 82 5C          LD      ($5C82),BC      ; Update ECHO_E line/column input buffer
 3333 0AF8 22 86 5C             LD      ($5C86),HL      ; Update DFCCL  lower screen memory address
 3334 0AFB C9                   RET                     ; Return.
 3335 0AFC
 3336 0AFC              ; ---
 3337 0AFC
 3338 0AFC              ;   This section deals with the ZX Printer.
 3339 0AFC
 3340 0AFC              ;; PO-ST-PR
 3341 0AFC FD 71 45     L0AFC:  LD      (IY+$45),C      ; Update P_POSN column position printer
 3342 0AFF 22 80 5C             LD      ($5C80),HL      ; Update PR_CC - full printer buffer memory
 3343 0B02                                              ; address
 3344 0B02 C9                   RET                     ; Return.
 3345 0B03
 3346 0B03              ;   Note. that any values stored in location 23681 will be overwritten with
 3347 0B03              ;   the value 91 decimal.
 3348 0B03              ;   Credit April 1983, Dilwyn Jones. "Delving Deeper into your ZX Spectrum".
 3349 0B03
 3350 0B03              ; ----------------------------
 3351 0B03              ; THE 'POSITION FETCH' ROUTINE
 3352 0B03              ; ----------------------------
 3353 0B03              ;   This routine fetches the line/column and display file address of the upper
 3354 0B03              ;   and lower screen or, if the printer is in use, the column position and
 3355 0B03              ;   absolute memory address.
 3356 0B03              ;   Note. that PR-CC-hi (23681) is used by this routine and if, in accordance
 3357 0B03              ;   with the manual (that says this is unused), the location has been used for
 3358 0B03              ;   other purposes, then subsequent output to the printer buffer could corrupt
 3359 0B03              ;   a 256-byte section of memory.
 3360 0B03
 3361 0B03              ;; PO-FETCH
 3362 0B03 FD CB 01 4E  L0B03:  BIT     1,(IY+$01)      ; Test FLAGS - is printer in use ?
 3363 0B07 20 14                JR      NZ,L0B1D        ; Forward, if so, to PO-F-PR
 3364 0B09
 3365 0B09              ;   assume upper screen in use and thus optimize for path that requires speed.
 3366 0B09
 3367 0B09 ED 4B 88 5C          LD      BC,($5C88)      ; Fetch line/column from S_POSN
 3368 0B0D 2A 84 5C             LD      HL,($5C84)      ; Fetch DF_CC display file address
 3369 0B10
 3370 0B10 FD CB 02 46          BIT     0,(IY+$02)      ; Test TV_FLAG - lower screen in use ?
 3371 0B14 C8                   RET     Z               ; Return if upper screen in use.
 3372 0B15
 3373 0B15              ;   Overwrite registers with values for lower screen.
 3374 0B15
 3375 0B15 ED 4B 8A 5C          LD      BC,($5C8A)      ; Fetch line/column from SPOSNL
 3376 0B19 2A 86 5C             LD      HL,($5C86)      ; Fetch display file address from DFCCL
 3377 0B1C C9                   RET                     ; Return.
 3378 0B1D
 3379 0B1D              ; ---
 3380 0B1D
 3381 0B1D              ;   This section deals with the ZX Printer.
 3382 0B1D
 3383 0B1D              ;; PO-F-PR
 3384 0B1D FD 4E 45     L0B1D:  LD      C,(IY+$45)      ; Fetch column from P_POSN.
 3385 0B20 2A 80 5C             LD      HL,($5C80)      ; Fetch printer buffer address from PR_CC.
 3386 0B23 C9                   RET                     ; Return.
 3387 0B24
 3388 0B24              ; ---------------------------------
 3389 0B24              ; THE 'PRINT ANY CHARACTER' ROUTINE
 3390 0B24              ; ---------------------------------
 3391 0B24              ;   This routine is used to print any character in range 32d - 255d
 3392 0B24              ;   It is only called from PO-ABLE which continues into PO-STORE
 3393 0B24
 3394 0B24              ;; PO-ANY
 3395 0B24 FE 80        L0B24:  CP      $80             ; ASCII ?
 3396 0B26 38 3D                JR      C,L0B65         ; to PO-CHAR is so.
 3397 0B28
 3398 0B28 FE 90                CP      $90             ; test if a block graphic character.
 3399 0B2A 30 26                JR      NC,L0B52        ; to PO-T&UDG to print tokens and UDGs
 3400 0B2C
 3401 0B2C              ; The 16 2*2 mosaic characters 128-143 decimal are formed from
 3402 0B2C              ; bits 0-3 of the character.
 3403 0B2C
 3404 0B2C 47                   LD      B,A             ; save character
 3405 0B2D CD 38 0B             CALL    L0B38           ; routine PO-GR-1 to construct top half
 3406 0B30                                              ; then bottom half.
 3407 0B30 CD 03 0B             CALL    L0B03           ; routine PO-FETCH fetches print position.
 3408 0B33 11 92 5C             LD      DE,$5C92        ; MEM-0 is location of 8 bytes of character
 3409 0B36 18 47                JR      L0B7F           ; to PR-ALL to print to screen or printer
 3410 0B38
 3411 0B38              ; ---
 3412 0B38
 3413 0B38              ;; PO-GR-1
 3414 0B38 21 92 5C     L0B38:  LD      HL,$5C92        ; address MEM-0 - a temporary buffer in
 3415 0B3B                                              ; systems variables which is normally used
 3416 0B3B                                              ; by the calculator.
 3417 0B3B CD 3E 0B             CALL    L0B3E           ; routine PO-GR-2 to construct top half
 3418 0B3E                                              ; and continue into routine to construct
 3419 0B3E                                              ; bottom half.
 3420 0B3E
 3421 0B3E              ;; PO-GR-2
 3422 0B3E CB 18        L0B3E:  RR      B               ; rotate bit 0/2 to carry
 3423 0B40 9F                   SBC     A,A             ; result $00 or $FF
 3424 0B41 E6 0F                AND     $0F             ; mask off right hand side
 3425 0B43 4F                   LD      C,A             ; store part in C
 3426 0B44 CB 18                RR      B               ; rotate bit 1/3 of original chr to carry
 3427 0B46 9F                   SBC     A,A             ; result $00 or $FF
 3428 0B47 E6 F0                AND     $F0             ; mask off left hand side
 3429 0B49 B1                   OR      C               ; combine with stored pattern
 3430 0B4A 0E 04                LD      C,$04           ; four bytes for top/bottom half
 3431 0B4C
 3432 0B4C              ;; PO-GR-3
 3433 0B4C 77           L0B4C:  LD      (HL),A          ; store bit patterns in temporary buffer
 3434 0B4D 23                   INC     HL              ; next address
 3435 0B4E 0D                   DEC     C               ; jump back to
 3436 0B4F 20 FB                JR      NZ,L0B4C        ; to PO-GR-3 until byte is stored 4 times
 3437 0B51
 3438 0B51 C9                   RET                     ; return
 3439 0B52
 3440 0B52              ; ---
 3441 0B52
 3442 0B52              ; Tokens and User defined graphics are now separated.
 3443 0B52
 3444 0B52              ;; PO-T&UDG
 3445 0B52 D6 A5        L0B52:  SUB     $A5             ; the 'RND' character
 3446 0B54 30 09                JR      NC,L0B5F        ; to PO-T to print tokens
 3447 0B56
 3448 0B56 C6 15                ADD     A,$15           ; add 21d to restore to 0 - 20
 3449 0B58 C5                   PUSH    BC              ; save current print position
 3450 0B59 ED 4B 7B 5C          LD      BC,($5C7B)      ; fetch UDG to address bit patterns
 3451 0B5D 18 0B                JR      L0B6A           ; to PO-CHAR-2 - common code to lay down
 3452 0B5F                                              ; a bit patterned character
 3453 0B5F
 3454 0B5F              ; ---
 3455 0B5F
 3456 0B5F              ;; PO-T
 3457 0B5F CD 10 0C     L0B5F:  CALL    L0C10           ; routine PO-TOKENS prints tokens
 3458 0B62 C3 03 0B             JP      L0B03           ; exit via a JUMP to PO-FETCH as this routine
 3459 0B65                                              ; must continue into PO-STORE.
 3460 0B65                                              ; A JR instruction could be used.
 3461 0B65
 3462 0B65              ; This point is used to print ASCII characters  32d - 127d.
 3463 0B65
 3464 0B65              ;; PO-CHAR
 3465 0B65 C5           L0B65:  PUSH    BC              ; save print position
 3466 0B66 ED 4B 36 5C          LD      BC,($5C36)      ; address CHARS
 3467 0B6A
 3468 0B6A              ; This common code is used to transfer the character bytes to memory.
 3469 0B6A
 3470 0B6A              ;; PO-CHAR-2
 3471 0B6A EB           L0B6A:  EX      DE,HL           ; transfer destination address to DE
 3472 0B6B 21 3B 5C             LD      HL,$5C3B        ; point to FLAGS
 3473 0B6E CB 86                RES     0,(HL)          ; allow for leading space
 3474 0B70 FE 20                CP      $20             ; is it a space ?
 3475 0B72 20 02                JR      NZ,L0B76        ; to PO-CHAR-3 if not
 3476 0B74
 3477 0B74 CB C6                SET     0,(HL)          ; signal no leading space to FLAGS
 3478 0B76
 3479 0B76              ;; PO-CHAR-3
 3480 0B76 26 00        L0B76:  LD      H,$00           ; set high byte to 0
 3481 0B78 6F                   LD      L,A             ; character to A
 3482 0B79                                              ; 0-21 UDG or 32-127 ASCII.
 3483 0B79 29                   ADD     HL,HL           ; multiply
 3484 0B7A 29                   ADD     HL,HL           ; by
 3485 0B7B 29                   ADD     HL,HL           ; eight
 3486 0B7C 09                   ADD     HL,BC           ; HL now points to first byte of character
 3487 0B7D C1                   POP     BC              ; the source address CHARS or UDG
 3488 0B7E EB                   EX      DE,HL           ; character address to DE
 3489 0B7F
 3490 0B7F              ; ----------------------------------
 3491 0B7F              ; THE 'PRINT ALL CHARACTERS' ROUTINE
 3492 0B7F              ; ----------------------------------
 3493 0B7F              ;   This entry point entered from above to print ASCII and UDGs but also from
 3494 0B7F              ;   earlier to print mosaic characters.
 3495 0B7F              ;   HL=destination
 3496 0B7F              ;   DE=character source
 3497 0B7F              ;   BC=line/column
 3498 0B7F
 3499 0B7F              ;; PR-ALL
 3500 0B7F 79           L0B7F:  LD      A,C             ; column to A
 3501 0B80 3D                   DEC     A               ; move right
 3502 0B81 3E 21                LD      A,$21           ; pre-load with leftmost position
 3503 0B83 20 0E                JR      NZ,L0B93        ; but if not zero to PR-ALL-1
 3504 0B85
 3505 0B85 05                   DEC     B               ; down one line
 3506 0B86 4F                   LD      C,A             ; load C with $21
 3507 0B87 FD CB 01 4E          BIT     1,(IY+$01)      ; test FLAGS  - Is printer in use
 3508 0B8B 28 06                JR      Z,L0B93         ; to PR-ALL-1 if not
 3509 0B8D
 3510 0B8D D5                   PUSH    DE              ; save source address
 3511 0B8E CD CD 0E             CALL    L0ECD           ; routine COPY-BUFF outputs line to printer
 3512 0B91 D1                   POP     DE              ; restore character source address
 3513 0B92 79                   LD      A,C             ; the new column number ($21) to C
 3514 0B93
 3515 0B93              ;; PR-ALL-1
 3516 0B93 B9           L0B93:  CP      C               ; this test is really for screen - new line ?
 3517 0B94 D5                   PUSH    DE              ; save source
 3518 0B95
 3519 0B95 CC 55 0C             CALL    Z,L0C55         ; routine PO-SCR considers scrolling
 3520 0B98
 3521 0B98 D1                   POP     DE              ; restore source
 3522 0B99 C5                   PUSH    BC              ; save line/column
 3523 0B9A E5                   PUSH    HL              ; and destination
 3524 0B9B 3A 91 5C             LD      A,($5C91)       ; fetch P_FLAG to accumulator
 3525 0B9E 06 FF                LD      B,$FF           ; prepare OVER mask in B.
 3526 0BA0 1F                   RRA                     ; bit 0 set if OVER 1
 3527 0BA1 38 01                JR      C,L0BA4         ; to PR-ALL-2
 3528 0BA3
 3529 0BA3 04                   INC     B               ; set OVER mask to 0
 3530 0BA4
 3531 0BA4              ;; PR-ALL-2
 3532 0BA4 1F           L0BA4:  RRA                     ; skip bit 1 of P_FLAG
 3533 0BA5 1F                   RRA                     ; bit 2 is INVERSE
 3534 0BA6 9F                   SBC     A,A             ; will be FF for INVERSE 1 else zero
 3535 0BA7 4F                   LD      C,A             ; transfer INVERSE mask to C
 3536 0BA8 3E 08                LD      A,$08           ; prepare to count 8 bytes
 3537 0BAA A7                   AND     A               ; clear carry to signal screen
 3538 0BAB FD CB 01 4E          BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?
 3539 0BAF 28 05                JR      Z,L0BB6         ; to PR-ALL-3 if screen
 3540 0BB1
 3541 0BB1 FD CB 30 CE          SET     1,(IY+$30)      ; update FLAGS2  - signal printer buffer has
 3542 0BB5                                              ; been used.
 3543 0BB5 37                   SCF                     ; set carry flag to signal printer.
 3544 0BB6
 3545 0BB6              ;; PR-ALL-3
 3546 0BB6 EB           L0BB6:  EX      DE,HL           ; now HL=source, DE=destination
 3547 0BB7
 3548 0BB7              ;; PR-ALL-4
 3549 0BB7 08           L0BB7:  EX      AF,AF'          ; save printer/screen flag
 3550 0BB8 1A                   LD      A,(DE)          ; fetch existing destination byte
 3551 0BB9 A0                   AND     B               ; consider OVER
 3552 0BBA AE                   XOR     (HL)            ; now XOR with source
 3553 0BBB A9                   XOR     C               ; now with INVERSE MASK
 3554 0BBC 12                   LD      (DE),A          ; update screen/printer
 3555 0BBD 08                   EX      AF,AF'          ; restore flag
 3556 0BBE 38 13                JR      C,L0BD3         ; to PR-ALL-6 - printer address update
 3557 0BC0
 3558 0BC0 14                   INC     D               ; gives next pixel line down screen
 3559 0BC1
 3560 0BC1              ;; PR-ALL-5
 3561 0BC1 23           L0BC1:  INC     HL              ; address next character byte
 3562 0BC2 3D                   DEC     A               ; the byte count is decremented
 3563 0BC3 20 F2                JR      NZ,L0BB7        ; back to PR-ALL-4 for all 8 bytes
 3564 0BC5
 3565 0BC5 EB                   EX      DE,HL           ; destination to HL
 3566 0BC6 25                   DEC     H               ; bring back to last updated screen position
 3567 0BC7 FD CB 01 4E          BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?
 3568 0BCB CC DB 0B             CALL    Z,L0BDB         ; if not, call routine PO-ATTR to update
 3569 0BCE                                              ; corresponding colour attribute.
 3570 0BCE E1                   POP     HL              ; restore original screen/printer position
 3571 0BCF C1                   POP     BC              ; and line column
 3572 0BD0 0D                   DEC     C               ; move column to right
 3573 0BD1 23                   INC     HL              ; increase screen/printer position
 3574 0BD2 C9                   RET                     ; return and continue into PO-STORE
 3575 0BD3                                              ; within PO-ABLE
 3576 0BD3
 3577 0BD3              ; ---
 3578 0BD3
 3579 0BD3              ;   This branch is used to update the printer position by 32 places
 3580 0BD3              ;   Note. The high byte of the address D remains constant (which it should).
 3581 0BD3
 3582 0BD3              ;; PR-ALL-6
 3583 0BD3 08           L0BD3:  EX      AF,AF'          ; save the flag
 3584 0BD4 3E 20                LD      A,$20           ; load A with 32 decimal
 3585 0BD6 83                   ADD     A,E             ; add this to E
 3586 0BD7 5F                   LD      E,A             ; and store result in E
 3587 0BD8 08                   EX      AF,AF'          ; fetch the flag
 3588 0BD9 18 E6                JR      L0BC1           ; back to PR-ALL-5
 3589 0BDB
 3590 0BDB              ; -----------------------------------
 3591 0BDB              ; THE 'GET ATTRIBUTE ADDRESS' ROUTINE
 3592 0BDB              ; -----------------------------------
 3593 0BDB              ;   This routine is entered with the HL register holding the last screen
 3594 0BDB              ;   address to be updated by PRINT or PLOT.
 3595 0BDB              ;   The Spectrum screen arrangement leads to the L register holding the correct
 3596 0BDB              ;   value for the attribute file and it is only necessary to manipulate H to
 3597 0BDB              ;   form the correct colour attribute address.
 3598 0BDB
 3599 0BDB              ;; PO-ATTR
 3600 0BDB 7C           L0BDB:  LD       A,H            ; fetch high byte $40 - $57
 3601 0BDC 0F                   RRCA                    ; shift
 3602 0BDD 0F                   RRCA                    ; bits 3 and 4
 3603 0BDE 0F                   RRCA                    ; to right.
 3604 0BDF E6 03                AND     $03             ; range is now 0 - 2
 3605 0BE1 F6 58                OR      $58             ; form correct high byte for third of screen
 3606 0BE3 67                   LD      H,A             ; HL is now correct
 3607 0BE4 ED 5B 8F 5C          LD      DE,($5C8F)      ; make D hold ATTR_T, E hold MASK-T
 3608 0BE8 7E                   LD      A,(HL)          ; fetch existing attribute
 3609 0BE9 AB                   XOR     E               ; apply masks
 3610 0BEA A2                   AND     D               ;
 3611 0BEB AB                   XOR     E               ;
 3612 0BEC FD CB 57 76          BIT     6,(IY+$57)      ; test P_FLAG  - is this PAPER 9 ??
 3613 0BF0 28 08                JR      Z,L0BFA         ; skip to PO-ATTR-1 if not.
 3614 0BF2
 3615 0BF2 E6 C7                AND     $C7             ; set paper
 3616 0BF4 CB 57                BIT     2,A             ; to contrast with ink
 3617 0BF6 20 02                JR      NZ,L0BFA        ; skip to PO-ATTR-1
 3618 0BF8
 3619 0BF8 EE 38                XOR     $38             ;
 3620 0BFA
 3621 0BFA              ;; PO-ATTR-1
 3622 0BFA FD CB 57 66  L0BFA:  BIT     4,(IY+$57)      ; test P_FLAG  - Is this INK 9 ??
 3623 0BFE 28 08                JR      Z,L0C08         ; skip to PO-ATTR-2 if not
 3624 0C00
 3625 0C00 E6 F8                AND     $F8             ; make ink
 3626 0C02 CB 6F                BIT     5,A             ; contrast with paper.
 3627 0C04 20 02                JR      NZ,L0C08        ; to PO-ATTR-2
 3628 0C06
 3629 0C06 EE 07                XOR     $07             ;
 3630 0C08
 3631 0C08              ;; PO-ATTR-2
 3632 0C08 77           L0C08:  LD      (HL),A          ; save the new attribute.
 3633 0C09 C9                   RET                     ; return.
 3634 0C0A
 3635 0C0A              ; ---------------------------------
 3636 0C0A              ; THE 'MESSAGE PRINTING' SUBROUTINE
 3637 0C0A              ; ---------------------------------
 3638 0C0A              ;   This entry point is used to print tape, boot-up, scroll? and error messages.
 3639 0C0A              ;   On entry the DE register points to an initial step-over byte or the
 3640 0C0A              ;   inverted end-marker of the previous entry in the table.
 3641 0C0A              ;   Register A contains the message number, often zero to print first message.
 3642 0C0A              ;   (HL has nothing important usually P_FLAG)
 3643 0C0A
 3644 0C0A              ;; PO-MSG
 3645 0C0A E5           L0C0A:  PUSH    HL              ; put hi-byte zero on stack to suppress
 3646 0C0B 26 00                LD      H,$00           ; trailing spaces
 3647 0C0D E3                   EX      (SP),HL         ; ld h,0; push hl would have done ?.
 3648 0C0E 18 04                JR      L0C14           ; forward to PO-TABLE.
 3649 0C10
 3650 0C10              ; ---
 3651 0C10
 3652 0C10              ;   This entry point prints the BASIC keywords, '<>' etc. from alt set
 3653 0C10
 3654 0C10              ;; PO-TOKENS
 3655 0C10 11 95 00     L0C10:  LD      DE,L0095        ; address: TKN-TABLE
 3656 0C13 F5                   PUSH    AF              ; save the token number to control
 3657 0C14                                              ; trailing spaces - see later *
 3658 0C14
 3659 0C14              ; ->
 3660 0C14
 3661 0C14              ;; PO-TABLE
 3662 0C14 CD 41 0C     L0C14:  CALL    L0C41           ; routine PO-SEARCH will set carry for
 3663 0C17                                              ; all messages and function words.
 3664 0C17
 3665 0C17 38 09                JR      C,L0C22         ; forward to PO-EACH if not a command, '<>' etc.
 3666 0C19
 3667 0C19 3E 20                LD      A,$20           ; prepare leading space
 3668 0C1B FD CB 01 46          BIT     0,(IY+$01)      ; test FLAGS  - leading space if not set
 3669 0C1F
 3670 0C1F CC 3B 0C             CALL    Z,L0C3B         ; routine PO-SAVE to print a space without
 3671 0C22                                              ; disturbing registers.
 3672 0C22
 3673 0C22              ;; PO-EACH
 3674 0C22 1A           L0C22:  LD      A,(DE)          ; Fetch character from the table.
 3675 0C23 E6 7F                AND     $7F             ; Cancel any inverted bit.
 3676 0C25
 3677 0C25 CD 3B 0C             CALL    L0C3B           ; Routine PO-SAVE to print using the alternate
 3678 0C28                                              ; set of registers.
 3679 0C28
 3680 0C28 1A                   LD      A,(DE)          ; Re-fetch character from table.
 3681 0C29 13                   INC     DE              ; Address next character in the table.
 3682 0C2A
 3683 0C2A 87                   ADD     A,A             ; Was character inverted ?
 3684 0C2B                                              ; (this also doubles character)
 3685 0C2B 30 F5                JR      NC,L0C22        ; back to PO-EACH if not.
 3686 0C2D
 3687 0C2D D1                   POP     DE              ; * re-fetch trailing space byte to D
 3688 0C2E
 3689 0C2E FE 48                CP      $48             ; was the last character '$' ?
 3690 0C30 28 03                JR      Z,L0C35         ; forward to PO-TR-SP to consider trailing
 3691 0C32                                              ; space if so.
 3692 0C32
 3693 0C32 FE 82                CP      $82             ; was it < 'A' i.e. '#','>','=' from tokens
 3694 0C34                                              ; or ' ','.' (from tape) or '?' from scroll
 3695 0C34
 3696 0C34 D8                   RET     C               ; Return if so as no trailing space required.
 3697 0C35
 3698 0C35              ;; PO-TR-SP
 3699 0C35 7A           L0C35:  LD      A,D             ; The trailing space flag (zero if an error msg)
 3700 0C36
 3701 0C36 FE 03                CP      $03             ; Test against RND, INKEY$ and PI which have no
 3702 0C38                                              ; parameters and therefore no trailing space.
 3703 0C38
 3704 0C38 D8                   RET     C               ; Return if no trailing space.
 3705 0C39
 3706 0C39 3E 20                LD      A,$20           ; Prepare the space character and continue to
 3707 0C3B                                              ; print and make an indirect return.
 3708 0C3B
 3709 0C3B              ; -----------------------------------
 3710 0C3B              ; THE 'RECURSIVE PRINTING' SUBROUTINE
 3711 0C3B              ; -----------------------------------
 3712 0C3B              ;   This routine which is part of PRINT-OUT allows RST $10 to be used
 3713 0C3B              ;   recursively to print tokens and the spaces associated with them.
 3714 0C3B              ;   It is called on three occasions when the value of DE must be preserved.
 3715 0C3B
 3716 0C3B              ;; PO-SAVE
 3717 0C3B D5           L0C3B:  PUSH    DE              ; Save DE value.
 3718 0C3C D9                   EXX                     ; Switch in main set
 3719 0C3D
 3720 0C3D D7                   RST     10H             ; PRINT-A prints using this alternate set.
 3721 0C3E
 3722 0C3E D9                   EXX                     ; Switch back to this alternate set.
 3723 0C3F D1                   POP     DE              ; Restore the initial DE value.
 3724 0C40
 3725 0C40 C9                   RET                     ; Return.
 3726 0C41
 3727 0C41              ; ------------
 3728 0C41              ; Table search
 3729 0C41              ; ------------
 3730 0C41              ; This subroutine searches a message or the token table for the
 3731 0C41              ; message number held in A. DE holds the address of the table.
 3732 0C41
 3733 0C41              ;; PO-SEARCH
 3734 0C41 F5           L0C41:  PUSH    AF              ; save the message/token number
 3735 0C42 EB                   EX      DE,HL           ; transfer DE to HL
 3736 0C43 3C                   INC     A               ; adjust for initial step-over byte
 3737 0C44
 3738 0C44              ;; PO-STEP
 3739 0C44 CB 7E        L0C44:  BIT     7,(HL)          ; is character inverted ?
 3740 0C46 23                   INC     HL              ; address next
 3741 0C47 28 FB                JR      Z,L0C44         ; back to PO-STEP if not inverted.
 3742 0C49
 3743 0C49 3D                   DEC     A               ; decrease counter
 3744 0C4A 20 F8                JR      NZ,L0C44        ; back to PO-STEP if not zero
 3745 0C4C
 3746 0C4C EB                   EX      DE,HL           ; transfer address to DE
 3747 0C4D F1                   POP     AF              ; restore message/token number
 3748 0C4E FE 20                CP      $20             ; return with carry set
 3749 0C50 D8                   RET     C               ; for all messages and function tokens
 3750 0C51
 3751 0C51 1A                   LD      A,(DE)          ; test first character of token
 3752 0C52 D6 41                SUB     $41             ; and return with carry set
 3753 0C54 C9                   RET                     ; if it is less that 'A'
 3754 0C55                                              ; i.e. '<>', '<=', '>='
 3755 0C55
 3756 0C55              ; ---------------
 3757 0C55              ; Test for scroll
 3758 0C55              ; ---------------
 3759 0C55              ; This test routine is called when printing carriage return, when considering
 3760 0C55              ; PRINT AT and from the general PRINT ALL characters routine to test if
 3761 0C55              ; scrolling is required, prompting the user if necessary.
 3762 0C55              ; This is therefore using the alternate set.
 3763 0C55              ; The B register holds the current line.
 3764 0C55
 3765 0C55              ;; PO-SCR
 3766 0C55 FD CB 01 4E  L0C55:  BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?
 3767 0C59 C0                   RET     NZ              ; return immediately if so.
 3768 0C5A
 3769 0C5A 11 D9 0D             LD      DE,L0DD9        ; set DE to address: CL-SET
 3770 0C5D D5                   PUSH    DE              ; and push for return address.
 3771 0C5E
 3772 0C5E 78                   LD      A,B             ; transfer the line to A.
 3773 0C5F FD CB 02 46          BIT     0,(IY+$02)      ; test TV_FLAG - lower screen in use ?
 3774 0C63 C2 02 0D             JP      NZ,L0D02        ; jump forward to PO-SCR-4 if so.
 3775 0C66
 3776 0C66 FD BE 31             CP      (IY+$31)        ; greater than DF_SZ display file size ?
 3777 0C69 38 1B                JR      C,L0C86         ; forward to REPORT-5 if less.
 3778 0C6B                                              ; 'Out of screen'
 3779 0C6B
 3780 0C6B C0                   RET     NZ              ; return (via CL-SET) if greater
 3781 0C6C
 3782 0C6C FD CB 02 66          BIT     4,(IY+$02)      ; test TV_FLAG  - Automatic listing ?
 3783 0C70 28 16                JR      Z,L0C88         ; forward to PO-SCR-2 if not.
 3784 0C72
 3785 0C72 FD 5E 2D             LD      E,(IY+$2D)      ; fetch BREG - the count of scroll lines to E.
 3786 0C75 1D                   DEC     E               ; decrease and jump
 3787 0C76 28 5A                JR      Z,L0CD2         ; to PO-SCR-3 if zero and scrolling required.
 3788 0C78
 3789 0C78 3E 00                LD      A,$00           ; explicit - select channel zero.
 3790 0C7A CD 01 16             CALL    L1601           ; routine CHAN-OPEN opens it.
 3791 0C7D
 3792 0C7D ED 7B 3F 5C          LD      SP,($5C3F)      ; set stack pointer to LIST_SP
 3793 0C81
 3794 0C81 FD CB 02 A6          RES     4,(IY+$02)      ; reset TV_FLAG  - signal auto listing finished.
 3795 0C85 C9                   RET                     ; return ignoring pushed value, CL-SET
 3796 0C86                                              ; to MAIN or EDITOR without updating
 3797 0C86                                              ; print position                         >>
 3798 0C86
 3799 0C86              ; ---
 3800 0C86
 3801 0C86
 3802 0C86              ;; REPORT-5
 3803 0C86 CF           L0C86:  RST     08H             ; ERROR-1
 3804 0C87 04                   DEFB    $04             ; Error Report: Out of screen
 3805 0C88
 3806 0C88              ; continue here if not an automatic listing.
 3807 0C88
 3808 0C88              ;; PO-SCR-2
 3809 0C88 FD 35 52     L0C88:  DEC     (IY+$52)        ; decrease SCR_CT
 3810 0C8B 20 45                JR      NZ,L0CD2        ; forward to PO-SCR-3 to scroll display if
 3811 0C8D                                              ; result not zero.
 3812 0C8D
 3813 0C8D              ; now produce prompt.
 3814 0C8D
 3815 0C8D 3E 18                LD      A,$18           ; reset
 3816 0C8F 90                   SUB     B               ; the
 3817 0C90 32 8C 5C             LD      ($5C8C),A       ; SCR_CT scroll count
 3818 0C93 2A 8F 5C             LD      HL,($5C8F)      ; L=ATTR_T, H=MASK_T
 3819 0C96 E5                   PUSH    HL              ; save on stack
 3820 0C97 3A 91 5C             LD      A,($5C91)       ; P_FLAG
 3821 0C9A F5                   PUSH    AF              ; save on stack to prevent lower screen
 3822 0C9B                                              ; attributes (BORDCR etc.) being applied.
 3823 0C9B 3E FD                LD      A,$FD           ; select system channel 'K'
 3824 0C9D CD 01 16             CALL    L1601           ; routine CHAN-OPEN opens it
 3825 0CA0 AF                   XOR     A               ; clear to address message directly
 3826 0CA1 11 F8 0C             LD      DE,L0CF8        ; make DE address: scrl-mssg
 3827 0CA4 CD 0A 0C             CALL    L0C0A           ; routine PO-MSG prints to lower screen
 3828 0CA7 FD CB 02 EE          SET     5,(IY+$02)      ; set TV_FLAG  - signal lower screen requires
 3829 0CAB                                              ; clearing
 3830 0CAB 21 3B 5C             LD      HL,$5C3B        ; make HL address FLAGS
 3831 0CAE CB DE                SET     3,(HL)          ; signal 'L' mode.
 3832 0CB0 CB AE                RES     5,(HL)          ; signal 'no new key'.
 3833 0CB2 D9                   EXX                     ; switch to main set.
 3834 0CB3                                              ; as calling chr input from alternative set.
 3835 0CB3 CD D4 15             CALL    L15D4           ; routine WAIT-KEY waits for new key
 3836 0CB6                                              ; Note. this is the right routine but the
 3837 0CB6                                              ; stream in use is unsatisfactory. From the
 3838 0CB6                                              ; choices available, it is however the best.
 3839 0CB6
 3840 0CB6 D9                   EXX                     ; switch back to alternate set.
 3841 0CB7 FE 20                CP      $20             ; space is considered as BREAK
 3842 0CB9 28 45                JR      Z,L0D00         ; forward to REPORT-D if so
 3843 0CBB                                              ; 'BREAK - CONT repeats'
 3844 0CBB
 3845 0CBB FE E2                CP      $E2             ; is character 'STOP' ?
 3846 0CBD 28 41                JR      Z,L0D00         ; forward to REPORT-D if so
 3847 0CBF
 3848 0CBF F6 20                OR      $20             ; convert to lower-case
 3849 0CC1 FE 6E                CP      $6E             ; is character 'n' ?
 3850 0CC3 28 3B                JR      Z,L0D00         ; forward to REPORT-D if so else scroll.
 3851 0CC5
 3852 0CC5 3E FE                LD      A,$FE           ; select system channel 'S'
 3853 0CC7 CD 01 16             CALL    L1601           ; routine CHAN-OPEN
 3854 0CCA F1                   POP     AF              ; restore original P_FLAG
 3855 0CCB 32 91 5C             LD      ($5C91),A       ; and save in P_FLAG.
 3856 0CCE E1                   POP     HL              ; restore original ATTR_T, MASK_T
 3857 0CCF 22 8F 5C             LD      ($5C8F),HL      ; and reset ATTR_T, MASK-T as 'scroll?' has
 3858 0CD2                                              ; been printed.
 3859 0CD2
 3860 0CD2              ;; PO-SCR-3
 3861 0CD2 CD FE 0D     L0CD2:  CALL    L0DFE           ; routine CL-SC-ALL to scroll whole display
 3862 0CD5 FD 46 31             LD      B,(IY+$31)      ; fetch DF_SZ to B
 3863 0CD8 04                   INC     B               ; increase to address last line of display
 3864 0CD9 0E 21                LD      C,$21           ; set C to $21 (was $21 from above routine)
 3865 0CDB C5                   PUSH    BC              ; save the line and column in BC.
 3866 0CDC
 3867 0CDC CD 9B 0E             CALL    L0E9B           ; routine CL-ADDR finds display address.
 3868 0CDF
 3869 0CDF 7C                   LD      A,H             ; now find the corresponding attribute byte
 3870 0CE0 0F                   RRCA                    ; (this code sequence is used twice
 3871 0CE1 0F                   RRCA                    ; elsewhere and is a candidate for
 3872 0CE2 0F                   RRCA                    ; a subroutine.)
 3873 0CE3 E6 03                AND     $03             ;
 3874 0CE5 F6 58                OR      $58             ;
 3875 0CE7 67                   LD      H,A             ;
 3876 0CE8
 3877 0CE8 11 E0 5A             LD      DE,$5AE0        ; start of last 'line' of attribute area
 3878 0CEB 1A                   LD      A,(DE)          ; get attribute for last line
 3879 0CEC 4E                   LD      C,(HL)          ; transfer to base line of upper part
 3880 0CED 06 20                LD      B,$20           ; there are thirty two bytes
 3881 0CEF EB                   EX      DE,HL           ; swap the pointers.
 3882 0CF0
 3883 0CF0              ;; PO-SCR-3A
 3884 0CF0 12           L0CF0:  LD      (DE),A          ; transfer
 3885 0CF1 71                   LD      (HL),C          ; attributes.
 3886 0CF2 13                   INC     DE              ; address next.
 3887 0CF3 23                   INC     HL              ; address next.
 3888 0CF4 10 FA                DJNZ    L0CF0           ; loop back to PO-SCR-3A for all adjacent
 3889 0CF6                                              ; attribute lines.
 3890 0CF6
 3891 0CF6 C1                   POP     BC              ; restore the line/column.
 3892 0CF7 C9                   RET                     ; return via CL-SET (was pushed on stack).
 3893 0CF8
 3894 0CF8              ; ---
 3895 0CF8
 3896 0CF8              ; The message 'scroll?' appears here with last byte inverted.
 3897 0CF8
 3898 0CF8              ;; scrl-mssg
 3899 0CF8 80           L0CF8:  DEFB    $80             ; initial step-over byte.
 3900 0CF9 73 63 72 6F          DEFM    "scroll"
 3900 0CFD 6C 6C
 3901 0CFF BF                   DEFB    '?'+$80
 3902 0D00
 3903 0D00              ;; REPORT-D
 3904 0D00 CF           L0D00:  RST     08H             ; ERROR-1
 3905 0D01 0C                   DEFB    $0C             ; Error Report: BREAK - CONT repeats
 3906 0D02
 3907 0D02              ; continue here if using lower display - A holds line number.
 3908 0D02
 3909 0D02              ;; PO-SCR-4
 3910 0D02 FE 02        L0D02:  CP      $02             ; is line number less than 2 ?
 3911 0D04 38 80                JR      C,L0C86         ; to REPORT-5 if so
 3912 0D06                                              ; 'Out of Screen'.
 3913 0D06
 3914 0D06 FD 86 31             ADD     A,(IY+$31)      ; add DF_SZ
 3915 0D09 D6 19                SUB     $19             ;
 3916 0D0B D0                   RET     NC              ; return if scrolling unnecessary
 3917 0D0C
 3918 0D0C ED 44                NEG                     ; Negate to give number of scrolls required.
 3919 0D0E C5                   PUSH    BC              ; save line/column
 3920 0D0F 47                   LD      B,A             ; count to B
 3921 0D10 2A 8F 5C             LD      HL,($5C8F)      ; fetch current ATTR_T, MASK_T to HL.
 3922 0D13 E5                   PUSH    HL              ; and save
 3923 0D14 2A 91 5C             LD      HL,($5C91)      ; fetch P_FLAG
 3924 0D17 E5                   PUSH    HL              ; and save.
 3925 0D18                                              ; to prevent corruption by input AT
 3926 0D18
 3927 0D18 CD 4D 0D             CALL    L0D4D           ; routine TEMPS sets to BORDCR etc
 3928 0D1B 78                   LD      A,B             ; transfer scroll number to A.
 3929 0D1C
 3930 0D1C              ;; PO-SCR-4A
 3931 0D1C F5           L0D1C:  PUSH    AF              ; save scroll number.
 3932 0D1D 21 6B 5C             LD      HL,$5C6B        ; address DF_SZ
 3933 0D20 46                   LD      B,(HL)          ; fetch old value
 3934 0D21 78                   LD      A,B             ; transfer to A
 3935 0D22 3C                   INC     A               ; and increment
 3936 0D23 77                   LD      (HL),A          ; then put back.
 3937 0D24 21 89 5C             LD      HL,$5C89        ; address S_POSN_hi - line
 3938 0D27 BE                   CP      (HL)            ; compare
 3939 0D28 38 03                JR      C,L0D2D         ; forward to PO-SCR-4B if scrolling required
 3940 0D2A
 3941 0D2A 34                   INC     (HL)            ; else increment S_POSN_hi
 3942 0D2B 06 18                LD      B,$18           ; set count to whole display ??
 3943 0D2D                                              ; Note. should be $17 and the top line will be
 3944 0D2D                                              ; scrolled into the ROM which is harmless on
 3945 0D2D                                              ; the standard set up.
 3946 0D2D                                              ; credit P.Giblin 1984.
 3947 0D2D
 3948 0D2D              ;; PO-SCR-4B
 3949 0D2D CD 00 0E     L0D2D:  CALL    L0E00           ; routine CL-SCROLL scrolls B lines
 3950 0D30 F1                   POP     AF              ; restore scroll counter.
 3951 0D31 3D                   DEC     A               ; decrease
 3952 0D32 20 E8                JR      NZ,L0D1C        ; back to PO-SCR-4A until done
 3953 0D34
 3954 0D34 E1                   POP     HL              ; restore original P_FLAG.
 3955 0D35 FD 75 57             LD      (IY+$57),L      ; and overwrite system variable P_FLAG.
 3956 0D38
 3957 0D38 E1                   POP     HL              ; restore original ATTR_T/MASK_T.
 3958 0D39 22 8F 5C             LD      ($5C8F),HL      ; and update system variables.
 3959 0D3C
 3960 0D3C ED 4B 88 5C          LD      BC,($5C88)      ; fetch S_POSN to BC.
 3961 0D40 FD CB 02 86          RES     0,(IY+$02)      ; signal to TV_FLAG  - main screen in use.
 3962 0D44 CD D9 0D             CALL    L0DD9           ; call routine CL-SET for upper display.
 3963 0D47
 3964 0D47 FD CB 02 C6          SET     0,(IY+$02)      ; signal to TV_FLAG  - lower screen in use.
 3965 0D4B C1                   POP     BC              ; restore line/column
 3966 0D4C C9                   RET                     ; return via CL-SET for lower display.
 3967 0D4D
 3968 0D4D              ; ----------------------
 3969 0D4D              ; Temporary colour items
 3970 0D4D              ; ----------------------
 3971 0D4D              ; This subroutine is called 11 times to copy the permanent colour items
 3972 0D4D              ; to the temporary ones.
 3973 0D4D
 3974 0D4D              ;; TEMPS
 3975 0D4D AF           L0D4D:  XOR     A               ; clear the accumulator
 3976 0D4E 2A 8D 5C             LD      HL,($5C8D)      ; fetch L=ATTR_P and H=MASK_P
 3977 0D51 FD CB 02 46          BIT     0,(IY+$02)      ; test TV_FLAG  - is lower screen in use ?
 3978 0D55 28 04                JR      Z,L0D5B         ; skip to TEMPS-1 if not
 3979 0D57
 3980 0D57 67                   LD      H,A             ; set H, MASK P, to 00000000.
 3981 0D58 FD 6E 0E             LD      L,(IY+$0E)      ; fetch BORDCR to L which is used for lower
 3982 0D5B                                              ; screen.
 3983 0D5B
 3984 0D5B              ;; TEMPS-1
 3985 0D5B 22 8F 5C     L0D5B:  LD      ($5C8F),HL      ; transfer values to ATTR_T and MASK_T
 3986 0D5E
 3987 0D5E              ; for the print flag the permanent values are odd bits, temporary even bits.
 3988 0D5E
 3989 0D5E 21 91 5C             LD      HL,$5C91        ; address P_FLAG.
 3990 0D61 20 02                JR      NZ,L0D65        ; skip to TEMPS-2 if lower screen using A=0.
 3991 0D63
 3992 0D63 7E                   LD      A,(HL)          ; else pick up flag bits.
 3993 0D64 0F                   RRCA                    ; rotate permanent bits to temporary bits.
 3994 0D65
 3995 0D65              ;; TEMPS-2
 3996 0D65 AE           L0D65:  XOR     (HL)            ;
 3997 0D66 E6 55                AND     $55             ; BIN 01010101
 3998 0D68 AE                   XOR     (HL)            ; permanent now as original
 3999 0D69 77                   LD      (HL),A          ; apply permanent bits to temporary bits.
 4000 0D6A C9                   RET                     ; and return.
 4001 0D6B
 4002 0D6B              ; -----------------
 4003 0D6B              ; THE 'CLS' COMMAND
 4004 0D6B              ; -----------------
 4005 0D6B              ;    This command clears the display.
 4006 0D6B              ;    The routine is also called during initialization and by the CLEAR command.
 4007 0D6B              ;    If it's difficult to write it should be difficult to read.
 4008 0D6B
 4009 0D6B              ;; CLS
 4010 0D6B CD AF 0D     L0D6B:  CALL    L0DAF           ; Routine CL-ALL clears the entire display and
 4011 0D6E                                              ; sets the attributes to the permanent ones
 4012 0D6E                                              ; from ATTR-P.
 4013 0D6E
 4014 0D6E              ;   Having cleared all 24 lines of the display area, continue into the
 4015 0D6E              ;   subroutine that clears the lower display area.  Note that at the moment
 4016 0D6E              ;   the attributes for the lower lines are the same as upper ones and have
 4017 0D6E              ;   to be changed to match the BORDER colour.
 4018 0D6E
 4019 0D6E              ; --------------------------
 4020 0D6E              ; THE 'CLS-LOWER' SUBROUTINE
 4021 0D6E              ; --------------------------
 4022 0D6E              ;   This routine is called from INPUT, and from the MAIN execution loop.
 4023 0D6E              ;   This is very much a housekeeping routine which clears between 2 and 23
 4024 0D6E              ;   lines of the display, setting attributes and correcting situations where
 4025 0D6E              ;   errors have occurred while the normal input and output routines have been
 4026 0D6E              ;   temporarily diverted to deal with, say colour control codes.
 4027 0D6E
 4028 0D6E              ;; CLS-LOWER
 4029 0D6E 21 3C 5C     L0D6E:  LD      HL,$5C3C        ; address System Variable TV_FLAG.
 4030 0D71 CB AE                RES     5,(HL)          ; TV_FLAG - signal do not clear lower screen.
 4031 0D73 CB C6                SET     0,(HL)          ; TV_FLAG - signal lower screen in use.
 4032 0D75
 4033 0D75 CD 4D 0D             CALL    L0D4D           ; routine TEMPS applies permanent attributes,
 4034 0D78                                              ; in this case BORDCR to ATTR_T.
 4035 0D78                                              ; Note. this seems unnecessary and is repeated
 4036 0D78                                              ; within CL-LINE.
 4037 0D78
 4038 0D78 FD 46 31             LD      B,(IY+$31)      ; fetch lower screen display file size DF_SZ
 4039 0D7B
 4040 0D7B CD 44 0E             CALL    L0E44           ; routine CL-LINE clears lines to bottom of the
 4041 0D7E                                              ; display and sets attributes from BORDCR while
 4042 0D7E                                              ; preserving the B register.
 4043 0D7E
 4044 0D7E 21 C0 5A             LD      HL,$5AC0        ; set initial attribute address to the leftmost
 4045 0D81                                              ; cell of second line up.
 4046 0D81
 4047 0D81 3A 8D 5C             LD      A,($5C8D)       ; fetch permanent attribute from ATTR_P.
 4048 0D84
 4049 0D84 05                   DEC     B               ; decrement lower screen display file size.
 4050 0D85
 4051 0D85 18 07                JR      L0D8E           ; forward to enter the backfill loop at CLS-3
 4052 0D87                                              ; where B is decremented again.
 4053 0D87
 4054 0D87              ; ---
 4055 0D87
 4056 0D87              ;   The backfill loop is entered at midpoint and ensures, if more than 2
 4057 0D87              ;   lines have been cleared, that any other lines take the permanent screen
 4058 0D87              ;   attributes.
 4059 0D87
 4060 0D87              ;; CLS-1
 4061 0D87 0E 20        L0D87:  LD      C,$20           ; set counter to 32 character cells per line
 4062 0D89
 4063 0D89              ;; CLS-2
 4064 0D89 2B           L0D89:  DEC     HL              ; decrease attribute address.
 4065 0D8A 77                   LD      (HL),A          ; and place attributes in next line up.
 4066 0D8B 0D                   DEC     C               ; decrease the 32 counter.
 4067 0D8C 20 FB                JR      NZ,L0D89        ; loop back to CLS-2 until all 32 cells done.
 4068 0D8E
 4069 0D8E              ;; CLS-3
 4070 0D8E 10 F7        L0D8E:  DJNZ    L0D87           ; decrease B counter and back to CLS-1
 4071 0D90                                              ; if not zero.
 4072 0D90
 4073 0D90 FD 36 31 02          LD      (IY+$31),$02    ; now set DF_SZ lower screen to 2
 4074 0D94
 4075 0D94              ; This entry point is also called from CL-ALL below to
 4076 0D94              ; reset the system channel input and output addresses to normal.
 4077 0D94
 4078 0D94              ;; CL-CHAN
 4079 0D94 3E FD        L0D94:  LD      A,$FD           ; select system channel 'K'
 4080 0D96
 4081 0D96 CD 01 16             CALL    L1601           ; routine CHAN-OPEN opens it.
 4082 0D99
 4083 0D99 2A 51 5C             LD      HL,($5C51)      ; fetch CURCHL to HL to address current channel
 4084 0D9C 11 F4 09             LD      DE,L09F4        ; set address to PRINT-OUT for first pass.
 4085 0D9F A7                   AND     A               ; clear carry for first pass.
 4086 0DA0
 4087 0DA0              ;; CL-CHAN-A
 4088 0DA0 73           L0DA0:  LD      (HL),E          ; Insert the output address on the first pass
 4089 0DA1 23                   INC     HL              ; or the input address on the second pass.
 4090 0DA2 72                   LD      (HL),D          ;
 4091 0DA3 23                   INC     HL              ;
 4092 0DA4
 4093 0DA4 11 A8 10             LD      DE,L10A8        ; fetch address KEY-INPUT for second pass
 4094 0DA7 3F                   CCF                     ; complement carry flag - will set on pass 1.
 4095 0DA8
 4096 0DA8 38 F6                JR      C,L0DA0         ; back to CL-CHAN-A if first pass else done.
 4097 0DAA
 4098 0DAA 01 21 17             LD      BC,$1721        ; line 23 for lower screen
 4099 0DAD 18 2A                JR      L0DD9           ; exit via CL-SET to set column
 4100 0DAF                                              ; for lower display
 4101 0DAF
 4102 0DAF              ; ---------------------------
 4103 0DAF              ; Clearing whole display area
 4104 0DAF              ; ---------------------------
 4105 0DAF              ; This subroutine called from CLS, AUTO-LIST and MAIN-3
 4106 0DAF              ; clears 24 lines of the display and resets the relevant system variables.
 4107 0DAF              ; This routine also recovers from an error situation where, for instance, an
 4108 0DAF              ; invalid colour or position control code has left the output routine addressing
 4109 0DAF              ; PO-TV-2 or PO-CONT.
 4110 0DAF
 4111 0DAF              ;; CL-ALL
 4112 0DAF 21 00 00     L0DAF:  LD      HL,$0000        ; Initialize plot coordinates.
 4113 0DB2 22 7D 5C             LD      ($5C7D),HL      ; Set system variable COORDS to 0,0.
 4114 0DB5
 4115 0DB5 FD CB 30 86          RES     0,(IY+$30)      ; update FLAGS2  - signal main screen is clear.
 4116 0DB9
 4117 0DB9 CD 94 0D             CALL    L0D94           ; routine CL-CHAN makes channel 'K' 'normal'.
 4118 0DBC
 4119 0DBC 3E FE                LD      A,$FE           ; select system channel 'S'
 4120 0DBE CD 01 16             CALL    L1601           ; routine CHAN-OPEN opens it.
 4121 0DC1
 4122 0DC1 CD 4D 0D             CALL    L0D4D           ; routine TEMPS applies permanent attributes,
 4123 0DC4                                              ; in this case ATTR_P, to ATTR_T.
 4124 0DC4                                              ; Note. this seems unnecessary.
 4125 0DC4
 4126 0DC4 06 18                LD      B,$18           ; There are 24 lines.
 4127 0DC6
 4128 0DC6 CD 44 0E             CALL    L0E44           ; routine CL-LINE clears 24 text lines and sets
 4129 0DC9                                              ; attributes from ATTR-P.
 4130 0DC9                                              ; This routine preserves B and sets C to $21.
 4131 0DC9
 4132 0DC9 2A 51 5C             LD      HL,($5C51)      ; fetch CURCHL make HL address output routine.
 4133 0DCC
 4134 0DCC 11 F4 09             LD      DE,L09F4        ; address: PRINT-OUT
 4135 0DCF 73                   LD      (HL),E          ; is made
 4136 0DD0 23                   INC     HL              ; the normal
 4137 0DD1 72                   LD      (HL),D          ; output address.
 4138 0DD2
 4139 0DD2 FD 36 52 01          LD      (IY+$52),$01    ; set SCR_CT - scroll count - to default.
 4140 0DD6
 4141 0DD6              ;   Note. BC already contains $1821.
 4142 0DD6
 4143 0DD6 01 21 18             LD      BC,$1821        ; reset column and line to 0,0
 4144 0DD9                                              ; and continue into CL-SET, below, exiting
 4145 0DD9                                              ; via PO-STORE (for the upper screen).
 4146 0DD9
 4147 0DD9              ; --------------------
 4148 0DD9              ; THE 'CL-SET' ROUTINE
 4149 0DD9              ; --------------------
 4150 0DD9              ; This important subroutine is used to calculate the character output
 4151 0DD9              ; address for screens or printer based on the line/column for screens
 4152 0DD9              ; or the column for printer.
 4153 0DD9
 4154 0DD9              ;; CL-SET
 4155 0DD9 21 00 5B     L0DD9:  LD      HL,$5B00        ; the base address of printer buffer
 4156 0DDC FD CB 01 4E          BIT     1,(IY+$01)      ; test FLAGS  - is printer in use ?
 4157 0DE0 20 12                JR      NZ,L0DF4        ; forward to CL-SET-2 if so.
 4158 0DE2
 4159 0DE2 78                   LD      A,B             ; transfer line to A.
 4160 0DE3 FD CB 02 46          BIT     0,(IY+$02)      ; test TV_FLAG  - lower screen in use ?
 4161 0DE7 28 05                JR      Z,L0DEE         ; skip to CL-SET-1 if handling upper part
 4162 0DE9
 4163 0DE9 FD 86 31             ADD     A,(IY+$31)      ; add DF_SZ for lower screen
 4164 0DEC D6 18                SUB     $18             ; and adjust.
 4165 0DEE
 4166 0DEE              ;; CL-SET-1
 4167 0DEE C5           L0DEE:  PUSH    BC              ; save the line/column.
 4168 0DEF 47                   LD      B,A             ; transfer line to B
 4169 0DF0                                              ; (adjusted if lower screen)
 4170 0DF0
 4171 0DF0 CD 9B 0E             CALL    L0E9B           ; routine CL-ADDR calculates address at left
 4172 0DF3                                              ; of screen.
 4173 0DF3 C1                   POP     BC              ; restore the line/column.
 4174 0DF4
 4175 0DF4              ;; CL-SET-2
 4176 0DF4 3E 21        L0DF4:  LD      A,$21           ; the column $01-$21 is reversed
 4177 0DF6 91                   SUB     C               ; to range $00 - $20
 4178 0DF7 5F                   LD      E,A             ; now transfer to DE
 4179 0DF8 16 00                LD      D,$00           ; prepare for addition
 4180 0DFA 19                   ADD     HL,DE           ; and add to base address
 4181 0DFB
 4182 0DFB C3 DC 0A             JP      L0ADC           ; exit via PO-STORE to update the relevant
 4183 0DFE                                              ; system variables.
 4184 0DFE              ; ----------------
 4185 0DFE              ; Handle scrolling
 4186 0DFE              ; ----------------
 4187 0DFE              ; The routine CL-SC-ALL is called once from PO to scroll all the display
 4188 0DFE              ; and from the routine CL-SCROLL, once, to scroll part of the display.
 4189 0DFE
 4190 0DFE              ;; CL-SC-ALL
 4191 0DFE 06 17        L0DFE:  LD      B,$17           ; scroll 23 lines, after 'scroll?'.
 4192 0E00
 4193 0E00              ;; CL-SCROLL
 4194 0E00 CD 9B 0E     L0E00:  CALL    L0E9B           ; routine CL-ADDR gets screen address in HL.
 4195 0E03 0E 08                LD      C,$08           ; there are 8 pixel lines to scroll.
 4196 0E05
 4197 0E05              ;; CL-SCR-1
 4198 0E05 C5           L0E05:  PUSH    BC              ; save counters.
 4199 0E06 E5                   PUSH    HL              ; and initial address.
 4200 0E07 78                   LD      A,B             ; get line count.
 4201 0E08 E6 07                AND     $07             ; will set zero if all third to be scrolled.
 4202 0E0A 78                   LD      A,B             ; re-fetch the line count.
 4203 0E0B 20 0C                JR      NZ,L0E19        ; forward to CL-SCR-3 if partial scroll.
 4204 0E0D
 4205 0E0D              ; HL points to top line of third and must be copied to bottom of previous 3rd.
 4206 0E0D              ; ( so HL = $4800 or $5000 ) ( but also sometimes $4000 )
 4207 0E0D
 4208 0E0D              ;; CL-SCR-2
 4209 0E0D EB           L0E0D:  EX      DE,HL           ; copy HL to DE.
 4210 0E0E 21 E0 F8             LD      HL,$F8E0        ; subtract $08 from H and add $E0 to L -
 4211 0E11 19                   ADD     HL,DE           ; to make destination bottom line of previous
 4212 0E12                                              ; third.
 4213 0E12 EB                   EX      DE,HL           ; restore the source and destination.
 4214 0E13 01 20 00             LD      BC,$0020        ; thirty-two bytes are to be copied.
 4215 0E16 3D                   DEC     A               ; decrement the line count.
 4216 0E17 ED B0                LDIR                    ; copy a pixel line to previous third.
 4217 0E19
 4218 0E19              ;; CL-SCR-3
 4219 0E19 EB           L0E19:  EX      DE,HL           ; save source in DE.
 4220 0E1A 21 E0 FF             LD      HL,$FFE0        ; load the value -32.
 4221 0E1D 19                   ADD     HL,DE           ; add to form destination in HL.
 4222 0E1E EB                   EX      DE,HL           ; switch source and destination
 4223 0E1F 47                   LD      B,A             ; save the count in B.
 4224 0E20 E6 07                AND     $07             ; mask to find count applicable to current
 4225 0E22 0F                   RRCA                    ; third and
 4226 0E23 0F                   RRCA                    ; multiply by
 4227 0E24 0F                   RRCA                    ; thirty two (same as 5 RLCAs)
 4228 0E25
 4229 0E25 4F                   LD      C,A             ; transfer byte count to C ($E0 at most)
 4230 0E26 78                   LD      A,B             ; store line count to A
 4231 0E27 06 00                LD      B,$00           ; make B zero
 4232 0E29 ED B0                LDIR                    ; copy bytes (BC=0, H incremented, L=0)
 4233 0E2B 06 07                LD      B,$07           ; set B to 7, C is zero.
 4234 0E2D 09                   ADD     HL,BC           ; add 7 to H to address next third.
 4235 0E2E E6 F8                AND     $F8             ; has last third been done ?
 4236 0E30 20 DB                JR      NZ,L0E0D        ; back to CL-SCR-2 if not.
 4237 0E32
 4238 0E32 E1                   POP     HL              ; restore topmost address.
 4239 0E33 24                   INC     H               ; next pixel line down.
 4240 0E34 C1                   POP     BC              ; restore counts.
 4241 0E35 0D                   DEC     C               ; reduce pixel line count.
 4242 0E36 20 CD                JR      NZ,L0E05        ; back to CL-SCR-1 if all eight not done.
 4243 0E38
 4244 0E38 CD 88 0E             CALL    L0E88           ; routine CL-ATTR gets address in attributes
 4245 0E3B                                              ; from current 'ninth line', count in BC.
 4246 0E3B
 4247 0E3B 21 E0 FF             LD      HL,$FFE0        ; set HL to the 16-bit value -32.
 4248 0E3E 19                   ADD     HL,DE           ; and add to form destination address.
 4249 0E3F EB                   EX      DE,HL           ; swap source and destination addresses.
 4250 0E40 ED B0                LDIR                    ; copy bytes scrolling the linear attributes.
 4251 0E42 06 01                LD      B,$01           ; continue to clear the bottom line.
 4252 0E44
 4253 0E44              ; ------------------------------
 4254 0E44              ; THE 'CLEAR TEXT LINES' ROUTINE
 4255 0E44              ; ------------------------------
 4256 0E44              ; This subroutine, called from CL-ALL, CLS-LOWER and AUTO-LIST and above,
 4257 0E44              ; clears text lines at bottom of display.
 4258 0E44              ; The B register holds on entry the number of lines to be cleared 1-24.
 4259 0E44
 4260 0E44              ;; CL-LINE
 4261 0E44 C5           L0E44:  PUSH    BC              ; save line count
 4262 0E45 CD 9B 0E             CALL    L0E9B           ; routine CL-ADDR gets top address
 4263 0E48 0E 08                LD      C,$08           ; there are eight screen lines to a text line.
 4264 0E4A
 4265 0E4A              ;; CL-LINE-1
 4266 0E4A C5           L0E4A:  PUSH    BC              ; save pixel line count
 4267 0E4B E5                   PUSH    HL              ; and save the address
 4268 0E4C 78                   LD      A,B             ; transfer the line to A (1-24).
 4269 0E4D
 4270 0E4D              ;; CL-LINE-2
 4271 0E4D E6 07        L0E4D:  AND     $07             ; mask 0-7 to consider thirds at a time
 4272 0E4F 0F                   RRCA                    ; multiply
 4273 0E50 0F                   RRCA                    ; by 32  (same as five RLCA instructions)
 4274 0E51 0F                   RRCA                    ; now 32 - 256(0)
 4275 0E52 4F                   LD      C,A             ; store result in C
 4276 0E53 78                   LD      A,B             ; save line in A (1-24)
 4277 0E54 06 00                LD      B,$00           ; set high byte to 0, prepare for ldir.
 4278 0E56 0D                   DEC     C               ; decrement count 31-255.
 4279 0E57 54                   LD      D,H             ; copy HL
 4280 0E58 5D                   LD      E,L             ; to DE.
 4281 0E59 36 00                LD      (HL),$00        ; blank the first byte.
 4282 0E5B 13                   INC     DE              ; make DE point to next byte.
 4283 0E5C ED B0                LDIR                    ; ldir will clear lines.
 4284 0E5E 11 01 07             LD      DE,$0701        ; now address next third adjusting
 4285 0E61 19                   ADD     HL,DE           ; register E to address left hand side
 4286 0E62 3D                   DEC     A               ; decrease the line count.
 4287 0E63 E6 F8                AND     $F8             ; will be 16, 8 or 0  (AND $18 will do).
 4288 0E65 47                   LD      B,A             ; transfer count to B.
 4289 0E66 20 E5                JR      NZ,L0E4D        ; back to CL-LINE-2 if 16 or 8 to do
 4290 0E68                                              ; the next third.
 4291 0E68
 4292 0E68 E1                   POP     HL              ; restore start address.
 4293 0E69 24                   INC     H               ; address next line down.
 4294 0E6A C1                   POP     BC              ; fetch counts.
 4295 0E6B 0D                   DEC     C               ; decrement pixel line count
 4296 0E6C 20 DC                JR      NZ,L0E4A        ; back to CL-LINE-1 till all done.
 4297 0E6E
 4298 0E6E CD 88 0E             CALL    L0E88           ; routine CL-ATTR gets attribute address
 4299 0E71                                              ; in DE and B * 32 in BC.
 4300 0E71
 4301 0E71 62                   LD      H,D             ; transfer the address
 4302 0E72 6B                   LD      L,E             ; to HL.
 4303 0E73
 4304 0E73 13                   INC     DE              ; make DE point to next location.
 4305 0E74
 4306 0E74 3A 8D 5C             LD      A,($5C8D)       ; fetch ATTR_P - permanent attributes
 4307 0E77 FD CB 02 46          BIT     0,(IY+$02)      ; test TV_FLAG  - lower screen in use ?
 4308 0E7B 28 03                JR      Z,L0E80         ; skip to CL-LINE-3 if not.
 4309 0E7D
 4310 0E7D 3A 48 5C             LD      A,($5C48)       ; else lower screen uses BORDCR as attribute.
 4311 0E80
 4312 0E80              ;; CL-LINE-3
 4313 0E80 77           L0E80:  LD      (HL),A          ; put attribute in first byte.
 4314 0E81 0B                   DEC     BC              ; decrement the counter.
 4315 0E82 ED B0                LDIR                    ; copy bytes to set all attributes.
 4316 0E84 C1                   POP     BC              ; restore the line $01-$24.
 4317 0E85 0E 21                LD      C,$21           ; make column $21. (No use is made of this)
 4318 0E87 C9                   RET                     ; return to the calling routine.
 4319 0E88
 4320 0E88              ; ------------------
 4321 0E88              ; Attribute handling
 4322 0E88              ; ------------------
 4323 0E88              ; This subroutine is called from CL-LINE or CL-SCROLL with the HL register
 4324 0E88              ; pointing to the 'ninth' line and H needs to be decremented before or after
 4325 0E88              ; the division. Had it been done first then either present code or that used
 4326 0E88              ; at the start of PO-ATTR could have been used.
 4327 0E88              ; The Spectrum screen arrangement leads to the L register already holding
 4328 0E88              ; the correct value for the attribute file and it is only necessary
 4329 0E88              ; to manipulate H to form the correct colour attribute address.
 4330 0E88
 4331 0E88              ;; CL-ATTR
 4332 0E88 7C           L0E88:  LD      A,H             ; fetch H to A - $48, $50, or $58.
 4333 0E89 0F                   RRCA                    ; divide by
 4334 0E8A 0F                   RRCA                    ; eight.
 4335 0E8B 0F                   RRCA                    ; $09, $0A or $0B.
 4336 0E8C 3D                   DEC     A               ; $08, $09 or $0A.
 4337 0E8D F6 50                OR      $50             ; $58, $59 or $5A.
 4338 0E8F 67                   LD      H,A             ; save high byte of attributes.
 4339 0E90
 4340 0E90 EB                   EX      DE,HL           ; transfer attribute address to DE
 4341 0E91 61                   LD      H,C             ; set H to zero - from last LDIR.
 4342 0E92 68                   LD      L,B             ; load L with the line from B.
 4343 0E93 29                   ADD     HL,HL           ; multiply
 4344 0E94 29                   ADD     HL,HL           ; by
 4345 0E95 29                   ADD     HL,HL           ; thirty two
 4346 0E96 29                   ADD     HL,HL           ; to give count of attribute
 4347 0E97 29                   ADD     HL,HL           ; cells to the end of display.
 4348 0E98
 4349 0E98 44                   LD      B,H             ; transfer the result
 4350 0E99 4D                   LD      C,L             ; to register BC.
 4351 0E9A
 4352 0E9A C9                   RET                     ; return.
 4353 0E9B
 4354 0E9B              ; -------------------------------
 4355 0E9B              ; Handle display with line number
 4356 0E9B              ; -------------------------------
 4357 0E9B              ; This subroutine is called from four places to calculate the address
 4358 0E9B              ; of the start of a screen character line which is supplied in B.
 4359 0E9B
 4360 0E9B              ;; CL-ADDR
 4361 0E9B 3E 18        L0E9B:  LD      A,$18           ; reverse the line number
 4362 0E9D 90                   SUB     B               ; to range $00 - $17.
 4363 0E9E 57                   LD      D,A             ; save line in D for later.
 4364 0E9F 0F                   RRCA                    ; multiply
 4365 0EA0 0F                   RRCA                    ; by
 4366 0EA1 0F                   RRCA                    ; thirty-two.
 4367 0EA2
 4368 0EA2 E6 E0                AND     $E0             ; mask off low bits to make
 4369 0EA4 6F                   LD      L,A             ; L a multiple of 32.
 4370 0EA5
 4371 0EA5 7A                   LD      A,D             ; bring back the line to A.
 4372 0EA6
 4373 0EA6 E6 18                AND     $18             ; now $00, $08 or $10.
 4374 0EA8
 4375 0EA8 F6 40                OR      $40             ; add the base address of screen.
 4376 0EAA
 4377 0EAA 67                   LD      H,A             ; HL now has the correct address.
 4378 0EAB C9                   RET                     ; return.
 4379 0EAC
 4380 0EAC              ; -------------------
 4381 0EAC              ; Handle COPY command
 4382 0EAC              ; -------------------
 4383 0EAC              ; This command copies the top 176 lines to the ZX Printer
 4384 0EAC              ; It is popular to call this from machine code at point
 4385 0EAC              ; L0EAF with B holding 192 (and interrupts disabled) for a full-screen
 4386 0EAC              ; copy. This particularly applies to 16K Spectrums as time-critical
 4387 0EAC              ; machine code routines cannot be written in the first 16K of RAM as
 4388 0EAC              ; it is shared with the ULA which has precedence over the Z80 chip.
 4389 0EAC
 4390 0EAC              ;; COPY
 4391 0EAC F3           L0EAC:  DI                      ; disable interrupts as this is time-critical.
 4392 0EAD
 4393 0EAD 06 B0                LD      B,$B0           ; top 176 lines.
 4394 0EAF 21 00 40     L0EAF:  LD      HL,$4000        ; address start of the display file.
 4395 0EB2
 4396 0EB2              ; now enter a loop to handle each pixel line.
 4397 0EB2
 4398 0EB2              ;; COPY-1
 4399 0EB2 E5           L0EB2:  PUSH    HL              ; save the screen address.
 4400 0EB3 C5                   PUSH    BC              ; and the line counter.
 4401 0EB4
 4402 0EB4 CD F4 0E             CALL    L0EF4           ; routine COPY-LINE outputs one line.
 4403 0EB7
 4404 0EB7 C1                   POP     BC              ; restore the line counter.
 4405 0EB8 E1                   POP     HL              ; and display address.
 4406 0EB9 24                   INC     H               ; next line down screen within 'thirds'.
 4407 0EBA 7C                   LD      A,H             ; high byte to A.
 4408 0EBB E6 07                AND     $07             ; result will be zero if we have left third.
 4409 0EBD 20 0A                JR      NZ,L0EC9        ; forward to COPY-2 if not to continue loop.
 4410 0EBF
 4411 0EBF 7D                   LD      A,L             ; consider low byte first.
 4412 0EC0 C6 20                ADD     A,$20           ; increase by 32 - sets carry if back to zero.
 4413 0EC2 6F                   LD      L,A             ; will be next group of 8.
 4414 0EC3 3F                   CCF                     ; complement - carry set if more lines in
 4415 0EC4                                              ; the previous third.
 4416 0EC4 9F                   SBC     A,A             ; will be FF, if more, else 00.
 4417 0EC5 E6 F8                AND     $F8             ; will be F8 (-8) or 00.
 4418 0EC7 84                   ADD     A,H             ; that is subtract 8, if more to do in third.
 4419 0EC8 67                   LD      H,A             ; and reset address.
 4420 0EC9
 4421 0EC9              ;; COPY-2
 4422 0EC9 10 E7        L0EC9:  DJNZ    L0EB2           ; back to COPY-1 for all lines.
 4423 0ECB
 4424 0ECB 18 0D                JR      L0EDA           ; forward to COPY-END to switch off the printer
 4425 0ECD                                              ; motor and enable interrupts.
 4426 0ECD                                              ; Note. Nothing else is required.
 4427 0ECD
 4428 0ECD              ; ------------------------------
 4429 0ECD              ; Pass printer buffer to printer
 4430 0ECD              ; ------------------------------
 4431 0ECD              ; This routine is used to copy 8 text lines from the printer buffer
 4432 0ECD              ; to the ZX Printer. These text lines are mapped linearly so HL does
 4433 0ECD              ; not need to be adjusted at the end of each line.
 4434 0ECD
 4435 0ECD              ;; COPY-BUFF
 4436 0ECD F3           L0ECD:  DI                      ; disable interrupts
 4437 0ECE 21 00 5B             LD      HL,$5B00        ; the base address of the Printer Buffer.
 4438 0ED1 06 08                LD      B,$08           ; set count to 8 lines of 32 bytes.
 4439 0ED3
 4440 0ED3              ;; COPY-3
 4441 0ED3 C5           L0ED3:  PUSH    BC              ; save counter.
 4442 0ED4
 4443 0ED4 CD F4 0E             CALL    L0EF4           ; routine COPY-LINE outputs 32 bytes
 4444 0ED7
 4445 0ED7 C1                   POP     BC              ; restore counter.
 4446 0ED8 10 F9                DJNZ    L0ED3           ; loop back to COPY-3 for all 8 lines.
 4447 0EDA                                              ; then stop motor and clear buffer.
 4448 0EDA
 4449 0EDA              ; Note. the COPY command rejoins here, essentially to execute the next
 4450 0EDA              ; three instructions.
 4451 0EDA
 4452 0EDA              ;; COPY-END
 4453 0EDA 3E 04        L0EDA:  LD      A,$04           ; output value 4 to port
 4454 0EDC D3 FB                OUT     ($FB),A         ; to stop the slowed printer motor.
 4455 0EDE FB                   EI                      ; enable interrupts.
 4456 0EDF
 4457 0EDF              ; --------------------
 4458 0EDF              ; Clear Printer Buffer
 4459 0EDF              ; --------------------
 4460 0EDF              ; This routine clears an arbitrary 256 bytes of memory.
 4461 0EDF              ; Note. The routine seems designed to clear a buffer that follows the
 4462 0EDF              ; system variables.
 4463 0EDF              ; The routine should check a flag or HL address and simply return if COPY
 4464 0EDF              ; is in use.
 4465 0EDF              ; As a consequence of this omission the buffer will needlessly
 4466 0EDF              ; be cleared when COPY is used and the screen/printer position may be set to
 4467 0EDF              ; the start of the buffer and the line number to 0 (B)
 4468 0EDF              ; giving an 'Out of Screen' error.
 4469 0EDF              ; There seems to have been an unsuccessful attempt to circumvent the use
 4470 0EDF              ; of PR_CC_hi.
 4471 0EDF
 4472 0EDF              ;; CLEAR-PRB
 4473 0EDF 21 00 5B     L0EDF:  LD      HL,$5B00        ; the location of the buffer.
 4474 0EE2 FD 75 46             LD      (IY+$46),L      ; update PR_CC_lo - set to zero - superfluous.
 4475 0EE5 AF                   XOR     A               ; clear the accumulator.
 4476 0EE6 47                   LD      B,A             ; set count to 256 bytes.
 4477 0EE7
 4478 0EE7              ;; PRB-BYTES
 4479 0EE7 77           L0EE7:  LD      (HL),A          ; set addressed location to zero.
 4480 0EE8 23                   INC     HL              ; address next byte - Note. not INC L.
 4481 0EE9 10 FC                DJNZ    L0EE7           ; back to PRB-BYTES. repeat for 256 bytes.
 4482 0EEB
 4483 0EEB FD CB 30 8E          RES     1,(IY+$30)      ; set FLAGS2 - signal printer buffer is clear.
 4484 0EEF 0E 21                LD      C,$21           ; set the column position .
 4485 0EF1 C3 D9 0D             JP      L0DD9           ; exit via CL-SET and then PO-STORE.
 4486 0EF4
 4487 0EF4              ; -----------------
 4488 0EF4              ; Copy line routine
 4489 0EF4              ; -----------------
 4490 0EF4              ; This routine is called from COPY and COPY-BUFF to output a line of
 4491 0EF4              ; 32 bytes to the ZX Printer.
 4492 0EF4              ; Output to port $FB -
 4493 0EF4              ; bit 7 set - activate stylus.
 4494 0EF4              ; bit 7 low - deactivate stylus.
 4495 0EF4              ; bit 2 set - stops printer.
 4496 0EF4              ; bit 2 reset - starts printer
 4497 0EF4              ; bit 1 set - slows printer.
 4498 0EF4              ; bit 1 reset - normal speed.
 4499 0EF4
 4500 0EF4              ;; COPY-LINE
 4501 0EF4 78           L0EF4:  LD      A,B             ; fetch the counter 1-8 or 1-176
 4502 0EF5 FE 03                CP      $03             ; is it 01 or 02 ?.
 4503 0EF7 9F                   SBC     A,A             ; result is $FF if so else $00.
 4504 0EF8 E6 02                AND     $02             ; result is 02 now else 00.
 4505 0EFA                                              ; bit 1 set slows the printer.
 4506 0EFA D3 FB                OUT     ($FB),A         ; slow the printer for the
 4507 0EFC                                              ; last two lines.
 4508 0EFC 57                   LD      D,A             ; save the mask to control the printer later.
 4509 0EFD
 4510 0EFD              ;; COPY-L-1
 4511 0EFD CD 54 1F     L0EFD:  CALL    L1F54           ; call BREAK-KEY to read keyboard immediately.
 4512 0F00 38 0A                JR      C,L0F0C         ; forward to COPY-L-2 if 'break' not pressed.
 4513 0F02
 4514 0F02 3E 04                LD      A,$04           ; else stop the
 4515 0F04 D3 FB                OUT     ($FB),A         ; printer motor.
 4516 0F06 FB                   EI                      ; enable interrupts.
 4517 0F07 CD DF 0E             CALL    L0EDF           ; call routine CLEAR-PRB.
 4518 0F0A                                              ; Note. should not be cleared if COPY in use.
 4519 0F0A
 4520 0F0A              ;; REPORT-Dc
 4521 0F0A CF           L0F0A:  RST     08H             ; ERROR-1
 4522 0F0B 0C                   DEFB    $0C             ; Error Report: BREAK - CONT repeats
 4523 0F0C
 4524 0F0C              ;; COPY-L-2
 4525 0F0C DB FB        L0F0C:  IN      A,($FB)         ; test now to see if
 4526 0F0E 87                   ADD     A,A             ; a printer is attached.
 4527 0F0F F8                   RET     M               ; return if not - but continue with parent
 4528 0F10                                              ; command.
 4529 0F10
 4530 0F10 30 EB                JR      NC,L0EFD        ; back to COPY-L-1 if stylus of printer not
 4531 0F12                                              ; in position.
 4532 0F12
 4533 0F12 0E 20                LD      C,$20           ; set count to 32 bytes.
 4534 0F14
 4535 0F14              ;; COPY-L-3
 4536 0F14 5E           L0F14:  LD      E,(HL)          ; fetch a byte from line.
 4537 0F15 23                   INC     HL              ; address next location. Note. not INC L.
 4538 0F16 06 08                LD      B,$08           ; count the bits.
 4539 0F18
 4540 0F18              ;; COPY-L-4
 4541 0F18 CB 12        L0F18:  RL      D               ; prepare mask to receive bit.
 4542 0F1A CB 13                RL      E               ; rotate leftmost print bit to carry
 4543 0F1C CB 1A                RR      D               ; and back to bit 7 of D restoring bit 1
 4544 0F1E
 4545 0F1E              ;; COPY-L-5
 4546 0F1E DB FB        L0F1E:  IN      A,($FB)         ; read the port.
 4547 0F20 1F                   RRA                     ; bit 0 to carry.
 4548 0F21 30 FB                JR      NC,L0F1E        ; back to COPY-L-5 if stylus not in position.
 4549 0F23
 4550 0F23 7A                   LD      A,D             ; transfer command bits to A.
 4551 0F24 D3 FB                OUT     ($FB),A         ; and output to port.
 4552 0F26 10 F0                DJNZ    L0F18           ; loop back to COPY-L-4 for all 8 bits.
 4553 0F28
 4554 0F28 0D                   DEC     C               ; decrease the byte count.
 4555 0F29 20 E9                JR      NZ,L0F14        ; back to COPY-L-3 until 256 bits done.
 4556 0F2B
 4557 0F2B C9                   RET                     ; return to calling routine COPY/COPY-BUFF.
 4558 0F2C
 4559 0F2C
 4560 0F2C              ; ----------------------------------
 4561 0F2C              ; Editor routine for BASIC and INPUT
 4562 0F2C              ; ----------------------------------
 4563 0F2C              ; The editor is called to prepare or edit a BASIC line.
 4564 0F2C              ; It is also called from INPUT to input a numeric or string expression.
 4565 0F2C              ; The behaviour and options are quite different in the various modes
 4566 0F2C              ; and distinguished by bit 5 of FLAGX.
 4567 0F2C              ;
 4568 0F2C              ; This is a compact and highly versatile routine.
 4569 0F2C
 4570 0F2C              ;; EDITOR
 4571 0F2C 2A 3D 5C     L0F2C:  LD      HL,($5C3D)      ; fetch ERR_SP
 4572 0F2F E5                   PUSH    HL              ; save on stack
 4573 0F30
 4574 0F30              ;; ED-AGAIN
 4575 0F30 21 7F 10     L0F30:  LD      HL,L107F        ; address: ED-ERROR
 4576 0F33 E5                   PUSH    HL              ; save address on stack and
 4577 0F34 ED 73 3D 5C          LD      ($5C3D),SP      ; make ERR_SP point to it.
 4578 0F38
 4579 0F38              ; Note. While in editing/input mode should an error occur then RST 08 will
 4580 0F38              ; update X_PTR to the location reached by CH_ADD and jump to ED-ERROR
 4581 0F38              ; where the error will be cancelled and the loop begin again from ED-AGAIN
 4582 0F38              ; above. The position of the error will be apparent when the lower screen is
 4583 0F38              ; reprinted. If no error then the re-iteration is to ED-LOOP below when
 4584 0F38              ; input is arriving from the keyboard.
 4585 0F38
 4586 0F38              ;; ED-LOOP
 4587 0F38 CD D4 15     L0F38:  CALL    L15D4           ; routine WAIT-KEY gets key possibly
 4588 0F3B                                              ; changing the mode.
 4589 0F3B F5                   PUSH    AF              ; save key.
 4590 0F3C 16 00                LD      D,$00           ; and give a short click based
 4591 0F3E FD 5E FF             LD      E,(IY-$01)      ; on PIP value for duration.
 4592 0F41 21 C8 00             LD      HL,$00C8        ; and pitch.
 4593 0F44 CD B5 03             CALL    L03B5           ; routine BEEPER gives click - effective
 4594 0F47                                              ; with rubber keyboard.
 4595 0F47 F1                   POP     AF              ; get saved key value.
 4596 0F48 21 38 0F             LD      HL,L0F38        ; address: ED-LOOP is loaded to HL.
 4597 0F4B E5                   PUSH    HL              ; and pushed onto stack.
 4598 0F4C
 4599 0F4C              ; At this point there is a looping return address on the stack, an error
 4600 0F4C              ; handler and an input stream set up to supply characters.
 4601 0F4C              ; The character that has been received can now be processed.
 4602 0F4C
 4603 0F4C FE 18                CP      $18             ; range 24 to 255 ?
 4604 0F4E 30 31                JR      NC,L0F81        ; forward to ADD-CHAR if so.
 4605 0F50
 4606 0F50 FE 07                CP      $07             ; lower than 7 ?
 4607 0F52 38 2D                JR      C,L0F81         ; forward to ADD-CHAR also.
 4608 0F54                                              ; Note. This is a 'bug' and chr$ 6, the comma
 4609 0F54                                              ; control character, should have had an
 4610 0F54                                              ; entry in the ED-KEYS table.
 4611 0F54                                              ; Steven Vickers, 1984, Pitman.
 4612 0F54
 4613 0F54 FE 10                CP      $10             ; less than 16 ?
 4614 0F56 38 3A                JR      C,L0F92         ; forward to ED-KEYS if editing control
 4615 0F58                                              ; range 7 to 15 dealt with by a table
 4616 0F58
 4617 0F58 01 02 00             LD      BC,$0002        ; prepare for ink/paper etc.
 4618 0F5B 57                   LD      D,A             ; save character in D
 4619 0F5C FE 16                CP      $16             ; is it ink/paper/bright etc. ?
 4620 0F5E 38 0C                JR      C,L0F6C         ; forward to ED-CONTR if so
 4621 0F60
 4622 0F60                                              ; leaves 22d AT and 23d TAB
 4623 0F60                                              ; which can't be entered via KEY-INPUT.
 4624 0F60                                              ; so this code is never normally executed
 4625 0F60                                              ; when the keyboard is used for input.
 4626 0F60
 4627 0F60 03                   INC     BC              ; if it was AT/TAB - 3 locations required
 4628 0F61 FD CB 37 7E          BIT     7,(IY+$37)      ; test FLAGX  - Is this INPUT LINE ?
 4629 0F65 CA 1E 10             JP      Z,L101E         ; jump to ED-IGNORE if not, else
 4630 0F68
 4631 0F68 CD D4 15             CALL    L15D4           ; routine WAIT-KEY - input address is KEY-NEXT
 4632 0F6B                                              ; but is reset to KEY-INPUT
 4633 0F6B 5F                   LD      E,A             ; save first in E
 4634 0F6C
 4635 0F6C              ;; ED-CONTR
 4636 0F6C CD D4 15     L0F6C:  CALL    L15D4           ; routine WAIT-KEY for control.
 4637 0F6F                                              ; input address will be key-next.
 4638 0F6F
 4639 0F6F D5                   PUSH    DE              ; saved code/parameters
 4640 0F70 2A 5B 5C             LD      HL,($5C5B)      ; fetch address of keyboard cursor from K_CUR
 4641 0F73 FD CB 07 86          RES     0,(IY+$07)      ; set MODE to 'L'
 4642 0F77
 4643 0F77 CD 55 16             CALL    L1655           ; routine MAKE-ROOM makes 2/3 spaces at cursor
 4644 0F7A
 4645 0F7A C1                   POP     BC              ; restore code/parameters
 4646 0F7B 23                   INC     HL              ; address first location
 4647 0F7C 70                   LD      (HL),B          ; place code (ink etc.)
 4648 0F7D 23                   INC     HL              ; address next
 4649 0F7E 71                   LD      (HL),C          ; place possible parameter. If only one
 4650 0F7F                                              ; then DE points to this location also.
 4651 0F7F 18 0A                JR      L0F8B           ; forward to ADD-CH-1
 4652 0F81
 4653 0F81              ; ------------------------
 4654 0F81              ; Add code to current line
 4655 0F81              ; ------------------------
 4656 0F81              ; this is the branch used to add normal non-control characters
 4657 0F81              ; with ED-LOOP as the stacked return address.
 4658 0F81              ; it is also the OUTPUT service routine for system channel 'R'.
 4659 0F81
 4660 0F81              ;; ADD-CHAR
 4661 0F81 FD CB 07 86  L0F81:  RES     0,(IY+$07)      ; set MODE to 'L'
 4662 0F85
 4663 0F85 2A 5B 5C     X0F85:  LD      HL,($5C5B)      ; fetch address of keyboard cursor from K_CUR
 4664 0F88
 4665 0F88 CD 52 16             CALL    L1652           ; routine ONE-SPACE creates one space.
 4666 0F8B
 4667 0F8B              ; either a continuation of above or from ED-CONTR with ED-LOOP on stack.
 4668 0F8B
 4669 0F8B              ;; ADD-CH-1
 4670 0F8B 12           L0F8B:  LD      (DE),A          ; load current character to last new location.
 4671 0F8C 13                   INC     DE              ; address next
 4672 0F8D ED 53 5B 5C          LD      ($5C5B),DE      ; and update K_CUR system variable.
 4673 0F91 C9                   RET                     ; return - either a simple return
 4674 0F92                                              ; from ADD-CHAR or to ED-LOOP on stack.
 4675 0F92
 4676 0F92              ; ---
 4677 0F92
 4678 0F92              ; a branch of the editing loop to deal with control characters
 4679 0F92              ; using a look-up table.
 4680 0F92
 4681 0F92              ;; ED-KEYS
 4682 0F92 5F           L0F92:  LD      E,A             ; character to E.
 4683 0F93 16 00                LD      D,$00           ; prepare to add.
 4684 0F95 21 99 0F             LD      HL,L0FA0 - 7    ; base address of editing keys table. $0F99
 4685 0F98 19                   ADD     HL,DE           ; add E
 4686 0F99 5E                   LD      E,(HL)          ; fetch offset to E
 4687 0F9A 19                   ADD     HL,DE           ; add offset for address of handling routine.
 4688 0F9B E5                   PUSH    HL              ; push the address on machine stack.
 4689 0F9C 2A 5B 5C             LD      HL,($5C5B)      ; load address of cursor from K_CUR.
 4690 0F9F C9                   RET                     ; Make an indirect jump forward to routine.
 4691 0FA0
 4692 0FA0              ; ------------------
 4693 0FA0              ; Editing keys table
 4694 0FA0              ; ------------------
 4695 0FA0              ; For each code in the range $07 to $0F this table contains a
 4696 0FA0              ; single offset byte to the routine that services that code.
 4697 0FA0              ; Note. for what was intended there should also have been an
 4698 0FA0              ; entry for chr$ 6 with offset to ed-symbol.
 4699 0FA0
 4700 0FA0              ;; ed-keys-t
 4701 0FA0 09           L0FA0:  DEFB    L0FA9 - $  ; 07d offset $09 to Address: ED-EDIT
 4702 0FA1 66                   DEFB    L1007 - $  ; 08d offset $66 to Address: ED-LEFT
 4703 0FA2 6A                   DEFB    L100C - $  ; 09d offset $6A to Address: ED-RIGHT
 4704 0FA3 50                   DEFB    L0FF3 - $  ; 10d offset $50 to Address: ED-DOWN
 4705 0FA4 B5                   DEFB    L1059 - $  ; 11d offset $B5 to Address: ED-UP
 4706 0FA5 70                   DEFB    L1015 - $  ; 12d offset $70 to Address: ED-DELETE
 4707 0FA6 7E                   DEFB    L1024 - $  ; 13d offset $7E to Address: ED-ENTER
 4708 0FA7 CF                   DEFB    L1076 - $  ; 14d offset $CF to Address: ED-SYMBOL
 4709 0FA8 D4                   DEFB    L107C - $  ; 15d offset $D4 to Address: ED-GRAPH
 4710 0FA9
 4711 0FA9              ; ---------------
 4712 0FA9              ; Handle EDIT key
 4713 0FA9              ; ---------------
 4714 0FA9              ; The user has pressed SHIFT 1 to bring edit line down to bottom of screen.
 4715 0FA9              ; Alternatively the user wishes to clear the input buffer and start again.
 4716 0FA9              ; Alternatively ...
 4717 0FA9
 4718 0FA9              ;; ED-EDIT
 4719 0FA9 2A 49 5C     L0FA9:  LD      HL,($5C49)      ; fetch E_PPC the last line number entered.
 4720 0FAC                                              ; Note. may not exist and may follow program.
 4721 0FAC FD CB 37 6E          BIT     5,(IY+$37)      ; test FLAGX  - input mode ?
 4722 0FB0 C2 97 10             JP      NZ,L1097        ; jump forward to CLEAR-SP if not in editor.
 4723 0FB3
 4724 0FB3 CD 6E 19             CALL    L196E           ; routine LINE-ADDR to find address of line
 4725 0FB6                                              ; or following line if it doesn't exist.
 4726 0FB6 CD 95 16             CALL    L1695           ; routine LINE-NO will get line number from
 4727 0FB9                                              ; address or previous line if at end-marker.
 4728 0FB9 7A                   LD      A,D             ; if there is no program then DE will
 4729 0FBA B3                   OR      E               ; contain zero so test for this.
 4730 0FBB CA 97 10             JP      Z,L1097         ; jump to CLEAR-SP if so.
 4731 0FBE
 4732 0FBE              ; Note. at this point we have a validated line number, not just an
 4733 0FBE              ; approximation and it would be best to update E_PPC with the true
 4734 0FBE              ; cursor line value which would enable the line cursor to be suppressed
 4735 0FBE              ; in all situations - see shortly.
 4736 0FBE
 4737 0FBE E5                   PUSH    HL              ; save address of line.
 4738 0FBF 23                   INC     HL              ; address low byte of length.
 4739 0FC0 4E                   LD      C,(HL)          ; transfer to C
 4740 0FC1 23                   INC     HL              ; next to high byte
 4741 0FC2 46                   LD      B,(HL)          ; transfer to B.
 4742 0FC3 21 0A 00             LD      HL,$000A        ; an overhead of ten bytes
 4743 0FC6 09                   ADD     HL,BC           ; is added to length.
 4744 0FC7 44                   LD      B,H             ; transfer adjusted value
 4745 0FC8 4D                   LD      C,L             ; to BC register.
 4746 0FC9 CD 05 1F             CALL    L1F05           ; routine TEST-ROOM checks free memory.
 4747 0FCC CD 97 10             CALL    L1097           ; routine CLEAR-SP clears editing area.
 4748 0FCF 2A 51 5C             LD      HL,($5C51)      ; address CURCHL
 4749 0FD2 E3                   EX      (SP),HL         ; swap with line address on stack
 4750 0FD3 E5                   PUSH    HL              ; save line address underneath
 4751 0FD4
 4752 0FD4 3E FF                LD      A,$FF           ; select system channel 'R'
 4753 0FD6 CD 01 16             CALL    L1601           ; routine CHAN-OPEN opens it
 4754 0FD9
 4755 0FD9 E1                   POP     HL              ; drop line address
 4756 0FDA 2B                   DEC     HL              ; make it point to first byte of line num.
 4757 0FDB FD 35 0F             DEC     (IY+$0F)        ; decrease E_PPC_lo to suppress line cursor.
 4758 0FDE                                              ; Note. ineffective when E_PPC is one
 4759 0FDE                                              ; greater than last line of program perhaps
 4760 0FDE                                              ; as a result of a delete.
 4761 0FDE                                              ; credit. Paul Harrison 1982.
 4762 0FDE
 4763 0FDE CD 55 18             CALL    L1855           ; routine OUT-LINE outputs the BASIC line
 4764 0FE1                                              ; to the editing area.
 4765 0FE1 FD 34 0F             INC     (IY+$0F)        ; restore E_PPC_lo to the previous value.
 4766 0FE4 2A 59 5C             LD      HL,($5C59)      ; address E_LINE in editing area.
 4767 0FE7 23                   INC     HL              ; advance
 4768 0FE8 23                   INC     HL              ; past space
 4769 0FE9 23                   INC     HL              ; and digit characters
 4770 0FEA 23                   INC     HL              ; of line number.
 4771 0FEB
 4772 0FEB 22 5B 5C             LD      ($5C5B),HL      ; update K_CUR to address start of BASIC.
 4773 0FEE E1                   POP     HL              ; restore the address of CURCHL.
 4774 0FEF CD 15 16             CALL    L1615           ; routine CHAN-FLAG sets flags for it.
 4775 0FF2
 4776 0FF2 C9                   RET                     ; RETURN to ED-LOOP.
 4777 0FF3
 4778 0FF3              ; -------------------
 4779 0FF3              ; Cursor down editing
 4780 0FF3              ; -------------------
 4781 0FF3              ;   The BASIC lines are displayed at the top of the screen and the user
 4782 0FF3              ;   wishes to move the cursor down one line in edit mode.
 4783 0FF3              ;   With INPUT LINE, this key must be used instead of entering STOP.
 4784 0FF3
 4785 0FF3              ;; ED-DOWN
 4786 0FF3 FD CB 37 6E  L0FF3:  BIT     5,(IY+$37)      ; test FLAGX  - Input Mode ?
 4787 0FF7 20 08                JR      NZ,L1001        ; skip to ED-STOP if so
 4788 0FF9
 4789 0FF9 21 49 5C             LD      HL,$5C49        ; address E_PPC - 'current line'
 4790 0FFC CD 0F 19             CALL    L190F           ; routine LN-FETCH fetches number of next
 4791 0FFF                                              ; line or same if at end of program.
 4792 0FFF 18 6D                JR      L106E           ; forward to ED-LIST to produce an
 4793 1001                                              ; automatic listing.
 4794 1001
 4795 1001              ; ---
 4796 1001
 4797 1001              ;; ED-STOP
 4798 1001 FD 36 00 10  L1001:  LD      (IY+$00),$10    ; set ERR_NR to 'STOP in INPUT' code
 4799 1005 18 1D                JR      L1024           ; forward to ED-ENTER to produce error.
 4800 1007
 4801 1007              ; -------------------
 4802 1007              ; Cursor left editing
 4803 1007              ; -------------------
 4804 1007              ; This acts on the cursor in the lower section of the screen in both
 4805 1007              ; editing and input mode.
 4806 1007
 4807 1007              ;; ED-LEFT
 4808 1007 CD 31 10     L1007:  CALL    L1031           ; routine ED-EDGE moves left if possible
 4809 100A 18 05                JR      L1011           ; forward to ED-CUR to update K-CUR
 4810 100C                                              ; and return to ED-LOOP.
 4811 100C
 4812 100C              ; --------------------
 4813 100C              ; Cursor right editing
 4814 100C              ; --------------------
 4815 100C              ; This acts on the cursor in the lower screen in both editing and input
 4816 100C              ; mode and moves it to the right.
 4817 100C
 4818 100C              ;; ED-RIGHT
 4819 100C 7E           L100C:  LD      A,(HL)          ; fetch addressed character.
 4820 100D FE 0D                CP      $0D             ; is it carriage return ?
 4821 100F C8                   RET     Z               ; return if so to ED-LOOP
 4822 1010
 4823 1010 23                   INC     HL              ; address next character
 4824 1011
 4825 1011              ;; ED-CUR
 4826 1011 22 5B 5C     L1011:  LD      ($5C5B),HL      ; update K_CUR system variable
 4827 1014 C9                   RET                     ; return to ED-LOOP
 4828 1015
 4829 1015              ; --------------
 4830 1015              ; DELETE editing
 4831 1015              ; --------------
 4832 1015              ; This acts on the lower screen and deletes the character to left of
 4833 1015              ; cursor. If control characters are present these are deleted first
 4834 1015              ; leaving the naked parameter (0-7) which appears as a '?' except in the
 4835 1015              ; case of chr$ 6 which is the comma control character. It is not mandatory
 4836 1015              ; to delete these second characters.
 4837 1015
 4838 1015              ;; ED-DELETE
 4839 1015 CD 31 10     L1015:  CALL    L1031           ; routine ED-EDGE moves cursor to left.
 4840 1018 01 01 00             LD      BC,$0001        ; of character to be deleted.
 4841 101B C3 E8 19             JP      L19E8           ; to RECLAIM-2 reclaim the character.
 4842 101E
 4843 101E              ; ------------------------------------------
 4844 101E              ; Ignore next 2 codes from key-input routine
 4845 101E              ; ------------------------------------------
 4846 101E              ; Since AT and TAB cannot be entered this point is never reached
 4847 101E              ; from the keyboard. If inputting from a tape device or network then
 4848 101E              ; the control and two following characters are ignored and processing
 4849 101E              ; continues as if a carriage return had been received.
 4850 101E              ; Here, perhaps, another Spectrum has said print #15; AT 0,0; "This is yellow"
 4851 101E              ; and this one is interpreting input #15; a$.
 4852 101E
 4853 101E              ;; ED-IGNORE
 4854 101E CD D4 15     L101E:  CALL    L15D4           ; routine WAIT-KEY to ignore keystroke.
 4855 1021 CD D4 15             CALL    L15D4           ; routine WAIT-KEY to ignore next key.
 4856 1024
 4857 1024              ; -------------
 4858 1024              ; Enter/newline
 4859 1024              ; -------------
 4860 1024              ; The enter key has been pressed to have BASIC line or input accepted.
 4861 1024
 4862 1024              ;; ED-ENTER
 4863 1024 E1           L1024:  POP     HL              ; discard address ED-LOOP
 4864 1025 E1                   POP     HL              ; drop address ED-ERROR
 4865 1026
 4866 1026              ;; ED-END
 4867 1026 E1           L1026:  POP     HL              ; the previous value of ERR_SP
 4868 1027 22 3D 5C             LD      ($5C3D),HL      ; is restored to ERR_SP system variable
 4869 102A FD CB 00 7E          BIT     7,(IY+$00)      ; is ERR_NR $FF (= 'OK') ?
 4870 102E C0                   RET     NZ              ; return if so
 4871 102F
 4872 102F F9                   LD      SP,HL           ; else put error routine on stack
 4873 1030 C9                   RET                     ; and make an indirect jump to it.
 4874 1031
 4875 1031              ; -----------------------------
 4876 1031              ; Move cursor left when editing
 4877 1031              ; -----------------------------
 4878 1031              ; This routine moves the cursor left. The complication is that it must
 4879 1031              ; not position the cursor between control codes and their parameters.
 4880 1031              ; It is further complicated in that it deals with TAB and AT characters
 4881 1031              ; which are never present from the keyboard.
 4882 1031              ; The method is to advance from the beginning of the line each time,
 4883 1031              ; jumping one, two, or three characters as necessary saving the original
 4884 1031              ; position at each jump in DE. Once it arrives at the cursor then the next
 4885 1031              ; legitimate leftmost position is in DE.
 4886 1031
 4887 1031              ;; ED-EDGE
 4888 1031 37           L1031:  SCF                     ; carry flag must be set to call the nested
 4889 1032 CD 95 11             CALL    L1195           ; subroutine SET-DE.
 4890 1035                                              ; if input   then DE=WORKSP
 4891 1035                                              ; if editing then DE=E_LINE
 4892 1035 ED 52                SBC     HL,DE           ; subtract address from start of line
 4893 1037 19                   ADD     HL,DE           ; and add back.
 4894 1038 23                   INC     HL              ; adjust for carry.
 4895 1039 C1                   POP     BC              ; drop return address
 4896 103A D8                   RET     C               ; return to ED-LOOP if already at left
 4897 103B                                              ; of line.
 4898 103B
 4899 103B C5                   PUSH    BC              ; resave return address - ED-LOOP.
 4900 103C 44                   LD      B,H             ; transfer HL - cursor address
 4901 103D 4D                   LD      C,L             ; to BC register pair.
 4902 103E                                              ; at this point DE addresses start of line.
 4903 103E
 4904 103E              ;; ED-EDGE-1
 4905 103E 62           L103E:  LD      H,D             ; transfer DE - leftmost pointer
 4906 103F 6B                   LD      L,E             ; to HL
 4907 1040 23                   INC     HL              ; address next leftmost character to
 4908 1041                                              ; advance position each time.
 4909 1041 1A                   LD      A,(DE)          ; pick up previous in A
 4910 1042 E6 F0                AND     $F0             ; lose the low bits
 4911 1044 FE 10                CP      $10             ; is it INK to TAB $10-$1F ?
 4912 1046                                              ; that is, is it followed by a parameter ?
 4913 1046 20 09                JR      NZ,L1051        ; to ED-EDGE-2 if not
 4914 1048                                              ; HL has been incremented once
 4915 1048
 4916 1048 23                   INC     HL              ; address next as at least one parameter.
 4917 1049
 4918 1049              ; in fact since 'tab' and 'at' cannot be entered the next section seems
 4919 1049              ; superfluous.
 4920 1049              ; The test will always fail and the jump to ED-EDGE-2 will be taken.
 4921 1049
 4922 1049 1A                   LD      A,(DE)          ; reload leftmost character
 4923 104A D6 17                SUB     $17             ; decimal 23 ('tab')
 4924 104C CE 00                ADC     A,$00           ; will be 0 for 'tab' and 'at'.
 4925 104E 20 01                JR      NZ,L1051        ; forward to ED-EDGE-2 if not
 4926 1050                                              ; HL has been incremented twice
 4927 1050
 4928 1050 23                   INC     HL              ; increment a third time for 'at'/'tab'
 4929 1051
 4930 1051              ;; ED-EDGE-2
 4931 1051 A7           L1051:  AND     A               ; prepare for true subtraction
 4932 1052 ED 42                SBC     HL,BC           ; subtract cursor address from pointer
 4933 1054 09                   ADD     HL,BC           ; and add back
 4934 1055                                              ; Note when HL matches the cursor position BC,
 4935 1055                                              ; there is no carry and the previous
 4936 1055                                              ; position is in DE.
 4937 1055 EB                   EX      DE,HL           ; transfer result to DE if looping again.
 4938 1056                                              ; transfer DE to HL to be used as K-CUR
 4939 1056                                              ; if exiting loop.
 4940 1056 38 E6                JR      C,L103E         ; back to ED-EDGE-1 if cursor not matched.
 4941 1058
 4942 1058 C9                   RET                     ; return.
 4943 1059
 4944 1059              ; -----------------
 4945 1059              ; Cursor up editing
 4946 1059              ; -----------------
 4947 1059              ; The main screen displays part of the BASIC program and the user wishes
 4948 1059              ; to move up one line scrolling if necessary.
 4949 1059              ; This has no alternative use in input mode.
 4950 1059
 4951 1059              ;; ED-UP
 4952 1059 FD CB 37 6E  L1059:  BIT     5,(IY+$37)      ; test FLAGX  - input mode ?
 4953 105D C0                   RET     NZ              ; return if not in editor - to ED-LOOP.
 4954 105E
 4955 105E 2A 49 5C             LD      HL,($5C49)      ; get current line from E_PPC
 4956 1061 CD 6E 19             CALL    L196E           ; routine LINE-ADDR gets address
 4957 1064 EB                   EX      DE,HL           ; and previous in DE
 4958 1065 CD 95 16             CALL    L1695           ; routine LINE-NO gets prev line number
 4959 1068 21 4A 5C             LD      HL,$5C4A        ; set HL to E_PPC_hi as next routine stores
 4960 106B                                              ; top first.
 4961 106B CD 1C 19             CALL    L191C           ; routine LN-STORE loads DE value to HL
 4962 106E                                              ; high byte first - E_PPC_lo takes E
 4963 106E
 4964 106E              ; this branch is also taken from ed-down.
 4965 106E
 4966 106E              ;; ED-LIST
 4967 106E CD 95 17     L106E:  CALL    L1795           ; routine AUTO-LIST lists to upper screen
 4968 1071                                              ; including adjusted current line.
 4969 1071 3E 00                LD      A,$00           ; select lower screen again
 4970 1073 C3 01 16             JP      L1601           ; exit via CHAN-OPEN to ED-LOOP
 4971 1076
 4972 1076              ; --------------------------------
 4973 1076              ; Use of symbol and graphics codes
 4974 1076              ; --------------------------------
 4975 1076              ; These will not be encountered with the keyboard but would be handled
 4976 1076              ; otherwise as follows.
 4977 1076              ; As noted earlier, Vickers says there should have been an entry in
 4978 1076              ; the KEYS table for chr$ 6 which also pointed here.
 4979 1076              ; If, for simplicity, two Spectrums were both using #15 as a bi-directional
 4980 1076              ; channel connected to each other:-
 4981 1076              ; then when the other Spectrum has said PRINT #15; x, y
 4982 1076              ; input #15; i ; j  would treat the comma control as a newline and the
 4983 1076              ; control would skip to input j.
 4984 1076              ; You can get round the missing chr$ 6 handler by sending multiple print
 4985 1076              ; items separated by a newline '.
 4986 1076
 4987 1076              ; chr$14 would have the same functionality.
 4988 1076
 4989 1076              ; This is chr$ 14.
 4990 1076              ;; ED-SYMBOL
 4991 1076 FD CB 37 7E  L1076:  BIT     7,(IY+$37)      ; test FLAGX - is this INPUT LINE ?
 4992 107A 28 A8                JR      Z,L1024         ; back to ED-ENTER if not to treat as if
 4993 107C                                              ; enter had been pressed.
 4994 107C                                              ; else continue and add code to buffer.
 4995 107C
 4996 107C              ; Next is chr$ 15
 4997 107C              ; Note that ADD-CHAR precedes the table so we can't offset to it directly.
 4998 107C
 4999 107C              ;; ED-GRAPH
 5000 107C C3 81 0F     L107C:  JP      L0F81           ; jump back to ADD-CHAR
 5001 107F
 5002 107F              ; --------------------
 5003 107F              ; Editor error routine
 5004 107F              ; --------------------
 5005 107F              ; If an error occurs while editing, or inputting, then ERR_SP
 5006 107F              ; points to the stack location holding address ED_ERROR.
 5007 107F
 5008 107F              ;; ED-ERROR
 5009 107F FD CB 30 66  L107F:  BIT     4,(IY+$30)      ; test FLAGS2  - is K channel in use ?
 5010 1083 28 A1                JR      Z,L1026         ; back to ED-END if not.
 5011 1085
 5012 1085              ; but as long as we're editing lines or inputting from the keyboard, then
 5013 1085              ; we've run out of memory so give a short rasp.
 5014 1085
 5015 1085 FD 36 00 FF          LD      (IY+$00),$FF    ; reset ERR_NR to 'OK'.
 5016 1089 16 00                LD      D,$00           ; prepare for beeper.
 5017 108B FD 5E FE             LD      E,(IY-$02)      ; use RASP value.
 5018 108E 21 90 1A             LD      HL,$1A90        ; set the pitch - or tone period.
 5019 1091 CD B5 03             CALL    L03B5           ; routine BEEPER emits a warning rasp.
 5020 1094 C3 30 0F             JP      L0F30           ; to ED-AGAIN to re-stack address of
 5021 1097                                              ; this routine and make ERR_SP point to it.
 5022 1097
 5023 1097              ; ---------------------
 5024 1097              ; Clear edit/work space
 5025 1097              ; ---------------------
 5026 1097              ; The editing area or workspace is cleared depending on context.
 5027 1097              ; This is called from ED-EDIT to clear workspace if edit key is
 5028 1097              ; used during input, to clear editing area if no program exists
 5029 1097              ; and to clear editing area prior to copying the edit line to it.
 5030 1097              ; It is also used by the error routine to clear the respective
 5031 1097              ; area depending on FLAGX.
 5032 1097
 5033 1097              ;; CLEAR-SP
 5034 1097 E5           L1097:  PUSH    HL              ; preserve HL
 5035 1098 CD 90 11             CALL    L1190           ; routine SET-HL
 5036 109B                                              ; if in edit   HL = WORKSP-1, DE = E_LINE
 5037 109B                                              ; if in input  HL = STKBOT,   DE = WORKSP
 5038 109B 2B                   DEC     HL              ; adjust
 5039 109C CD E5 19             CALL    L19E5           ; routine RECLAIM-1 reclaims space
 5040 109F 22 5B 5C             LD      ($5C5B),HL      ; set K_CUR to start of empty area
 5041 10A2 FD 36 07 00          LD      (IY+$07),$00    ; set MODE to 'KLC'
 5042 10A6 E1                   POP     HL              ; restore HL.
 5043 10A7 C9                   RET                     ; return.
 5044 10A8
 5045 10A8              ; ----------------------------
 5046 10A8              ; THE 'KEYBOARD INPUT' ROUTINE
 5047 10A8              ; ----------------------------
 5048 10A8              ; This is the service routine for the input stream of the keyboard channel 'K'.
 5049 10A8
 5050 10A8              ;; KEY-INPUT
 5051 10A8 FD CB 02 5E  L10A8:  BIT     3,(IY+$02)      ; test TV_FLAG  - has a key been pressed in
 5052 10AC                                              ; editor ?
 5053 10AC
 5054 10AC C4 1D 11             CALL    NZ,L111D        ; routine ED-COPY, if so, to reprint the lower
 5055 10AF                                              ; screen at every keystroke/mode change.
 5056 10AF
 5057 10AF A7                   AND     A               ; clear carry flag - required exit condition.
 5058 10B0
 5059 10B0 FD CB 01 6E          BIT     5,(IY+$01)      ; test FLAGS  - has a new key been pressed ?
 5060 10B4 C8                   RET     Z               ; return if not.                        >>
 5061 10B5
 5062 10B5 3A 08 5C             LD      A,($5C08)       ; system variable LASTK will hold last key -
 5063 10B8                                              ; from the interrupt routine.
 5064 10B8
 5065 10B8 FD CB 01 AE          RES     5,(IY+$01)      ; update FLAGS  - reset the new key flag.
 5066 10BC F5                   PUSH    AF              ; save the input character.
 5067 10BD
 5068 10BD FD CB 02 6E          BIT     5,(IY+$02)      ; test TV_FLAG  - clear lower screen ?
 5069 10C1
 5070 10C1 C4 6E 0D             CALL    NZ,L0D6E        ; routine CLS-LOWER if so.
 5071 10C4
 5072 10C4 F1                   POP     AF              ; restore the character code.
 5073 10C5
 5074 10C5 FE 20                CP      $20             ; if space or higher then
 5075 10C7 30 52                JR      NC,L111B        ; forward to KEY-DONE2 and return with carry
 5076 10C9                                              ; set to signal key-found.
 5077 10C9
 5078 10C9 FE 10                CP      $10             ; with 16d INK and higher skip
 5079 10CB 30 2D                JR      NC,L10FA        ; forward to KEY-CONTR.
 5080 10CD
 5081 10CD FE 06                CP      $06             ; for 6 - 15d
 5082 10CF 30 0A                JR      NC,L10DB        ; skip forward to KEY-M-CL to handle Modes
 5083 10D1                                              ; and CapsLock.
 5084 10D1
 5085 10D1              ; that only leaves 0-5, the flash bright inverse switches.
 5086 10D1
 5087 10D1 47                   LD      B,A             ; save character in B
 5088 10D2 E6 01                AND     $01             ; isolate the embedded parameter (0/1).
 5089 10D4 4F                   LD      C,A             ; and store in C
 5090 10D5 78                   LD      A,B             ; re-fetch copy (0-5)
 5091 10D6 1F                   RRA                     ; halve it 0, 1 or 2.
 5092 10D7 C6 12                ADD     A,$12           ; add 18d gives 'flash', 'bright'
 5093 10D9                                              ; and 'inverse'.
 5094 10D9 18 2A                JR      L1105           ; forward to KEY-DATA with the
 5095 10DB                                              ; parameter (0/1) in C.
 5096 10DB
 5097 10DB              ; ---
 5098 10DB
 5099 10DB              ; Now separate capslock 06 from modes 7-15.
 5100 10DB
 5101 10DB              ;; KEY-M-CL
 5102 10DB 20 09        L10DB:  JR      NZ,L10E6        ; forward to KEY-MODE if not 06 (capslock)
 5103 10DD
 5104 10DD 21 6A 5C             LD      HL,$5C6A        ; point to FLAGS2
 5105 10E0 3E 08                LD      A,$08           ; value 00001000
 5106 10E2 AE                   XOR     (HL)            ; toggle BIT 3 of FLAGS2 the capslock bit
 5107 10E3 77                   LD      (HL),A          ; and store result in FLAGS2 again.
 5108 10E4 18 0E                JR      L10F4           ; forward to KEY-FLAG to signal no-key.
 5109 10E6
 5110 10E6              ; ---
 5111 10E6
 5112 10E6              ;; KEY-MODE
 5113 10E6 FE 0E        L10E6:  CP      $0E             ; compare with chr 14d
 5114 10E8 D8                   RET     C               ; return with carry set "key found" for
 5115 10E9                                              ; codes 7 - 13d leaving 14d and 15d
 5116 10E9                                              ; which are converted to mode codes.
 5117 10E9
 5118 10E9 D6 0D                SUB     $0D             ; subtract 13d leaving 1 and 2
 5119 10EB                                              ; 1 is 'E' mode, 2 is 'G' mode.
 5120 10EB 21 41 5C             LD      HL,$5C41        ; address the MODE system variable.
 5121 10EE BE                   CP      (HL)            ; compare with existing value before
 5122 10EF 77                   LD      (HL),A          ; inserting the new value.
 5123 10F0 20 02                JR      NZ,L10F4        ; forward to KEY-FLAG if it has changed.
 5124 10F2
 5125 10F2 36 00                LD      (HL),$00        ; else make MODE zero - KLC mode
 5126 10F4                                              ; Note. while in Extended/Graphics mode,
 5127 10F4                                              ; the Extended Mode/Graphics key is pressed
 5128 10F4                                              ; again to get out.
 5129 10F4
 5130 10F4              ;; KEY-FLAG
 5131 10F4 FD CB 02 DE  L10F4:  SET     3,(IY+$02)      ; update TV_FLAG  - show key state has changed
 5132 10F8 BF                   CP      A               ; clear carry and reset zero flags -
 5133 10F9                                              ; no actual key returned.
 5134 10F9 C9                   RET                     ; make the return.
 5135 10FA
 5136 10FA              ; ---
 5137 10FA
 5138 10FA              ; now deal with colour controls - 16-23 ink, 24-31 paper
 5139 10FA
 5140 10FA              ;; KEY-CONTR
 5141 10FA 47           L10FA:  LD      B,A             ; make a copy of character.
 5142 10FB E6 07                AND     $07             ; mask to leave bits 0-7
 5143 10FD 4F                   LD      C,A             ; and store in C.
 5144 10FE 3E 10                LD      A,$10           ; initialize to 16d - INK.
 5145 1100 CB 58                BIT     3,B             ; was it paper ?
 5146 1102 20 01                JR      NZ,L1105        ; forward to KEY-DATA with INK 16d and
 5147 1104                                              ; colour in C.
 5148 1104
 5149 1104 3C                   INC     A               ; else change from INK to PAPER (17d) if so.
 5150 1105
 5151 1105              ;; KEY-DATA
 5152 1105 FD 71 D3     L1105:  LD      (IY-$2D),C      ; put the colour (0-7)/state(0/1) in KDATA
 5153 1108 11 0D 11             LD      DE,L110D        ; address: KEY-NEXT will be next input stream
 5154 110B 18 06                JR      L1113           ; forward to KEY-CHAN to change it ...
 5155 110D
 5156 110D              ; ---
 5157 110D
 5158 110D              ; ... so that INPUT_AD directs control to here at next call to WAIT-KEY
 5159 110D
 5160 110D              ;; KEY-NEXT
 5161 110D 3A 0D 5C     L110D:  LD      A,($5C0D)       ; pick up the parameter stored in KDATA.
 5162 1110 11 A8 10             LD      DE,L10A8        ; address: KEY-INPUT will be next input stream
 5163 1113                                              ; continue to restore default channel and
 5164 1113                                              ; make a return with the control code.
 5165 1113
 5166 1113              ;; KEY-CHAN
 5167 1113 2A 4F 5C     L1113:  LD      HL,($5C4F)      ; address start of CHANNELS area using CHANS
 5168 1116                                              ; system variable.
 5169 1116                                              ; Note. One might have expected CURCHL to
 5170 1116                                              ; have been used.
 5171 1116 23                   INC     HL              ; step over the
 5172 1117 23                   INC     HL              ; output address
 5173 1118 73                   LD      (HL),E          ; and update the input
 5174 1119 23                   INC     HL              ; routine address for
 5175 111A 72                   LD      (HL),D          ; the next call to WAIT-KEY.
 5176 111B
 5177 111B              ;; KEY-DONE2
 5178 111B 37           L111B:  SCF                     ; set carry flag to show a key has been found
 5179 111C C9                   RET                     ; and return.
 5180 111D
 5181 111D              ; --------------------
 5182 111D              ; Lower screen copying
 5183 111D              ; --------------------
 5184 111D              ; This subroutine is called whenever the line in the editing area or
 5185 111D              ; input workspace is required to be printed to the lower screen.
 5186 111D              ; It is by calling this routine after any change that the cursor, for
 5187 111D              ; instance, appears to move to the left.
 5188 111D              ; Remember the edit line will contain characters and tokens
 5189 111D              ; e.g. "1000 LET a=1" is 8 characters.
 5190 111D
 5191 111D              ;; ED-COPY
 5192 111D CD 4D 0D     L111D:  CALL    L0D4D           ; routine TEMPS sets temporary attributes.
 5193 1120 FD CB 02 9E          RES     3,(IY+$02)      ; update TV_FLAG  - signal no change in mode
 5194 1124 FD CB 02 AE          RES     5,(IY+$02)      ; update TV_FLAG  - signal don't clear lower
 5195 1128                                              ; screen.
 5196 1128 2A 8A 5C             LD      HL,($5C8A)      ; fetch SPOSNL
 5197 112B E5                   PUSH    HL              ; and save on stack.
 5198 112C
 5199 112C 2A 3D 5C             LD      HL,($5C3D)      ; fetch ERR_SP
 5200 112F E5                   PUSH    HL              ; and save also
 5201 1130 21 67 11             LD      HL,L1167        ; address: ED-FULL
 5202 1133 E5                   PUSH    HL              ; is pushed as the error routine
 5203 1134 ED 73 3D 5C          LD      ($5C3D),SP      ; and ERR_SP made to point to it.
 5204 1138
 5205 1138 2A 82 5C             LD      HL,($5C82)      ; fetch ECHO_E
 5206 113B E5                   PUSH    HL              ; and push also
 5207 113C
 5208 113C 37                   SCF                     ; set carry flag to control SET-DE
 5209 113D CD 95 11             CALL    L1195           ; call routine SET-DE
 5210 1140                                              ; if in input DE = WORKSP
 5211 1140                                              ; if in edit  DE = E_LINE
 5212 1140 EB                   EX      DE,HL           ; start address to HL
 5213 1141
 5214 1141 CD 7D 18             CALL    L187D           ; routine OUT-LINE2 outputs entire line up to
 5215 1144                                              ; carriage return including initial
 5216 1144                                              ; characterized line number when present.
 5217 1144 EB                   EX      DE,HL           ; transfer new address to DE
 5218 1145 CD E1 18             CALL    L18E1           ; routine OUT-CURS considers a
 5219 1148                                              ; terminating cursor.
 5220 1148
 5221 1148 2A 8A 5C             LD      HL,($5C8A)      ; fetch updated SPOSNL
 5222 114B E3                   EX      (SP),HL         ; exchange with ECHO_E on stack
 5223 114C EB                   EX      DE,HL           ; transfer ECHO_E to DE
 5224 114D CD 4D 0D             CALL    L0D4D           ; routine TEMPS to re-set attributes
 5225 1150                                              ; if altered.
 5226 1150
 5227 1150              ; the lower screen was not cleared, at the outset, so if deleting then old
 5228 1150              ; text from a previous print may follow this line and requires blanking.
 5229 1150
 5230 1150              ;; ED-BLANK
 5231 1150 3A 8B 5C     L1150:  LD      A,($5C8B)       ; fetch SPOSNL_hi is current line
 5232 1153 92                   SUB     D               ; compare with old
 5233 1154 38 26                JR      C,L117C         ; forward to ED-C-DONE if no blanking
 5234 1156
 5235 1156 20 06                JR      NZ,L115E        ; forward to ED-SPACES if line has changed
 5236 1158
 5237 1158 7B                   LD      A,E             ; old column to A
 5238 1159 FD 96 50             SUB     (IY+$50)        ; subtract new in SPOSNL_lo
 5239 115C 30 1E                JR      NC,L117C        ; forward to ED-C-DONE if no backfilling.
 5240 115E
 5241 115E              ;; ED-SPACES
 5242 115E 3E 20        L115E:  LD      A,$20           ; prepare a space.
 5243 1160 D5                   PUSH    DE              ; save old line/column.
 5244 1161 CD F4 09             CALL    L09F4           ; routine PRINT-OUT prints a space over
 5245 1164                                              ; any text from previous print.
 5246 1164                                              ; Note. Since the blanking only occurs when
 5247 1164                                              ; using $09F4 to print to the lower screen,
 5248 1164                                              ; there is no need to vector via a RST 10
 5249 1164                                              ; and we can use this alternate set.
 5250 1164 D1                   POP     DE              ; restore the old line column.
 5251 1165 18 E9                JR      L1150           ; back to ED-BLANK until all old text blanked.
 5252 1167
 5253 1167              ; -------------------------------
 5254 1167              ; THE 'EDITOR-FULL' ERROR ROUTINE
 5255 1167              ; -------------------------------
 5256 1167              ;   This is the error routine addressed by ERR_SP.  This is not for the out of
 5257 1167              ;   memory situation as we're just printing.  The pitch and duration are exactly
 5258 1167              ;   the same as used by ED-ERROR from which this has been augmented.  The
 5259 1167              ;   situation is that the lower screen is full and a rasp is given to suggest
 5260 1167              ;   that this is perhaps not the best idea you've had that day.
 5261 1167
 5262 1167              ;; ED-FULL
 5263 1167 16 00        L1167:  LD      D,$00           ; prepare to moan.
 5264 1169 FD 5E FE             LD      E,(IY-$02)      ; fetch RASP value.
 5265 116C 21 90 1A             LD      HL,$1A90        ; set pitch or tone period.
 5266 116F
 5267 116F CD B5 03             CALL    L03B5           ; routine BEEPER.
 5268 1172
 5269 1172 FD 36 00 FF          LD      (IY+$00),$FF    ; clear ERR_NR.
 5270 1176 ED 5B 8A 5C          LD      DE,($5C8A)      ; fetch SPOSNL.
 5271 117A 18 02                JR      L117E           ; forward to ED-C-END
 5272 117C
 5273 117C              ; -------
 5274 117C
 5275 117C              ; the exit point from line printing continues here.
 5276 117C
 5277 117C              ;; ED-C-DONE
 5278 117C D1           L117C:  POP     DE              ; fetch new line/column.
 5279 117D E1                   POP     HL              ; fetch the error address.
 5280 117E
 5281 117E              ; the error path rejoins here.
 5282 117E
 5283 117E              ;; ED-C-END
 5284 117E E1           L117E:  POP     HL              ; restore the old value of ERR_SP.
 5285 117F 22 3D 5C             LD      ($5C3D),HL      ; update the system variable ERR_SP
 5286 1182
 5287 1182 C1                   POP     BC              ; old value of SPOSN_L
 5288 1183 D5                   PUSH    DE              ; save new value
 5289 1184
 5290 1184 CD D9 0D             CALL    L0DD9           ; routine CL-SET and PO-STORE
 5291 1187                                              ; update ECHO_E and SPOSN_L from BC
 5292 1187
 5293 1187 E1                   POP     HL              ; restore new value
 5294 1188 22 82 5C             LD      ($5C82),HL      ; and overwrite ECHO_E
 5295 118B
 5296 118B FD 36 26 00          LD      (IY+$26),$00    ; make error pointer X_PTR_hi out of bounds
 5297 118F
 5298 118F C9                   RET                     ; return
 5299 1190
 5300 1190              ; -----------------------------------------------
 5301 1190              ; Point to first and last locations of work space
 5302 1190              ; -----------------------------------------------
 5303 1190              ;   These two nested routines ensure that the appropriate pointers are
 5304 1190              ;   selected for the editing area or workspace. The routines that call
 5305 1190              ;   these routines are designed to work on either area.
 5306 1190
 5307 1190              ; this routine is called once
 5308 1190
 5309 1190              ;; SET-HL
 5310 1190 2A 61 5C     L1190:  LD      HL,($5C61)      ; fetch WORKSP to HL.
 5311 1193 2B                   DEC     HL              ; point to last location of editing area.
 5312 1194 A7                   AND     A               ; clear carry to limit exit points to first
 5313 1195                                              ; or last.
 5314 1195
 5315 1195              ; this routine is called with carry set and exits at a conditional return.
 5316 1195
 5317 1195              ;; SET-DE
 5318 1195 ED 5B 59 5C  L1195:  LD      DE,($5C59)      ; fetch E_LINE to DE
 5319 1199 FD CB 37 6E          BIT     5,(IY+$37)      ; test FLAGX  - Input Mode ?
 5320 119D C8                   RET     Z               ; return now if in editing mode
 5321 119E
 5322 119E ED 5B 61 5C          LD      DE,($5C61)      ; fetch WORKSP to DE
 5323 11A2 D8                   RET     C               ; return if carry set ( entry = set-de)
 5324 11A3
 5325 11A3 2A 63 5C             LD      HL,($5C63)      ; fetch STKBOT to HL as well
 5326 11A6 C9                   RET                     ; and return  (entry = set-hl (in input))
 5327 11A7
 5328 11A7              ; -----------------------------------
 5329 11A7              ; THE 'REMOVE FLOATING POINT' ROUTINE
 5330 11A7              ; -----------------------------------
 5331 11A7              ;   When a BASIC LINE or the INPUT BUFFER is parsed any numbers will have
 5332 11A7              ;   an invisible chr 14d inserted after them and the 5-byte integer or
 5333 11A7              ;   floating point form inserted after that.  Similar invisible value holders
 5334 11A7              ;   are also created after the numeric and string variables in a DEF FN list.
 5335 11A7              ;   This routine removes these 'compiled' numbers from the edit line or
 5336 11A7              ;   input workspace.
 5337 11A7
 5338 11A7              ;; REMOVE-FP
 5339 11A7 7E           L11A7:  LD      A,(HL)          ; fetch character
 5340 11A8 FE 0E                CP      $0E             ; is it the CHR$ 14 number marker ?
 5341 11AA 01 06 00             LD      BC,$0006        ; prepare to strip six bytes
 5342 11AD
 5343 11AD CC E8 19             CALL    Z,L19E8         ; routine RECLAIM-2 reclaims bytes if CHR$ 14.
 5344 11B0
 5345 11B0 7E                   LD      A,(HL)          ; reload next (or same) character
 5346 11B1 23                   INC     HL              ; and advance address
 5347 11B2 FE 0D                CP      $0D             ; end of line or input buffer ?
 5348 11B4 20 F1                JR      NZ,L11A7        ; back to REMOVE-FP until entire line done.
 5349 11B6
 5350 11B6 C9                   RET                     ; return.
 5351 11B7
 5352 11B7
 5353 11B7              ; *********************************
 5354 11B7              ; ** Part 6. EXECUTIVE ROUTINES  **
 5355 11B7              ; *********************************
 5356 11B7
 5357 11B7
 5358 11B7              ; The memory.
 5359 11B7              ;
 5360 11B7              ; +---------+-----------+------------+--------------+-------------+--
 5361 11B7              ; | BASIC   |  Display  | Attributes | ZX Printer   |    System   |
 5362 11B7              ; |  ROM    |   File    |    File    |   Buffer     |  Variables  |
 5363 11B7              ; +---------+-----------+------------+--------------+-------------+--
 5364 11B7              ; ^         ^           ^            ^              ^             ^
 5365 11B7              ; $0000   $4000       $5800        $5B00          $5C00         $5CB6 = CHANS
 5366 11B7              ;
 5367 11B7              ;
 5368 11B7              ;  --+----------+---+---------+-----------+---+------------+--+---+--
 5369 11B7              ;    | Channel  |$80|  BASIC  | Variables |$80| Edit Line  |NL|$80|
 5370 11B7              ;    |   Info   |   | Program |   Area    |   | or Command |  |   |
 5371 11B7              ;  --+----------+---+---------+-----------+---+------------+--+---+--
 5372 11B7              ;    ^              ^         ^               ^                   ^
 5373 11B7              ;  CHANS           PROG      VARS           E_LINE              WORKSP
 5374 11B7              ;
 5375 11B7              ;
 5376 11B7              ;                             ---5-->         <---2---  <--3---
 5377 11B7              ;  --+-------+--+------------+-------+-------+---------+-------+-+---+------+
 5378 11B7              ;    | INPUT |NL| Temporary  | Calc. | Spare | Machine | GOSUB |?|$3E| UDGs |
 5379 11B7              ;    | data  |  | Work Space | Stack |       |  Stack  | Stack | |   |      |
 5380 11B7              ;  --+-------+--+------------+-------+-------+---------+-------+-+---+------+
 5381 11B7              ;    ^                       ^       ^       ^                   ^   ^      ^
 5382 11B7              ;  WORKSP                  STKBOT  STKEND   sp               RAMTOP UDG  P_RAMT
 5383 11B7              ;
 5384 11B7
 5385 11B7              ; -----------------
 5386 11B7              ; THE 'NEW' COMMAND
 5387 11B7              ; -----------------
 5388 11B7              ;   The NEW command is about to set all RAM below RAMTOP to zero and then
 5389 11B7              ;   re-initialize the system.  All RAM above RAMTOP should, and will be,
 5390 11B7              ;   preserved.
 5391 11B7              ;   There is nowhere to store values in RAM or on the stack which becomes
 5392 11B7              ;   inoperable. Similarly PUSH and CALL instructions cannot be used to store
 5393 11B7              ;   values or section common code. The alternate register set is the only place
 5394 11B7              ;   available to store 3 persistent 16-bit system variables.
 5395 11B7
 5396 11B7              ;; NEW
 5397 11B7 F3           L11B7:  DI                      ; Disable Interrupts - machine stack will be
 5398 11B8                                              ; cleared.
 5399 11B8 3E FF                LD      A,$FF           ; Flag coming from NEW.
 5400 11BA ED 5B B2 5C          LD      DE,($5CB2)      ; Fetch RAMTOP as top value.
 5401 11BE D9                   EXX                     ; Switch in alternate set.
 5402 11BF ED 4B B4 5C          LD      BC,($5CB4)      ; Fetch P-RAMT differs on 16K/48K machines.
 5403 11C3 ED 5B 38 5C          LD      DE,($5C38)      ; Fetch RASP/PIP.
 5404 11C7 2A 7B 5C             LD      HL,($5C7B)      ; Fetch UDG    differs on 16K/48K machines.
 5405 11CA D9                   EXX                     ; Switch back to main set and continue into...
 5406 11CB
 5407 11CB              ; ----------------------
 5408 11CB              ; THE 'START-NEW' BRANCH
 5409 11CB              ; ----------------------
 5410 11CB              ;   This branch is taken from above and from RST 00h.
 5411 11CB              ;   The common code tests RAM and sets it to zero re-initializing all the
 5412 11CB              ;   non-zero system variables and channel information.  The A register flags
 5413 11CB              ;   if coming from START or NEW.
 5414 11CB
 5415 11CB              ;; START-NEW
 5416 11CB 47           L11CB:  LD      B,A             ; Save the flag to control later branching.
 5417 11CC
 5418 11CC 3E 07                LD      A,$07           ; Select a white border
 5419 11CE D3 FE                OUT     ($FE),A         ; and set it now by writing to a port.
 5420 11D0
 5421 11D0 3E 3F                LD      A,$3F           ; Load the accumulator with last page in ROM.
 5422 11D2 ED 47                LD      I,A             ; Set the I register - this remains constant
 5423 11D4                                              ; and can't be in the range $40 - $7F as 'snow'
 5424 11D4                                              ; appears on the screen.
 5425 11D4
 5426 11D4 00                   NOP                     ; These seem unnecessary.
 5427 11D5 00                   NOP                     ;
 5428 11D6 00                   NOP                     ;
 5429 11D7 00                   NOP                     ;
 5430 11D8 00                   NOP                     ;
 5431 11D9 00                   NOP                     ;
 5432 11DA
 5433 11DA              ; -----------------------
 5434 11DA              ; THE 'RAM CHECK' SECTION
 5435 11DA              ; -----------------------
 5436 11DA              ;   Typically, a Spectrum will have 16K or 48K of RAM and this code will test
 5437 11DA              ;   it all till it finds an unpopulated location or, less likely, a faulty
 5438 11DA              ;   location.  Usually it stops when it reaches the top $FFFF, or in the case
 5439 11DA              ;   of NEW the supplied top value.  The entire screen turns black with
 5440 11DA              ;   sometimes red stripes on black paper just visible.
 5441 11DA
 5442 11DA              ;; ram-check
 5443 11DA 62           L11DA:  LD      H,D             ; Transfer the top value to the HL register
 5444 11DB 6B                   LD      L,E             ; pair.
 5445 11DC
 5446 11DC              ;; RAM-FILL
 5447 11DC 36 02        L11DC:  LD      (HL),$02        ; Load memory with $02 - red ink on black paper.
 5448 11DE 2B                   DEC     HL              ; Decrement memory address.
 5449 11DF BC                   CP      H               ; Have we reached ROM - $3F ?
 5450 11E0 20 FA                JR      NZ,L11DC        ; Back to RAM-FILL if not.
 5451 11E2
 5452 11E2              ;; RAM-READ
 5453 11E2 A7           L11E2:  AND     A               ; Clear carry - prepare to subtract.
 5454 11E3 ED 52                SBC     HL,DE           ; subtract and add back setting
 5455 11E5 19                   ADD     HL,DE           ; carry when back at start.
 5456 11E6 23                   INC     HL              ; and increment for next iteration.
 5457 11E7 30 06                JR      NC,L11EF        ; forward to RAM-DONE if we've got back to
 5458 11E9                                              ; starting point with no errors.
 5459 11E9
 5460 11E9 35                   DEC     (HL)            ; decrement to 1.
 5461 11EA 28 03                JR      Z,L11EF         ; forward to RAM-DONE if faulty.
 5462 11EC
 5463 11EC 35                   DEC     (HL)            ; decrement to zero.
 5464 11ED 28 F3                JR      Z,L11E2         ; back to RAM-READ if zero flag was set.
 5465 11EF
 5466 11EF              ;; RAM-DONE
 5467 11EF 2B           L11EF:  DEC     HL              ; step back to last valid location.
 5468 11F0 D9                   EXX                     ; regardless of state, set up possibly
 5469 11F1                                              ; stored system variables in case from NEW.
 5470 11F1 ED 43 B4 5C          LD      ($5CB4),BC      ; insert P-RAMT.
 5471 11F5 ED 53 38 5C          LD      ($5C38),DE      ; insert RASP/PIP.
 5472 11F9 22 7B 5C             LD      ($5C7B),HL      ; insert UDG.
 5473 11FC D9                   EXX                     ; switch in main set.
 5474 11FD 04                   INC     B               ; now test if we arrived here from NEW.
 5475 11FE 28 19                JR      Z,L1219         ; forward to RAM-SET if we did.
 5476 1200
 5477 1200              ;   This section applies to START only.
 5478 1200
 5479 1200 22 B4 5C             LD      ($5CB4),HL      ; set P-RAMT to the highest working RAM
 5480 1203                                              ; address.
 5481 1203 11 AF 3E             LD      DE,$3EAF        ; address of last byte of 'U' bitmap in ROM.
 5482 1206 01 A8 00             LD      BC,$00A8        ; there are 21 user defined graphics.
 5483 1209 EB                   EX      DE,HL           ; switch pointers and make the UDGs a
 5484 120A ED B8                LDDR                    ; copy of the standard characters A - U.
 5485 120C EB                   EX      DE,HL           ; switch the pointer to HL.
 5486 120D 23                   INC     HL              ; update to start of 'A' in RAM.
 5487 120E 22 7B 5C             LD      ($5C7B),HL      ; make UDG system variable address the first
 5488 1211                                              ; bitmap.
 5489 1211 2B                   DEC     HL              ; point at RAMTOP again.
 5490 1212
 5491 1212 01 40 00             LD      BC,$0040        ; set the values of
 5492 1215 ED 43 38 5C          LD      ($5C38),BC      ; the PIP and RASP system variables.
 5493 1219
 5494 1219              ;   The NEW command path rejoins here.
 5495 1219
 5496 1219              ;; RAM-SET
 5497 1219 22 B2 5C     L1219:  LD      ($5CB2),HL      ; set system variable RAMTOP to HL.
 5498 121C
 5499 121C              ;
 5500 121C              ;   Note. this entry point is a disabled Warm Restart that was almost certainly
 5501 121C              ;   once pointed to by the System Variable NMIADD.  It would be essential that
 5502 121C              ;   any NMI Handler would perform the tasks from here to the EI instruction
 5503 121C              ;   below.
 5504 121C
 5505 121C              ;; NMI_VECT
 5506 121C              L121C:
 5507 121C 21 00 3C             LD      HL,$3C00        ; a strange place to set the pointer to the
 5508 121F 22 36 5C             LD      ($5C36),HL      ; character set, CHARS - as no printing yet.
 5509 1222
 5510 1222 2A B2 5C             LD      HL,($5CB2)      ; fetch RAMTOP to HL again as we've lost it.
 5511 1225
 5512 1225 36 3E                LD      (HL),$3E        ; top of user ram holds GOSUB end marker
 5513 1227                                              ; an impossible line number - see RETURN.
 5514 1227                                              ; no significance in the number $3E. It has
 5515 1227                                              ; been traditional since the ZX80.
 5516 1227
 5517 1227 2B                   DEC     HL              ; followed by empty byte (not important).
 5518 1228 F9                   LD      SP,HL           ; set up the machine stack pointer.
 5519 1229 2B                   DEC     HL              ;
 5520 122A 2B                   DEC     HL              ;
 5521 122B 22 3D 5C             LD      ($5C3D),HL      ; ERR_SP is where the error pointer is
 5522 122E                                              ; at moment empty - will take address MAIN-4
 5523 122E                                              ; at the call preceding that address,
 5524 122E                                              ; although interrupts and calls will make use
 5525 122E                                              ; of this location in meantime.
 5526 122E
 5527 122E ED 56                IM      1               ; select interrupt mode 1.
 5528 1230
 5529 1230 FD 21 3A 5C          LD      IY,$5C3A        ; set IY to ERR_NR. IY can reach all standard
 5530 1234                                              ; system variables but shadow ROM system
 5531 1234                                              ; variables will be mostly out of range.
 5532 1234
 5533 1234 FB                   EI                      ; enable interrupts now that we have a stack.
 5534 1235
 5535 1235              ;   If, as suggested above, the NMI service routine pointed to this section of
 5536 1235              ;   code then a decision would have to be made at this point to jump forward,
 5537 1235              ;   in a Warm Restart scenario, to produce a report code, leaving any program
 5538 1235              ;   intact.
 5539 1235
 5540 1235 21 B6 5C             LD      HL,$5CB6        ; The address of the channels - initially
 5541 1238                                              ; following system variables.
 5542 1238 22 4F 5C             LD      ($5C4F),HL      ; Set the CHANS system variable.
 5543 123B
 5544 123B 11 AF 15             LD      DE,L15AF        ; Address: init-chan in ROM.
 5545 123E 01 15 00             LD      BC,$0015        ; There are 21 bytes of initial data in ROM.
 5546 1241 EB                   EX      DE,HL           ; swap the pointers.
 5547 1242 ED B0                LDIR                    ; Copy the bytes to RAM.
 5548 1244
 5549 1244 EB                   EX      DE,HL           ; Swap pointers. HL points to program area.
 5550 1245 2B                   DEC     HL              ; Decrement address.
 5551 1246 22 57 5C             LD      ($5C57),HL      ; Set DATADD to location before program area.
 5552 1249 23                   INC     HL              ; Increment again.
 5553 124A
 5554 124A 22 53 5C             LD      ($5C53),HL      ; Set PROG the location where BASIC starts.
 5555 124D 22 4B 5C             LD      ($5C4B),HL      ; Set VARS to same location with a
 5556 1250 36 80                LD      (HL),$80        ; variables end-marker.
 5557 1252 23                   INC     HL              ; Advance address.
 5558 1253 22 59 5C             LD      ($5C59),HL      ; Set E_LINE, where the edit line
 5559 1256                                              ; will be created.
 5560 1256                                              ; Note. it is not strictly necessary to
 5561 1256                                              ; execute the next fifteen bytes of code
 5562 1256                                              ; as this will be done by the call to SET-MIN.
 5563 1256                                              ; --
 5564 1256 36 0D                LD      (HL),$0D        ; initially just has a carriage return
 5565 1258 23                   INC     HL              ; followed by
 5566 1259 36 80                LD      (HL),$80        ; an end-marker.
 5567 125B 23                   INC     HL              ; address the next location.
 5568 125C 22 61 5C             LD      ($5C61),HL      ; set WORKSP - empty workspace.
 5569 125F 22 63 5C             LD      ($5C63),HL      ; set STKBOT - bottom of the empty stack.
 5570 1262 22 65 5C             LD      ($5C65),HL      ; set STKEND to the end of the empty stack.
 5571 1265                                              ; --
 5572 1265 3E 38                LD      A,$38           ; the colour system is set to white paper,
 5573 1267                                              ; black ink, no flash or bright.
 5574 1267 32 8D 5C             LD      ($5C8D),A       ; set ATTR_P permanent colour attributes.
 5575 126A 32 8F 5C             LD      ($5C8F),A       ; set ATTR_T temporary colour attributes.
 5576 126D 32 48 5C             LD      ($5C48),A       ; set BORDCR the border colour/lower screen
 5577 1270                                              ; attributes.
 5578 1270
 5579 1270 21 23 05             LD      HL,$0523        ; The keyboard repeat and delay values are
 5580 1273 22 09 5C             LD      ($5C09),HL      ; loaded to REPDEL and REPPER.
 5581 1276
 5582 1276 FD 35 C6             DEC     (IY-$3A)        ; set KSTATE-0 to $FF - keyboard map available.
 5583 1279 FD 35 CA             DEC     (IY-$36)        ; set KSTATE-4 to $FF - keyboard map available.
 5584 127C
 5585 127C 21 C6 15             LD      HL,L15C6        ; set source to ROM Address: init-strm
 5586 127F 11 10 5C             LD      DE,$5C10        ; set destination to system variable STRMS-FD
 5587 1282 01 0E 00             LD      BC,$000E        ; copy the 14 bytes of initial 7 streams data
 5588 1285 ED B0                LDIR                    ; from ROM to RAM.
 5589 1287
 5590 1287 FD CB 01 CE          SET     1,(IY+$01)      ; update FLAGS  - signal printer in use.
 5591 128B CD DF 0E             CALL    L0EDF           ; call routine CLEAR-PRB to initialize system
 5592 128E                                              ; variables associated with printer.
 5593 128E                                              ; The buffer is clear.
 5594 128E
 5595 128E FD 36 31 02          LD      (IY+$31),$02    ; set DF_SZ the lower screen display size to
 5596 1292                                              ; two lines
 5597 1292 CD 6B 0D             CALL    L0D6B           ; call routine CLS to set up system
 5598 1295                                              ; variables associated with screen and clear
 5599 1295                                              ; the screen and set attributes.
 5600 1295 AF                   XOR     A               ; clear accumulator so that we can address
 5601 1296 11 38 15             LD      DE,L1539 - 1    ; the message table directly.
 5602 1299 CD 0A 0C             CALL    L0C0A           ; routine PO-MSG puts
 5603 129C                                              ; '   1982 Sinclair Research Ltd'
 5604 129C                                              ; at bottom of display.
 5605 129C FD CB 02 EE          SET     5,(IY+$02)      ; update TV_FLAG  - signal lower screen will
 5606 12A0                                              ; require clearing.
 5607 12A0
 5608 12A0 18 07                JR      L12A9           ; forward to MAIN-1
 5609 12A2
 5610 12A2              ; -------------------------
 5611 12A2              ; THE 'MAIN EXECUTION LOOP'
 5612 12A2              ; -------------------------
 5613 12A2              ;
 5614 12A2              ;
 5615 12A2
 5616 12A2              ;; MAIN-EXEC
 5617 12A2 FD 36 31 02  L12A2:  LD      (IY+$31),$02    ; set DF_SZ lower screen display file size to
 5618 12A6                                              ; two lines.
 5619 12A6 CD 95 17             CALL    L1795           ; routine AUTO-LIST
 5620 12A9
 5621 12A9              ;; MAIN-1
 5622 12A9 CD B0 16     L12A9:  CALL    L16B0           ; routine SET-MIN clears work areas.
 5623 12AC
 5624 12AC              ;; MAIN-2
 5625 12AC 3E 00        L12AC:  LD      A,$00           ; select channel 'K' the keyboard
 5626 12AE
 5627 12AE CD 01 16             CALL    L1601           ; routine CHAN-OPEN opens it
 5628 12B1
 5629 12B1 CD 2C 0F             CALL    L0F2C           ; routine EDITOR is called.
 5630 12B4                                              ; Note the above routine is where the Spectrum
 5631 12B4                                              ; waits for user-interaction. Perhaps the
 5632 12B4                                              ; most common input at this stage
 5633 12B4                                              ; is LOAD "".
 5634 12B4
 5635 12B4 CD 17 1B             CALL    L1B17           ; routine LINE-SCAN scans the input.
 5636 12B7
 5637 12B7 FD CB 00 7E          BIT     7,(IY+$00)      ; test ERR_NR - will be $FF if syntax is OK.
 5638 12BB 20 12                JR      NZ,L12CF        ; forward, if correct, to MAIN-3.
 5639 12BD
 5640 12BD              ;
 5641 12BD
 5642 12BD FD CB 30 66          BIT     4,(IY+$30)      ; test FLAGS2 - K channel in use ?
 5643 12C1 28 40                JR      Z,L1303         ; forward to MAIN-4 if not.
 5644 12C3
 5645 12C3              ;
 5646 12C3
 5647 12C3 2A 59 5C             LD      HL,($5C59)      ; an editing error so address E_LINE.
 5648 12C6 CD A7 11             CALL    L11A7           ; routine REMOVE-FP removes the hidden
 5649 12C9                                              ; floating-point forms.
 5650 12C9 FD 36 00 FF          LD      (IY+$00),$FF    ; system variable ERR_NR is reset to 'OK'.
 5651 12CD 18 DD                JR      L12AC           ; back to MAIN-2 to allow user to correct.
 5652 12CF
 5653 12CF              ; ---
 5654 12CF
 5655 12CF              ; the branch was here if syntax has passed test.
 5656 12CF
 5657 12CF              ;; MAIN-3
 5658 12CF 2A 59 5C     L12CF:  LD      HL,($5C59)      ; fetch the edit line address from E_LINE.
 5659 12D2
 5660 12D2 22 5D 5C             LD      ($5C5D),HL      ; system variable CH_ADD is set to first
 5661 12D5                                              ; character of edit line.
 5662 12D5                                              ; Note. the above two instructions are a little
 5663 12D5                                              ; inadequate.
 5664 12D5                                              ; They are repeated with a subtle difference
 5665 12D5                                              ; at the start of the next subroutine and are
 5666 12D5                                              ; therefore not required above.
 5667 12D5
 5668 12D5 CD FB 19             CALL    L19FB           ; routine E-LINE-NO will fetch any line
 5669 12D8                                              ; number to BC if this is a program line.
 5670 12D8
 5671 12D8 78                   LD      A,B             ; test if the number of
 5672 12D9 B1                   OR      C               ; the line is non-zero.
 5673 12DA C2 5D 15             JP      NZ,L155D        ; jump forward to MAIN-ADD if so to add the
 5674 12DD                                              ; line to the BASIC program.
 5675 12DD
 5676 12DD              ; Has the user just pressed the ENTER key ?
 5677 12DD
 5678 12DD DF                   RST     18H             ; GET-CHAR gets character addressed by CH_ADD.
 5679 12DE FE 0D                CP      $0D             ; is it a carriage return ?
 5680 12E0 28 C0                JR      Z,L12A2         ; back to MAIN-EXEC if so for an automatic
 5681 12E2                                              ; listing.
 5682 12E2
 5683 12E2              ; this must be a direct command.
 5684 12E2
 5685 12E2 FD CB 30 46          BIT     0,(IY+$30)      ; test FLAGS2 - clear the main screen ?
 5686 12E6
 5687 12E6 C4 AF 0D             CALL    NZ,L0DAF        ; routine CL-ALL, if so, e.g. after listing.
 5688 12E9
 5689 12E9 CD 6E 0D             CALL    L0D6E           ; routine CLS-LOWER anyway.
 5690 12EC
 5691 12EC 3E 19                LD      A,$19           ; compute scroll count as 25 minus
 5692 12EE FD 96 4F             SUB     (IY+$4F)        ; value of S_POSN_hi.
 5693 12F1 32 8C 5C             LD      ($5C8C),A       ; update SCR_CT system variable.
 5694 12F4 FD CB 01 FE          SET     7,(IY+$01)      ; update FLAGS - signal running program.
 5695 12F8 FD 36 00 FF          LD      (IY+$00),$FF    ; set ERR_NR to 'OK'.
 5696 12FC FD 36 0A 01          LD      (IY+$0A),$01    ; set NSPPC to one for first statement.
 5697 1300 CD 8A 1B             CALL    L1B8A           ; call routine LINE-RUN to run the line.
 5698 1303                                              ; sysvar ERR_SP therefore addresses MAIN-4
 5699 1303
 5700 1303              ; Examples of direct commands are RUN, CLS, LOAD "", PRINT USR 40000,
 5701 1303              ; LPRINT "A"; etc..
 5702 1303              ; If a user written machine-code program disables interrupts then it
 5703 1303              ; must enable them to pass the next step. We also jumped to here if the
 5704 1303              ; keyboard was not being used.
 5705 1303
 5706 1303              ;; MAIN-4
 5707 1303 76           L1303:  HALT                    ; wait for interrupt the only routine that can
 5708 1304                                              ; set bit 5 of FLAGS.
 5709 1304
 5710 1304 FD CB 01 AE          RES     5,(IY+$01)      ; update bit 5 of FLAGS - signal no new key.
 5711 1308
 5712 1308 FD CB 30 4E          BIT     1,(IY+$30)      ; test FLAGS2 - is printer buffer clear ?
 5713 130C C4 CD 0E             CALL    NZ,L0ECD        ; call routine COPY-BUFF if not.
 5714 130F                                              ; Note. the programmer has neglected
 5715 130F                                              ; to set bit 1 of FLAGS first.
 5716 130F
 5717 130F 3A 3A 5C             LD      A,($5C3A)       ; fetch ERR_NR
 5718 1312 3C                   INC     A               ; increment to give true code.
 5719 1313
 5720 1313              ; Now deal with a runtime error as opposed to an editing error.
 5721 1313              ; However if the error code is now zero then the OK message will be printed.
 5722 1313
 5723 1313              ;; MAIN-G
 5724 1313 F5           L1313:  PUSH    AF              ; save the error number.
 5725 1314
 5726 1314 21 00 00             LD      HL,$0000        ; prepare to clear some system variables.
 5727 1317 FD 74 37             LD      (IY+$37),H      ; clear all the bits of FLAGX.
 5728 131A FD 74 26             LD      (IY+$26),H      ; blank X_PTR_hi to suppress error marker.
 5729 131D 22 0B 5C             LD      ($5C0B),HL      ; blank DEFADD to signal that no defined
 5730 1320                                              ; function is currently being evaluated.
 5731 1320
 5732 1320 21 01 00             LD      HL,$0001        ; explicit - inc hl would do.
 5733 1323 22 16 5C             LD      ($5C16),HL      ; ensure STRMS-00 is keyboard.
 5734 1326
 5735 1326 CD B0 16             CALL    L16B0           ; routine SET-MIN clears workspace etc.
 5736 1329 FD CB 37 AE          RES     5,(IY+$37)      ; update FLAGX - signal in EDIT not INPUT mode.
 5737 132D                                              ; Note. all the bits were reset earlier.
 5738 132D
 5739 132D CD 6E 0D             CALL    L0D6E           ; call routine CLS-LOWER.
 5740 1330
 5741 1330 FD CB 02 EE          SET     5,(IY+$02)      ; update TV_FLAG - signal lower screen
 5742 1334                                              ; requires clearing.
 5743 1334
 5744 1334 F1                   POP     AF              ; bring back the true error number
 5745 1335 47                   LD      B,A             ; and make a copy in B.
 5746 1336 FE 0A                CP      $0A             ; is it a print-ready digit ?
 5747 1338 38 02                JR      C,L133C         ; forward to MAIN-5 if so.
 5748 133A
 5749 133A C6 07                ADD     A,$07           ; add ASCII offset to letters.
 5750 133C
 5751 133C              ;; MAIN-5
 5752 133C CD EF 15     L133C:  CALL    L15EF           ; call routine OUT-CODE to print the code.
 5753 133F
 5754 133F 3E 20                LD      A,$20           ; followed by a space.
 5755 1341 D7                   RST     10H             ; PRINT-A
 5756 1342
 5757 1342 78                   LD      A,B             ; fetch stored report code.
 5758 1343 11 91 13             LD      DE,L1391        ; address: rpt-mesgs.
 5759 1346
 5760 1346 CD 0A 0C             CALL    L0C0A           ; call routine PO-MSG to print the message.
 5761 1349
 5762 1349 AF           X1349:  XOR     A               ; clear accumulator to directly
 5763 134A 11 36 15             LD      DE,L1537 - 1    ; address the comma and space message.
 5764 134D
 5765 134D CD 0A 0C             CALL    L0C0A           ; routine PO-MSG prints ', ' although it would
 5766 1350                                              ; be more succinct to use RST $10.
 5767 1350
 5768 1350 ED 4B 45 5C          LD      BC,($5C45)      ; fetch PPC the current line number.
 5769 1354 CD 1B 1A             CALL    L1A1B           ; routine OUT-NUM-1 will print that
 5770 1357
 5771 1357 3E 3A                LD      A,$3A           ; then a ':' character.
 5772 1359 D7                   RST     10H             ; PRINT-A
 5773 135A
 5774 135A FD 4E 0D             LD      C,(IY+$0D)      ; then SUBPPC for statement
 5775 135D 06 00                LD      B,$00           ; limited to 127
 5776 135F CD 1B 1A             CALL    L1A1B           ; routine OUT-NUM-1 prints BC.
 5777 1362
 5778 1362 CD 97 10             CALL    L1097           ; routine CLEAR-SP clears editing area which
 5779 1365                                              ; probably contained 'RUN'.
 5780 1365
 5781 1365 3A 3A 5C             LD      A,($5C3A)       ; fetch ERR_NR again
 5782 1368 3C                   INC     A               ; test for no error originally $FF.
 5783 1369 28 1B                JR      Z,L1386         ; forward to MAIN-9 if no error.
 5784 136B
 5785 136B FE 09                CP      $09             ; is code Report 9 STOP ?
 5786 136D 28 04                JR      Z,L1373         ; forward to MAIN-6 if so
 5787 136F
 5788 136F FE 15                CP      $15             ; is code Report L Break ?
 5789 1371 20 03                JR      NZ,L1376        ; forward to MAIN-7 if not
 5790 1373
 5791 1373              ; Stop or Break was encountered so consider CONTINUE.
 5792 1373
 5793 1373              ;; MAIN-6
 5794 1373 FD 34 0D     L1373:  INC     (IY+$0D)        ; increment SUBPPC to next statement.
 5795 1376
 5796 1376              ;; MAIN-7
 5797 1376 01 03 00     L1376:  LD      BC,$0003        ; prepare to copy 3 system variables to
 5798 1379 11 70 5C             LD      DE,$5C70        ; address OSPPC - statement for CONTINUE.
 5799 137C                                              ; also updating OLDPPC line number below.
 5800 137C
 5801 137C 21 44 5C             LD      HL,$5C44        ; set source top to NSPPC next statement.
 5802 137F CB 7E                BIT     7,(HL)          ; did BREAK occur before the jump ?
 5803 1381                                              ; e.g. between GO TO and next statement.
 5804 1381 28 01                JR      Z,L1384         ; skip forward to MAIN-8, if not, as set-up
 5805 1383                                              ; is correct.
 5806 1383
 5807 1383 09                   ADD     HL,BC           ; set source to SUBPPC number of current
 5808 1384                                              ; statement/line which will be repeated.
 5809 1384
 5810 1384              ;; MAIN-8
 5811 1384 ED B8        L1384:  LDDR                    ; copy PPC to OLDPPC and SUBPPC to OSPCC
 5812 1386                                              ; or NSPPC to OLDPPC and NEWPPC to OSPCC
 5813 1386
 5814 1386              ;; MAIN-9
 5815 1386 FD 36 0A FF  L1386:  LD      (IY+$0A),$FF    ; update NSPPC - signal 'no jump'.
 5816 138A FD CB 01 9E          RES     3,(IY+$01)      ; update FLAGS - signal use 'K' mode for
 5817 138E                                              ; the first character in the editor and
 5818 138E
 5819 138E C3 AC 12             JP      L12AC           ; jump back to MAIN-2.
 5820 1391
 5821 1391
 5822 1391              ; ----------------------
 5823 1391              ; Canned report messages
 5824 1391              ; ----------------------
 5825 1391              ; The Error reports with the last byte inverted. The first entry
 5826 1391              ; is a dummy entry. The last, which begins with $7F, the Spectrum
 5827 1391              ; character for copyright symbol, is placed here for convenience
 5828 1391              ; as is the preceding comma and space.
 5829 1391              ; The report line must accommodate a 4-digit line number and a 3-digit
 5830 1391              ; statement number which limits the length of the message text to twenty
 5831 1391              ; characters.
 5832 1391              ; e.g.  "B Integer out of range, 1000:127"
 5833 1391
 5834 1391              ;; rpt-mesgs
 5835 1391 80           L1391:  DEFB    $80
 5836 1392 4F CB                DEFB    'O','K'+$80                             ; 0
 5837 1394 4E 45 58 54          DEFM    "NEXT without FO"
 5837 1398 20 77 69 74
 5837 139C 68 6F 75 74
 5837 13A0 20 46 4F
 5838 13A3 D2                   DEFB    'R'+$80                                 ; 1
 5839 13A4 56 61 72 69          DEFM    "Variable not foun"
 5839 13A8 61 62 6C 65
 5839 13AC 20 6E 6F 74
 5839 13B0 20 66 6F 75
 5839 13B4 6E
 5840 13B5 E4                   DEFB    'd'+$80                                 ; 2
 5841 13B6 53 75 62 73          DEFM    "Subscript wron"
 5841 13BA 63 72 69 70
 5841 13BE 74 20 77 72
 5841 13C2 6F 6E
 5842 13C4 E7                   DEFB    'g'+$80                                 ; 3
 5843 13C5 4F 75 74 20          DEFM    "Out of memor"
 5843 13C9 6F 66 20 6D
 5843 13CD 65 6D 6F 72
 5844 13D1 F9                   DEFB    'y'+$80                                 ; 4
 5845 13D2 4F 75 74 20          DEFM    "Out of scree"
 5845 13D6 6F 66 20 73
 5845 13DA 63 72 65 65
 5846 13DE EE                   DEFB    'n'+$80                                 ; 5
 5847 13DF 4E 75 6D 62          DEFM    "Number too bi"
 5847 13E3 65 72 20 74
 5847 13E7 6F 6F 20 62
 5847 13EB 69
 5848 13EC E7                   DEFB    'g'+$80                                 ; 6
 5849 13ED 52 45 54 55          DEFM    "RETURN without GOSU"
 5849 13F1 52 4E 20 77
 5849 13F5 69 74 68 6F
 5849 13F9 75 74 20 47
 5849 13FD 4F 53 55
 5850 1400 C2                   DEFB    'B'+$80                                 ; 7
 5851 1401 45 6E 64 20          DEFM    "End of fil"
 5851 1405 6F 66 20 66
 5851 1409 69 6C
 5852 140B E5                   DEFB    'e'+$80                                 ; 8
 5853 140C 53 54 4F 50          DEFM    "STOP statemen"
 5853 1410 20 73 74 61
 5853 1414 74 65 6D 65
 5853 1418 6E
 5854 1419 F4                   DEFB    't'+$80                                 ; 9
 5855 141A 49 6E 76 61          DEFM    "Invalid argumen"
 5855 141E 6C 69 64 20
 5855 1422 61 72 67 75
 5855 1426 6D 65 6E
 5856 1429 F4                   DEFB    't'+$80                                 ; A
 5857 142A 49 6E 74 65          DEFM    "Integer out of rang"
 5857 142E 67 65 72 20
 5857 1432 6F 75 74 20
 5857 1436 6F 66 20 72
 5857 143A 61 6E 67
 5858 143D E5                   DEFB    'e'+$80                                 ; B
 5859 143E 4E 6F 6E 73          DEFM    "Nonsense in BASI"
 5859 1442 65 6E 73 65
 5859 1446 20 69 6E 20
 5859 144A 42 41 53 49
 5860 144E C3                   DEFB    'C'+$80                                 ; C
 5861 144F 42 52 45 41          DEFM    "BREAK - CONT repeat"
 5861 1453 4B 20 2D 20
 5861 1457 43 4F 4E 54
 5861 145B 20 72 65 70
 5861 145F 65 61 74
 5862 1462 F3                   DEFB    's'+$80                                 ; D
 5863 1463 4F 75 74 20          DEFM    "Out of DAT"
 5863 1467 6F 66 20 44
 5863 146B 41 54
 5864 146D C1                   DEFB    'A'+$80                                 ; E
 5865 146E 49 6E 76 61          DEFM    "Invalid file nam"
 5865 1472 6C 69 64 20
 5865 1476 66 69 6C 65
 5865 147A 20 6E 61 6D
 5866 147E E5                   DEFB    'e'+$80                                 ; F
 5867 147F 4E 6F 20 72          DEFM    "No room for lin"
 5867 1483 6F 6F 6D 20
 5867 1487 66 6F 72 20
 5867 148B 6C 69 6E
 5868 148E E5                   DEFB    'e'+$80                                 ; G
 5869 148F 53 54 4F 50          DEFM    "STOP in INPU"
 5869 1493 20 69 6E 20
 5869 1497 49 4E 50 55
 5870 149B D4                   DEFB    'T'+$80                                 ; H
 5871 149C 46 4F 52 20          DEFM    "FOR without NEX"
 5871 14A0 77 69 74 68
 5871 14A4 6F 75 74 20
 5871 14A8 4E 45 58
 5872 14AB D4                   DEFB    'T'+$80                                 ; I
 5873 14AC 49 6E 76 61          DEFM    "Invalid I/O devic"
 5873 14B0 6C 69 64 20
 5873 14B4 49 2F 4F 20
 5873 14B8 64 65 76 69
 5873 14BC 63
 5874 14BD E5                   DEFB    'e'+$80                                 ; J
 5875 14BE 49 6E 76 61          DEFM    "Invalid colou"
 5875 14C2 6C 69 64 20
 5875 14C6 63 6F 6C 6F
 5875 14CA 75
 5876 14CB F2                   DEFB    'r'+$80                                 ; K
 5877 14CC 42 52 45 41          DEFM    "BREAK into progra"
 5877 14D0 4B 20 69 6E
 5877 14D4 74 6F 20 70
 5877 14D8 72 6F 67 72
 5877 14DC 61
 5878 14DD ED                   DEFB    'm'+$80                                 ; L
 5879 14DE 52 41 4D 54          DEFM    "RAMTOP no goo"
 5879 14E2 4F 50 20 6E
 5879 14E6 6F 20 67 6F
 5879 14EA 6F
 5880 14EB E4                   DEFB    'd'+$80                                 ; M
 5881 14EC 53 74 61 74          DEFM    "Statement los"
 5881 14F0 65 6D 65 6E
 5881 14F4 74 20 6C 6F
 5881 14F8 73
 5882 14F9 F4                   DEFB    't'+$80                                 ; N
 5883 14FA 49 6E 76 61          DEFM    "Invalid strea"
 5883 14FE 6C 69 64 20
 5883 1502 73 74 72 65
 5883 1506 61
 5884 1507 ED                   DEFB    'm'+$80                                 ; O
 5885 1508 46 4E 20 77          DEFM    "FN without DE"
 5885 150C 69 74 68 6F
 5885 1510 75 74 20 44
 5885 1514 45
 5886 1515 C6                   DEFB    'F'+$80                                 ; P
 5887 1516 50 61 72 61          DEFM    "Parameter erro"
 5887 151A 6D 65 74 65
 5887 151E 72 20 65 72
 5887 1522 72 6F
 5888 1524 F2                   DEFB    'r'+$80                                 ; Q
 5889 1525 54 61 70 65          DEFM    "Tape loading erro"
 5889 1529 20 6C 6F 61
 5889 152D 64 69 6E 67
 5889 1531 20 65 72 72
 5889 1535 6F
 5890 1536 F2                   DEFB    'r'+$80                                 ; R
 5891 1537              ;; comma-sp
 5892 1537 2C A0        L1537:  DEFB    ',',' '+$80                             ; used in report line.
 5893 1539              ;; copyright
 5894 1539 7F           L1539:  DEFB    $7F                                     ; copyright
 5895 153A 20 31 39 38          DEFM    " 1982 Sinclair Research Lt"
 5895 153E 32 20 53 69
 5895 1542 6E 63 6C 61
 5895 1546 69 72 20 52
 5895 154A 65 73 65 61
 5895 154E 72 63 68 20
 5895 1552 4C 74
 5896 1554 E4                   DEFB    'd'+$80
 5897 1555
 5898 1555
 5899 1555              ; -------------
 5900 1555              ; REPORT-G
 5901 1555              ; -------------
 5902 1555              ; Note ERR_SP points here during line entry which allows the
 5903 1555              ; normal 'Out of Memory' report to be augmented to the more
 5904 1555              ; precise 'No Room for line' report.
 5905 1555
 5906 1555              ;; REPORT-G
 5907 1555              ; No Room for line
 5908 1555 3E 10        L1555:  LD      A,$10           ; i.e. 'G' -$30 -$07
 5909 1557 01 00 00             LD      BC,$0000        ; this seems unnecessary.
 5910 155A C3 13 13             JP      L1313           ; jump back to MAIN-G
 5911 155D
 5912 155D              ; -----------------------------
 5913 155D              ; Handle addition of BASIC line
 5914 155D              ; -----------------------------
 5915 155D              ; Note this is not a subroutine but a branch of the main execution loop.
 5916 155D              ; System variable ERR_SP still points to editing error handler.
 5917 155D              ; A new line is added to the BASIC program at the appropriate place.
 5918 155D              ; An existing line with same number is deleted first.
 5919 155D              ; Entering an existing line number deletes that line.
 5920 155D              ; Entering a non-existent line allows the subsequent line to be edited next.
 5921 155D
 5922 155D              ;; MAIN-ADD
 5923 155D ED 43 49 5C  L155D:  LD      ($5C49),BC      ; set E_PPC to extracted line number.
 5924 1561 2A 5D 5C             LD      HL,($5C5D)      ; fetch CH_ADD - points to location after the
 5925 1564                                              ; initial digits (set in E_LINE_NO).
 5926 1564 EB                   EX      DE,HL           ; save start of BASIC in DE.
 5927 1565
 5928 1565 21 55 15             LD      HL,L1555        ; Address: REPORT-G
 5929 1568 E5                   PUSH    HL              ; is pushed on stack and addressed by ERR_SP.
 5930 1569                                              ; the only error that can occur is
 5931 1569                                              ; 'Out of memory'.
 5932 1569
 5933 1569 2A 61 5C             LD      HL,($5C61)      ; fetch WORKSP - end of line.
 5934 156C 37                   SCF                     ; prepare for true subtraction.
 5935 156D ED 52                SBC     HL,DE           ; find length of BASIC and
 5936 156F E5                   PUSH    HL              ; save it on stack.
 5937 1570 60                   LD      H,B             ; transfer line number
 5938 1571 69                   LD      L,C             ; to HL register.
 5939 1572 CD 6E 19             CALL    L196E           ; routine LINE-ADDR will see if
 5940 1575                                              ; a line with the same number exists.
 5941 1575 20 06                JR      NZ,L157D        ; forward if no existing line to MAIN-ADD1.
 5942 1577
 5943 1577 CD B8 19             CALL    L19B8           ; routine NEXT-ONE finds the existing line.
 5944 157A CD E8 19             CALL    L19E8           ; routine RECLAIM-2 reclaims it.
 5945 157D
 5946 157D              ;; MAIN-ADD1
 5947 157D C1           L157D:  POP     BC              ; retrieve the length of the new line.
 5948 157E 79                   LD      A,C             ; and test if carriage return only
 5949 157F 3D                   DEC     A               ; i.e. one byte long.
 5950 1580 B0                   OR      B               ; result would be zero.
 5951 1581 28 28                JR      Z,L15AB         ; forward to MAIN-ADD2 is so.
 5952 1583
 5953 1583 C5                   PUSH    BC              ; save the length again.
 5954 1584 03                   INC     BC              ; adjust for inclusion
 5955 1585 03                   INC     BC              ; of line number (two bytes)
 5956 1586 03                   INC     BC              ; and line length
 5957 1587 03                   INC     BC              ; (two bytes).
 5958 1588 2B                   DEC     HL              ; HL points to location before the destination
 5959 1589
 5960 1589 ED 5B 53 5C          LD      DE,($5C53)      ; fetch the address of PROG
 5961 158D D5                   PUSH    DE              ; and save it on the stack
 5962 158E CD 55 16             CALL    L1655           ; routine MAKE-ROOM creates BC spaces in
 5963 1591                                              ; program area and updates pointers.
 5964 1591 E1                   POP     HL              ; restore old program pointer.
 5965 1592 22 53 5C             LD      ($5C53),HL      ; and put back in PROG as it may have been
 5966 1595                                              ; altered by the POINTERS routine.
 5967 1595
 5968 1595 C1                   POP     BC              ; retrieve BASIC length
 5969 1596 C5                   PUSH    BC              ; and save again.
 5970 1597
 5971 1597 13                   INC     DE              ; points to end of new area.
 5972 1598 2A 61 5C             LD      HL,($5C61)      ; set HL to WORKSP - location after edit line.
 5973 159B 2B                   DEC     HL              ; decrement to address end marker.
 5974 159C 2B                   DEC     HL              ; decrement to address carriage return.
 5975 159D ED B8                LDDR                    ; copy the BASIC line back to initial command.
 5976 159F
 5977 159F 2A 49 5C             LD      HL,($5C49)      ; fetch E_PPC - line number.
 5978 15A2 EB                   EX      DE,HL           ; swap it to DE, HL points to last of
 5979 15A3                                              ; four locations.
 5980 15A3 C1                   POP     BC              ; retrieve length of line.
 5981 15A4 70                   LD      (HL),B          ; high byte last.
 5982 15A5 2B                   DEC     HL              ;
 5983 15A6 71                   LD      (HL),C          ; then low byte of length.
 5984 15A7 2B                   DEC     HL              ;
 5985 15A8 73                   LD      (HL),E          ; then low byte of line number.
 5986 15A9 2B                   DEC     HL              ;
 5987 15AA 72                   LD      (HL),D          ; then high byte range $0 - $27 (1-9999).
 5988 15AB
 5989 15AB              ;; MAIN-ADD2
 5990 15AB F1           L15AB:  POP     AF              ; drop the address of Report G
 5991 15AC C3 A2 12             JP      L12A2           ; and back to MAIN-EXEC producing a listing
 5992 15AF                                              ; and to reset ERR_SP in EDITOR.
 5993 15AF
 5994 15AF
 5995 15AF              ; ---------------------------------
 5996 15AF              ; THE 'INITIAL CHANNEL' INFORMATION
 5997 15AF              ; ---------------------------------
 5998 15AF              ;   This initial channel information is copied from ROM to RAM, during
 5999 15AF              ;   initialization.  It's new location is after the system variables and is
 6000 15AF              ;   addressed by the system variable CHANS which means that it can slide up and
 6001 15AF              ;   down in memory.  The table is never searched, by this ROM, and the last
 6002 15AF              ;   character, which could be anything other than a comma, provides a
 6003 15AF              ;   convenient resting place for DATADD.
 6004 15AF
 6005 15AF              ;; init-chan
 6006 15AF F4 09        L15AF:  DEFW    L09F4           ; PRINT-OUT
 6007 15B1 A8 10                DEFW    L10A8           ; KEY-INPUT
 6008 15B3 4B                   DEFB    $4B             ; 'K'
 6009 15B4 F4 09                DEFW    L09F4           ; PRINT-OUT
 6010 15B6 C4 15                DEFW    L15C4           ; REPORT-J
 6011 15B8 53                   DEFB    $53             ; 'S'
 6012 15B9 81 0F                DEFW    L0F81           ; ADD-CHAR
 6013 15BB C4 15                DEFW    L15C4           ; REPORT-J
 6014 15BD 52                   DEFB    $52             ; 'R'
 6015 15BE F4 09                DEFW    L09F4           ; PRINT-OUT
 6016 15C0 C4 15                DEFW    L15C4           ; REPORT-J
 6017 15C2 50                   DEFB    $50             ; 'P'
 6018 15C3
 6019 15C3 80                   DEFB    $80             ; End Marker
 6020 15C4
 6021 15C4              ;; REPORT-J
 6022 15C4 CF           L15C4:  RST     08H             ; ERROR-1
 6023 15C5 12                   DEFB    $12             ; Error Report: Invalid I/O device
 6024 15C6
 6025 15C6
 6026 15C6              ; -------------------------
 6027 15C6              ; THE 'INITIAL STREAM' DATA
 6028 15C6              ; -------------------------
 6029 15C6              ;   This is the initial stream data for the seven streams $FD - $03 that is
 6030 15C6              ;   copied from ROM to the STRMS system variables area during initialization.
 6031 15C6              ;   There are reserved locations there for another 12 streams.  Each location
 6032 15C6              ;   contains an offset to the second byte of a channel.  The first byte of a
 6033 15C6              ;   channel can't be used as that would result in an offset of zero for some
 6034 15C6              ;   and zero is used to denote that a stream is closed.
 6035 15C6
 6036 15C6              ;; init-strm
 6037 15C6 01 00        L15C6:  DEFB    $01, $00        ; stream $FD offset to channel 'K'
 6038 15C8 06 00                DEFB    $06, $00        ; stream $FE offset to channel 'S'
 6039 15CA 0B 00                DEFB    $0B, $00        ; stream $FF offset to channel 'R'
 6040 15CC
 6041 15CC 01 00                DEFB    $01, $00        ; stream $00 offset to channel 'K'
 6042 15CE 01 00                DEFB    $01, $00        ; stream $01 offset to channel 'K'
 6043 15D0 06 00                DEFB    $06, $00        ; stream $02 offset to channel 'S'
 6044 15D2 10 00                DEFB    $10, $00        ; stream $03 offset to channel 'P'
 6045 15D4
 6046 15D4              ; ------------------------------
 6047 15D4              ; THE 'INPUT CONTROL' SUBROUTINE
 6048 15D4              ; ------------------------------
 6049 15D4              ;
 6050 15D4
 6051 15D4              ;; WAIT-KEY
 6052 15D4 FD CB 02 6E  L15D4:  BIT     5,(IY+$02)      ; test TV_FLAG - clear lower screen ?
 6053 15D8 20 04                JR      NZ,L15DE        ; forward to WAIT-KEY1 if so.
 6054 15DA
 6055 15DA FD CB 02 DE          SET     3,(IY+$02)      ; update TV_FLAG - signal reprint the edit
 6056 15DE                                              ; line to the lower screen.
 6057 15DE
 6058 15DE              ;; WAIT-KEY1
 6059 15DE CD E6 15     L15DE:  CALL    L15E6           ; routine INPUT-AD is called.
 6060 15E1
 6061 15E1 D8                   RET     C               ; return with acceptable keys.
 6062 15E2
 6063 15E2 28 FA                JR      Z,L15DE         ; back to WAIT-KEY1 if no key is pressed
 6064 15E4                                              ; or it has been handled within INPUT-AD.
 6065 15E4
 6066 15E4              ;   Note. When inputting from the keyboard all characters are returned with
 6067 15E4              ;   above conditions so this path is never taken.
 6068 15E4
 6069 15E4              ;; REPORT-8
 6070 15E4 CF           L15E4:  RST     08H             ; ERROR-1
 6071 15E5 07                   DEFB    $07             ; Error Report: End of file
 6072 15E6
 6073 15E6              ; ---------------------------
 6074 15E6              ; THE 'INPUT ADDRESS' ROUTINE
 6075 15E6              ; ---------------------------
 6076 15E6              ;   This routine fetches the address of the input stream from the current
 6077 15E6              ;   channel area using the system variable CURCHL.
 6078 15E6
 6079 15E6              ;; INPUT-AD
 6080 15E6 D9           L15E6:  EXX                     ; switch in alternate set.
 6081 15E7 E5                   PUSH    HL              ; save HL register
 6082 15E8 2A 51 5C             LD      HL,($5C51)      ; fetch address of CURCHL - current channel.
 6083 15EB 23                   INC     HL              ; step over output routine
 6084 15EC 23                   INC     HL              ; to point to low byte of input routine.
 6085 15ED 18 08                JR      L15F7           ; forward to CALL-SUB.
 6086 15EF
 6087 15EF              ; -------------------------
 6088 15EF              ; THE 'CODE OUTPUT' ROUTINE
 6089 15EF              ; -------------------------
 6090 15EF              ;   This routine is called on five occasions to print the ASCII equivalent of
 6091 15EF              ;   a value 0-9.
 6092 15EF
 6093 15EF              ;; OUT-CODE
 6094 15EF 1E 30        L15EF:  LD      E,$30           ; add 48 decimal to give the ASCII character
 6095 15F1 83                   ADD     A,E             ; '0' to '9' and continue into the main output
 6096 15F2                                              ; routine.
 6097 15F2
 6098 15F2              ; -------------------------
 6099 15F2              ; THE 'MAIN OUTPUT' ROUTINE
 6100 15F2              ; -------------------------
 6101 15F2              ;   PRINT-A-2 is a continuation of the RST 10 restart that prints any character.
 6102 15F2              ;   The routine prints to the current channel and the printing of control codes
 6103 15F2              ;   may alter that channel to divert subsequent RST 10 instructions to temporary
 6104 15F2              ;   routines. The normal channel is $09F4.
 6105 15F2
 6106 15F2              ;; PRINT-A-2
 6107 15F2 D9           L15F2:  EXX                     ; switch in alternate set
 6108 15F3 E5                   PUSH    HL              ; save HL register
 6109 15F4 2A 51 5C             LD      HL,($5C51)      ; fetch CURCHL the current channel.
 6110 15F7
 6111 15F7              ; input-ad rejoins here also.
 6112 15F7
 6113 15F7              ;; CALL-SUB
 6114 15F7 5E           L15F7:  LD      E,(HL)          ; put the low byte in E.
 6115 15F8 23                   INC     HL              ; advance address.
 6116 15F9 56                   LD      D,(HL)          ; put the high byte to D.
 6117 15FA EB                   EX      DE,HL           ; transfer the stream to HL.
 6118 15FB CD 2C 16             CALL    L162C           ; use routine CALL-JUMP.
 6119 15FE                                              ; in effect CALL (HL).
 6120 15FE
 6121 15FE E1                   POP     HL              ; restore saved HL register.
 6122 15FF D9                   EXX                     ; switch back to the main set and
 6123 1600 C9                   RET                     ; return.
 6124 1601
 6125 1601              ; --------------------------
 6126 1601              ; THE 'OPEN CHANNEL' ROUTINE
 6127 1601              ; --------------------------
 6128 1601              ;   This subroutine is used by the ROM to open a channel 'K', 'S', 'R' or 'P'.
 6129 1601              ;   This is either for its own use or in response to a user's request, for
 6130 1601              ;   example, when '#' is encountered with output - PRINT, LIST etc.
 6131 1601              ;   or with input - INPUT, INKEY$ etc.
 6132 1601              ;   It is entered with a system stream $FD - $FF, or a user stream $00 - $0F
 6133 1601              ;   in the accumulator.
 6134 1601
 6135 1601              ;; CHAN-OPEN
 6136 1601 87           L1601:  ADD     A,A             ; double the stream ($FF will become $FE etc.)
 6137 1602 C6 16                ADD     A,$16           ; add the offset to stream 0 from $5C00
 6138 1604 6F                   LD      L,A             ; result to L
 6139 1605 26 5C                LD      H,$5C           ; now form the address in STRMS area.
 6140 1607 5E                   LD      E,(HL)          ; fetch low byte of CHANS offset
 6141 1608 23                   INC     HL              ; address next
 6142 1609 56                   LD      D,(HL)          ; fetch high byte of offset
 6143 160A 7A                   LD      A,D             ; test that the stream is open.
 6144 160B B3                   OR      E               ; zero if closed.
 6145 160C 20 02                JR      NZ,L1610        ; forward to CHAN-OP-1 if open.
 6146 160E
 6147 160E              ;; REPORT-Oa
 6148 160E CF           L160E:  RST     08H             ; ERROR-1
 6149 160F 17                   DEFB    $17             ; Error Report: Invalid stream
 6150 1610
 6151 1610              ; continue here if stream was open. Note that the offset is from CHANS
 6152 1610              ; to the second byte of the channel.
 6153 1610
 6154 1610              ;; CHAN-OP-1
 6155 1610 1B           L1610:  DEC     DE              ; reduce offset so it points to the channel.
 6156 1611 2A 4F 5C             LD      HL,($5C4F)      ; fetch CHANS the location of the base of
 6157 1614                                              ; the channel information area
 6158 1614 19                   ADD     HL,DE           ; and add the offset to address the channel.
 6159 1615                                              ; and continue to set flags.
 6160 1615
 6161 1615              ; -----------------
 6162 1615              ; Set channel flags
 6163 1615              ; -----------------
 6164 1615              ; This subroutine is used from ED-EDIT, str$ and read-in to reset the
 6165 1615              ; current channel when it has been temporarily altered.
 6166 1615
 6167 1615              ;; CHAN-FLAG
 6168 1615 22 51 5C     L1615:  LD      ($5C51),HL      ; set CURCHL system variable to the
 6169 1618                                              ; address in HL
 6170 1618 FD CB 30 A6          RES     4,(IY+$30)      ; update FLAGS2  - signal K channel not in use.
 6171 161C                                              ; Note. provide a default for channel 'R'.
 6172 161C 23                   INC     HL              ; advance past
 6173 161D 23                   INC     HL              ; output routine.
 6174 161E 23                   INC     HL              ; advance past
 6175 161F 23                   INC     HL              ; input routine.
 6176 1620 4E                   LD      C,(HL)          ; pick up the letter.
 6177 1621 21 2D 16             LD      HL,L162D        ; address: chn-cd-lu
 6178 1624 CD DC 16             CALL    L16DC           ; routine INDEXER finds offset to a
 6179 1627                                              ; flag-setting routine.
 6180 1627
 6181 1627 D0                   RET     NC              ; but if the letter wasn't found in the
 6182 1628                                              ; table just return now. - channel 'R'.
 6183 1628
 6184 1628 16 00                LD      D,$00           ; prepare to add
 6185 162A 5E                   LD      E,(HL)          ; offset to E
 6186 162B 19                   ADD     HL,DE           ; add offset to location of offset to form
 6187 162C                                              ; address of routine
 6188 162C
 6189 162C              ;; CALL-JUMP
 6190 162C E9           L162C:  JP      (HL)            ; jump to the routine
 6191 162D
 6192 162D              ; Footnote. calling any location that holds JP (HL) is the equivalent to
 6193 162D              ; a pseudo Z80 instruction CALL (HL). The ROM uses the instruction above.
 6194 162D
 6195 162D              ; --------------------------
 6196 162D              ; Channel code look-up table
 6197 162D              ; --------------------------
 6198 162D              ; This table is used by the routine above to find one of the three
 6199 162D              ; flag setting routines below it.
 6200 162D              ; A zero end-marker is required as channel 'R' is not present.
 6201 162D
 6202 162D              ;; chn-cd-lu
 6203 162D 4B 06        L162D:  DEFB    'K', L1634-$-1  ; offset $06 to CHAN-K
 6204 162F 53 12                DEFB    'S', L1642-$-1  ; offset $12 to CHAN-S
 6205 1631 50 1B                DEFB    'P', L164D-$-1  ; offset $1B to CHAN-P
 6206 1633
 6207 1633 00                   DEFB    $00             ; end marker.
 6208 1634
 6209 1634              ; --------------
 6210 1634              ; Channel K flag
 6211 1634              ; --------------
 6212 1634              ; routine to set flags for lower screen/keyboard channel.
 6213 1634
 6214 1634              ;; CHAN-K
 6215 1634 FD CB 02 C6  L1634:  SET     0,(IY+$02)      ; update TV_FLAG  - signal lower screen in use
 6216 1638 FD CB 01 AE          RES     5,(IY+$01)      ; update FLAGS    - signal no new key
 6217 163C FD CB 30 E6          SET     4,(IY+$30)      ; update FLAGS2   - signal K channel in use
 6218 1640 18 04                JR      L1646           ; forward to CHAN-S-1 for indirect exit
 6219 1642
 6220 1642              ; --------------
 6221 1642              ; Channel S flag
 6222 1642              ; --------------
 6223 1642              ; routine to set flags for upper screen channel.
 6224 1642
 6225 1642              ;; CHAN-S
 6226 1642 FD CB 02 86  L1642:  RES     0,(IY+$02)      ; TV_FLAG  - signal main screen in use
 6227 1646
 6228 1646              ;; CHAN-S-1
 6229 1646 FD CB 01 8E  L1646:  RES     1,(IY+$01)      ; update FLAGS  - signal printer not in use
 6230 164A C3 4D 0D             JP      L0D4D           ; jump back to TEMPS and exit via that
 6231 164D                                              ; routine after setting temporary attributes.
 6232 164D              ; --------------
 6233 164D              ; Channel P flag
 6234 164D              ; --------------
 6235 164D              ; This routine sets a flag so that subsequent print related commands
 6236 164D              ; print to printer or update the relevant system variables.
 6237 164D              ; This status remains in force until reset by the routine above.
 6238 164D
 6239 164D              ;; CHAN-P
 6240 164D FD CB 01 CE  L164D:  SET     1,(IY+$01)      ; update FLAGS  - signal printer in use
 6241 1651 C9                   RET                     ; return
 6242 1652
 6243 1652              ; --------------------------
 6244 1652              ; THE 'ONE SPACE' SUBROUTINE
 6245 1652              ; --------------------------
 6246 1652              ; This routine is called once only to create a single space
 6247 1652              ; in workspace by ADD-CHAR.
 6248 1652
 6249 1652              ;; ONE-SPACE
 6250 1652 01 01 00     L1652:  LD      BC,$0001        ; create space for a single character.
 6251 1655
 6252 1655              ; ---------
 6253 1655              ; Make Room
 6254 1655              ; ---------
 6255 1655              ; This entry point is used to create BC spaces in various areas such as
 6256 1655              ; program area, variables area, workspace etc..
 6257 1655              ; The entire free RAM is available to each BASIC statement.
 6258 1655              ; On entry, HL addresses where the first location is to be created.
 6259 1655              ; Afterwards, HL will point to the location before this.
 6260 1655
 6261 1655              ;; MAKE-ROOM
 6262 1655 E5           L1655:  PUSH    HL              ; save the address pointer.
 6263 1656 CD 05 1F             CALL    L1F05           ; routine TEST-ROOM checks if room
 6264 1659                                              ; exists and generates an error if not.
 6265 1659 E1                   POP     HL              ; restore the address pointer.
 6266 165A CD 64 16             CALL    L1664           ; routine POINTERS updates the
 6267 165D                                              ; dynamic memory location pointers.
 6268 165D                                              ; DE now holds the old value of STKEND.
 6269 165D 2A 65 5C             LD      HL,($5C65)      ; fetch new STKEND the top destination.
 6270 1660
 6271 1660 EB                   EX      DE,HL           ; HL now addresses the top of the area to
 6272 1661                                              ; be moved up - old STKEND.
 6273 1661 ED B8                LDDR                    ; the program, variables, etc are moved up.
 6274 1663 C9                   RET                     ; return with new area ready to be populated.
 6275 1664                                              ; HL points to location before new area,
 6276 1664                                              ; and DE to last of new locations.
 6277 1664
 6278 1664              ; -----------------------------------------------
 6279 1664              ; Adjust pointers before making or reclaiming room
 6280 1664              ; -----------------------------------------------
 6281 1664              ; This routine is called by MAKE-ROOM to adjust upwards and by RECLAIM to
 6282 1664              ; adjust downwards the pointers within dynamic memory.
 6283 1664              ; The fourteen pointers to dynamic memory, starting with VARS and ending
 6284 1664              ; with STKEND, are updated adding BC if they are higher than the position
 6285 1664              ; in HL.
 6286 1664              ; The system variables are in no particular order except that STKEND, the first
 6287 1664              ; free location after dynamic memory must be the last encountered.
 6288 1664
 6289 1664              ;; POINTERS
 6290 1664 F5           L1664:  PUSH    AF              ; preserve accumulator.
 6291 1665 E5                   PUSH    HL              ; put pos pointer on stack.
 6292 1666 21 4B 5C             LD      HL,$5C4B        ; address VARS the first of the
 6293 1669 3E 0E                LD      A,$0E           ; fourteen variables to consider.
 6294 166B
 6295 166B              ;; PTR-NEXT
 6296 166B 5E           L166B:  LD      E,(HL)          ; fetch the low byte of the system variable.
 6297 166C 23                   INC     HL              ; advance address.
 6298 166D 56                   LD      D,(HL)          ; fetch high byte of the system variable.
 6299 166E E3                   EX      (SP),HL         ; swap pointer on stack with the variable
 6300 166F                                              ; pointer.
 6301 166F A7                   AND     A               ; prepare to subtract.
 6302 1670 ED 52                SBC     HL,DE           ; subtract variable address
 6303 1672 19                   ADD     HL,DE           ; and add back
 6304 1673 E3                   EX      (SP),HL         ; swap pos with system variable pointer
 6305 1674 30 09                JR      NC,L167F        ; forward to PTR-DONE if var before pos
 6306 1676
 6307 1676 D5                   PUSH    DE              ; save system variable address.
 6308 1677 EB                   EX      DE,HL           ; transfer to HL
 6309 1678 09                   ADD     HL,BC           ; add the offset
 6310 1679 EB                   EX      DE,HL           ; back to DE
 6311 167A 72                   LD      (HL),D          ; load high byte
 6312 167B 2B                   DEC     HL              ; move back
 6313 167C 73                   LD      (HL),E          ; load low byte
 6314 167D 23                   INC     HL              ; advance to high byte
 6315 167E D1                   POP     DE              ; restore old system variable address.
 6316 167F
 6317 167F              ;; PTR-DONE
 6318 167F 23           L167F:  INC     HL              ; address next system variable.
 6319 1680 3D                   DEC     A               ; decrease counter.
 6320 1681 20 E8                JR      NZ,L166B        ; back to PTR-NEXT if more.
 6321 1683 EB                   EX      DE,HL           ; transfer old value of STKEND to HL.
 6322 1684                                              ; Note. this has always been updated.
 6323 1684 D1                   POP     DE              ; pop the address of the position.
 6324 1685
 6325 1685 F1                   POP     AF              ; pop preserved accumulator.
 6326 1686 A7                   AND     A               ; clear carry flag preparing to subtract.
 6327 1687
 6328 1687 ED 52                SBC     HL,DE           ; subtract position from old stkend
 6329 1689 44                   LD      B,H             ; to give number of data bytes
 6330 168A 4D                   LD      C,L             ; to be moved.
 6331 168B 03                   INC     BC              ; increment as we also copy byte at old STKEND.
 6332 168C 19                   ADD     HL,DE           ; recompute old stkend.
 6333 168D EB                   EX      DE,HL           ; transfer to DE.
 6334 168E C9                   RET                     ; return.
 6335 168F
 6336 168F
 6337 168F
 6338 168F              ; -------------------
 6339 168F              ; Collect line number
 6340 168F              ; -------------------
 6341 168F              ; This routine extracts a line number, at an address that has previously
 6342 168F              ; been found using LINE-ADDR, and it is entered at LINE-NO. If it encounters
 6343 168F              ; the program 'end-marker' then the previous line is used and if that
 6344 168F              ; should also be unacceptable then zero is used as it must be a direct
 6345 168F              ; command. The program end-marker is the variables end-marker $80, or
 6346 168F              ; if variables exist, then the first character of any variable name.
 6347 168F
 6348 168F              ;; LINE-ZERO
 6349 168F 00 00        L168F:  DEFB    $00, $00        ; dummy line number used for direct commands
 6350 1691
 6351 1691
 6352 1691              ;; LINE-NO-A
 6353 1691 EB           L1691:  EX      DE,HL           ; fetch the previous line to HL and set
 6354 1692 11 8F 16             LD      DE,L168F        ; DE to LINE-ZERO should HL also fail.
 6355 1695
 6356 1695              ; -> The Entry Point.
 6357 1695
 6358 1695              ;; LINE-NO
 6359 1695 7E           L1695:  LD      A,(HL)          ; fetch the high byte - max $2F
 6360 1696 E6 C0                AND     $C0             ; mask off the invalid bits.
 6361 1698 20 F7                JR      NZ,L1691        ; to LINE-NO-A if an end-marker.
 6362 169A
 6363 169A 56                   LD      D,(HL)          ; reload the high byte.
 6364 169B 23                   INC     HL              ; advance address.
 6365 169C 5E                   LD      E,(HL)          ; pick up the low byte.
 6366 169D C9                   RET                     ; return from here.
 6367 169E
 6368 169E              ; -------------------
 6369 169E              ; Handle reserve room
 6370 169E              ; -------------------
 6371 169E              ; This is a continuation of the restart BC-SPACES
 6372 169E
 6373 169E              ;; RESERVE
 6374 169E 2A 63 5C     L169E:  LD      HL,($5C63)      ; STKBOT first location of calculator stack
 6375 16A1 2B                   DEC     HL              ; make one less than new location
 6376 16A2 CD 55 16             CALL    L1655           ; routine MAKE-ROOM creates the room.
 6377 16A5 23                   INC     HL              ; address the first new location
 6378 16A6 23                   INC     HL              ; advance to second
 6379 16A7 C1                   POP     BC              ; restore old WORKSP
 6380 16A8 ED 43 61 5C          LD      ($5C61),BC      ; system variable WORKSP was perhaps
 6381 16AC                                              ; changed by POINTERS routine.
 6382 16AC C1                   POP     BC              ; restore count for return value.
 6383 16AD EB                   EX      DE,HL           ; switch. DE = location after first new space
 6384 16AE 23                   INC     HL              ; HL now location after new space
 6385 16AF C9                   RET                     ; return.
 6386 16B0
 6387 16B0              ; ---------------------------
 6388 16B0              ; Clear various editing areas
 6389 16B0              ; ---------------------------
 6390 16B0              ; This routine sets the editing area, workspace and calculator stack
 6391 16B0              ; to their minimum configurations as at initialization and indeed this
 6392 16B0              ; routine could have been relied on to perform that task.
 6393 16B0              ; This routine uses HL only and returns with that register holding
 6394 16B0              ; WORKSP/STKBOT/STKEND though no use is made of this. The routines also
 6395 16B0              ; reset MEM to its usual place in the systems variable area should it
 6396 16B0              ; have been relocated to a FOR-NEXT variable. The main entry point
 6397 16B0              ; SET-MIN is called at the start of the MAIN-EXEC loop and prior to
 6398 16B0              ; displaying an error.
 6399 16B0
 6400 16B0              ;; SET-MIN
 6401 16B0 2A 59 5C     L16B0:  LD      HL,($5C59)      ; fetch E_LINE
 6402 16B3 36 0D                LD      (HL),$0D        ; insert carriage return
 6403 16B5 22 5B 5C             LD      ($5C5B),HL      ; make K_CUR keyboard cursor point there.
 6404 16B8 23                   INC     HL              ; next location
 6405 16B9 36 80                LD      (HL),$80        ; holds end-marker $80
 6406 16BB 23                   INC     HL              ; next location becomes
 6407 16BC 22 61 5C             LD      ($5C61),HL      ; start of WORKSP
 6408 16BF
 6409 16BF              ; This entry point is used prior to input and prior to the execution,
 6410 16BF              ; or parsing, of each statement.
 6411 16BF
 6412 16BF              ;; SET-WORK
 6413 16BF 2A 61 5C     L16BF:  LD      HL,($5C61)      ; fetch WORKSP value
 6414 16C2 22 63 5C             LD      ($5C63),HL      ; and place in STKBOT
 6415 16C5
 6416 16C5              ; This entry point is used to move the stack back to its normal place
 6417 16C5              ; after temporary relocation during line entry and also from ERROR-3
 6418 16C5
 6419 16C5              ;; SET-STK
 6420 16C5 2A 63 5C     L16C5:  LD      HL,($5C63)      ; fetch STKBOT value
 6421 16C8 22 65 5C             LD      ($5C65),HL      ; and place in STKEND.
 6422 16CB
 6423 16CB E5                   PUSH    HL              ; perhaps an obsolete entry point.
 6424 16CC 21 92 5C             LD      HL,$5C92        ; normal location of MEM-0
 6425 16CF 22 68 5C             LD      ($5C68),HL      ; is restored to system variable MEM.
 6426 16D2 E1                   POP     HL              ; saved value not required.
 6427 16D3 C9                   RET                     ; return.
 6428 16D4
 6429 16D4              ; ------------------
 6430 16D4              ; Reclaim edit-line?
 6431 16D4              ; ------------------
 6432 16D4              ; This seems to be legacy code from the ZX80/ZX81 as it is
 6433 16D4              ; not used in this ROM.
 6434 16D4              ; That task, in fact, is performed here by the dual-area routine CLEAR-SP.
 6435 16D4              ; This routine is designed to deal with something that is known to be in the
 6436 16D4              ; edit buffer and not workspace.
 6437 16D4              ; On entry, HL must point to the end of the something to be deleted.
 6438 16D4
 6439 16D4              ;; REC-EDIT
 6440 16D4 ED 5B 59 5C  L16D4:  LD      DE,($5C59)      ; fetch start of edit line from E_LINE.
 6441 16D8 C3 E5 19             JP      L19E5           ; jump forward to RECLAIM-1.
 6442 16DB
 6443 16DB              ; --------------------------
 6444 16DB              ; The Table INDEXING routine
 6445 16DB              ; --------------------------
 6446 16DB              ; This routine is used to search two-byte hash tables for a character
 6447 16DB              ; held in C, returning the address of the following offset byte.
 6448 16DB              ; if it is known that the character is in the table e.g. for priorities,
 6449 16DB              ; then the table requires no zero end-marker. If this is not known at the
 6450 16DB              ; outset then a zero end-marker is required and carry is set to signal
 6451 16DB              ; success.
 6452 16DB
 6453 16DB              ;; INDEXER-1
 6454 16DB 23           L16DB:  INC     HL              ; address the next pair of values.
 6455 16DC
 6456 16DC              ; -> The Entry Point.
 6457 16DC
 6458 16DC              ;; INDEXER
 6459 16DC 7E           L16DC:  LD      A,(HL)          ; fetch the first byte of pair
 6460 16DD A7                   AND     A               ; is it the end-marker ?
 6461 16DE C8                   RET     Z               ; return with carry reset if so.
 6462 16DF
 6463 16DF B9                   CP      C               ; is it the required character ?
 6464 16E0 23                   INC     HL              ; address next location.
 6465 16E1 20 F8                JR      NZ,L16DB        ; back to INDEXER-1 if no match.
 6466 16E3
 6467 16E3 37                   SCF                     ; else set the carry flag.
 6468 16E4 C9                   RET                     ; return with carry set
 6469 16E5
 6470 16E5              ; --------------------------------
 6471 16E5              ; The Channel and Streams Routines
 6472 16E5              ; --------------------------------
 6473 16E5              ; A channel is an input/output route to a hardware device
 6474 16E5              ; and is identified to the system by a single letter e.g. 'K' for
 6475 16E5              ; the keyboard. A channel can have an input and output route
 6476 16E5              ; associated with it in which case it is bi-directional like
 6477 16E5              ; the keyboard. Others like the upper screen 'S' are output
 6478 16E5              ; only and the input routine usually points to a report message.
 6479 16E5              ; Channels 'K' and 'S' are system channels and it would be inappropriate
 6480 16E5              ; to close the associated streams so a mechanism is provided to
 6481 16E5              ; re-attach them. When the re-attachment is no longer required, then
 6482 16E5              ; closing these streams resets them as at initialization.
 6483 16E5              ; Early adverts said that the network and RS232 were in this ROM.
 6484 16E5              ; Channels 'N' and 'B' are user channels and have been removed successfully
 6485 16E5              ; if, as seems possible, they existed.
 6486 16E5              ; Ironically the tape streamer is not accessed through streams and
 6487 16E5              ; channels.
 6488 16E5              ; Early demonstrations of the Spectrum showed a single microdrive being
 6489 16E5              ; controlled by the main ROM.
 6490 16E5
 6491 16E5              ; ---------------------
 6492 16E5              ; THE 'CLOSE #' COMMAND
 6493 16E5              ; ---------------------
 6494 16E5              ;   This command allows streams to be closed after use.
 6495 16E5              ;   Any temporary memory areas used by the stream would be reclaimed and
 6496 16E5              ;   finally flags set or reset if necessary.
 6497 16E5
 6498 16E5              ;; CLOSE
 6499 16E5 CD 1E 17     L16E5:  CALL    L171E           ; routine STR-DATA fetches parameter
 6500 16E8                                              ; from calculator stack and gets the
 6501 16E8                                              ; existing STRMS data pointer address in HL
 6502 16E8                                              ; and stream offset from CHANS in BC.
 6503 16E8
 6504 16E8                                              ; Note. this offset could be zero if the
 6505 16E8                                              ; stream is already closed. A check for this
 6506 16E8                                              ; should occur now and an error should be
 6507 16E8                                              ; generated, for example,
 6508 16E8                                              ; Report S 'Stream status closed'.
 6509 16E8
 6510 16E8 CD 01 17             CALL    L1701           ; routine CLOSE-2 would perform any actions
 6511 16EB                                              ; peculiar to that stream without disturbing
 6512 16EB                                              ; data pointer to STRMS entry in HL.
 6513 16EB
 6514 16EB 01 00 00             LD      BC,$0000        ; the stream is to be blanked.
 6515 16EE 11 E2 A3             LD      DE,$A3E2        ; the number of bytes from stream 4, $5C1E,
 6516 16F1                                              ; to $10000
 6517 16F1 EB                   EX      DE,HL           ; transfer offset to HL, STRMS data pointer
 6518 16F2                                              ; to DE.
 6519 16F2 19                   ADD     HL,DE           ; add the offset to the data pointer.
 6520 16F3 38 07                JR      C,L16FC         ; forward to CLOSE-1 if a non-system stream.
 6521 16F5                                              ; i.e. higher than 3.
 6522 16F5
 6523 16F5              ; proceed with a negative result.
 6524 16F5
 6525 16F5 01 D4 15             LD      BC,L15C6 + 14   ; prepare the address of the byte after
 6526 16F8                                              ; the initial stream data in ROM. ($15D4)
 6527 16F8 09                   ADD     HL,BC           ; index into the data table with negative value.
 6528 16F9 4E                   LD      C,(HL)          ; low byte to C
 6529 16FA 23                   INC     HL              ; address next.
 6530 16FB 46                   LD      B,(HL)          ; high byte to B.
 6531 16FC
 6532 16FC              ;   and for streams 0 - 3 just enter the initial data back into the STRMS entry
 6533 16FC              ;   streams 0 - 2 can't be closed as they are shared by the operating system.
 6534 16FC              ;   -> for streams 4 - 15 then blank the entry.
 6535 16FC
 6536 16FC              ;; CLOSE-1
 6537 16FC EB           L16FC:  EX      DE,HL           ; address of stream to HL.
 6538 16FD 71                   LD      (HL),C          ; place zero (or low byte).
 6539 16FE 23                   INC     HL              ; next address.
 6540 16FF 70                   LD      (HL),B          ; place zero (or high byte).
 6541 1700 C9                   RET                     ; return.
 6542 1701
 6543 1701              ; ------------------------
 6544 1701              ; THE 'CLOSE-2' SUBROUTINE
 6545 1701              ; ------------------------
 6546 1701              ;   There is not much point in coming here.
 6547 1701              ;   The purpose was once to find the offset to a special closing routine,
 6548 1701              ;   in this ROM and within 256 bytes of the close stream look up table that
 6549 1701              ;   would reclaim any buffers associated with a stream. At least one has been
 6550 1701              ;   removed.
 6551 1701              ;   Any attempt to CLOSE streams $00 to $04, without first opening the stream,
 6552 1701              ;   will lead to either a system restart or the production of a strange report.
 6553 1701              ;   credit: Martin Wren-Hilton 1982.
 6554 1701
 6555 1701              ;; CLOSE-2
 6556 1701 E5           L1701:  PUSH    HL              ; * save address of stream data pointer
 6557 1702                                              ; in STRMS on the machine stack.
 6558 1702 2A 4F 5C             LD      HL,($5C4F)      ; fetch CHANS address to HL
 6559 1705 09                   ADD     HL,BC           ; add the offset to address the second
 6560 1706                                              ; byte of the output routine hopefully.
 6561 1706 23                   INC     HL              ; step past
 6562 1707 23                   INC     HL              ; the input routine.
 6563 1708
 6564 1708              ;    Note. When the Sinclair Interface1 is fitted then an instruction fetch
 6565 1708              ;    on the next address pages this ROM out and the shadow ROM in.
 6566 1708
 6567 1708              ;; ROM_TRAP
 6568 1708 23           L1708:  INC     HL              ; to address channel's letter
 6569 1709 4E                   LD      C,(HL)          ; pick it up in C.
 6570 170A                                              ; Note. but if stream is already closed we
 6571 170A                                              ; get the value $10 (the byte preceding 'K').
 6572 170A
 6573 170A EB                   EX      DE,HL           ; save the pointer to the letter in DE.
 6574 170B
 6575 170B              ;   Note. The string pointer is saved but not used!!
 6576 170B
 6577 170B 21 16 17             LD      HL,L1716        ; address: cl-str-lu in ROM.
 6578 170E CD DC 16             CALL    L16DC           ; routine INDEXER uses the code to get
 6579 1711                                              ; the 8-bit offset from the current point to
 6580 1711                                              ; the address of the closing routine in ROM.
 6581 1711                                              ; Note. it won't find $10 there!
 6582 1711
 6583 1711 4E                   LD      C,(HL)          ; transfer the offset to C.
 6584 1712 06 00                LD      B,$00           ; prepare to add.
 6585 1714 09                   ADD     HL,BC           ; add offset to point to the address of the
 6586 1715                                              ; routine that closes the stream.
 6587 1715                                              ; (and presumably removes any buffers that
 6588 1715                                              ; are associated with it.)
 6589 1715 E9                   JP      (HL)            ; jump to that routine.
 6590 1716
 6591 1716              ; --------------------------------
 6592 1716              ; THE 'CLOSE STREAM LOOK-UP' TABLE
 6593 1716              ; --------------------------------
 6594 1716              ;   This table contains an entry for a letter found in the CHANS area.
 6595 1716              ;   followed by an 8-bit displacement, from that byte's address in the
 6596 1716              ;   table to the routine that performs any ancillary actions associated
 6597 1716              ;   with closing the stream of that channel.
 6598 1716              ;   The table doesn't require a zero end-marker as the letter has been
 6599 1716              ;   picked up from a channel that has an open stream.
 6600 1716
 6601 1716              ;; cl-str-lu
 6602 1716 4B 05        L1716:  DEFB    'K', L171C-$-1  ; offset 5 to CLOSE-STR
 6603 1718 53 03                DEFB    'S', L171C-$-1  ; offset 3 to CLOSE-STR
 6604 171A 50 01                DEFB    'P', L171C-$-1  ; offset 1 to CLOSE-STR
 6605 171C
 6606 171C
 6607 171C              ; ------------------------------
 6608 171C              ; THE 'CLOSE STREAM' SUBROUTINES
 6609 171C              ; ------------------------------
 6610 171C              ; The close stream routines in fact have no ancillary actions to perform
 6611 171C              ; which is not surprising with regard to 'K' and 'S'.
 6612 171C
 6613 171C              ;; CLOSE-STR
 6614 171C E1           L171C:  POP     HL              ; * now just restore the stream data pointer
 6615 171D C9                   RET                     ; in STRMS and return.
 6616 171E
 6617 171E              ; -----------
 6618 171E              ; Stream data
 6619 171E              ; -----------
 6620 171E              ; This routine finds the data entry in the STRMS area for the specified
 6621 171E              ; stream which is passed on the calculator stack. It returns with HL
 6622 171E              ; pointing to this system variable and BC holding a displacement from
 6623 171E              ; the CHANS area to the second byte of the stream's channel. If BC holds
 6624 171E              ; zero, then that signifies that the stream is closed.
 6625 171E
 6626 171E              ;; STR-DATA
 6627 171E CD 94 1E     L171E:  CALL    L1E94           ; routine FIND-INT1 fetches parameter to A
 6628 1721 FE 10                CP      $10             ; is it less than 16d ?
 6629 1723 38 02                JR      C,L1727         ; skip forward to STR-DATA1 if so.
 6630 1725
 6631 1725              ;; REPORT-Ob
 6632 1725 CF           L1725:  RST     08H             ; ERROR-1
 6633 1726 17                   DEFB    $17             ; Error Report: Invalid stream
 6634 1727
 6635 1727              ;; STR-DATA1
 6636 1727 C6 03        L1727:  ADD     A,$03           ; add the offset for 3 system streams.
 6637 1729                                              ; range 00 - 15d becomes 3 - 18d.
 6638 1729 07                   RLCA                    ; double as there are two bytes per
 6639 172A                                              ; stream - now 06 - 36d
 6640 172A 21 10 5C             LD      HL,$5C10        ; address STRMS - the start of the streams
 6641 172D                                              ; data area in system variables.
 6642 172D 4F                   LD      C,A             ; transfer the low byte to A.
 6643 172E 06 00                LD      B,$00           ; prepare to add offset.
 6644 1730 09                   ADD     HL,BC           ; add to address the data entry in STRMS.
 6645 1731
 6646 1731              ; the data entry itself contains an offset from CHANS to the address of the
 6647 1731              ; stream
 6648 1731
 6649 1731 4E                   LD      C,(HL)          ; low byte of displacement to C.
 6650 1732 23                   INC     HL              ; address next.
 6651 1733 46                   LD      B,(HL)          ; high byte of displacement to B.
 6652 1734 2B                   DEC     HL              ; step back to leave HL pointing to STRMS
 6653 1735                                              ; data entry.
 6654 1735 C9                   RET                     ; return with CHANS displacement in BC
 6655 1736                                              ; and address of stream data entry in HL.
 6656 1736
 6657 1736              ; --------------------
 6658 1736              ; Handle OPEN# command
 6659 1736              ; --------------------
 6660 1736              ; Command syntax example: OPEN #5,"s"
 6661 1736              ; On entry the channel code entry is on the calculator stack with the next
 6662 1736              ; value containing the stream identifier. They have to swapped.
 6663 1736
 6664 1736              ;; OPEN
 6665 1736 EF           L1736:  RST     28H             ;; FP-CALC    ;s,c.
 6666 1737 01                   DEFB    $01             ;;exchange    ;c,s.
 6667 1738 38                   DEFB    $38             ;;end-calc
 6668 1739
 6669 1739 CD 1E 17             CALL    L171E           ; routine STR-DATA fetches the stream off
 6670 173C                                              ; the stack and returns with the CHANS
 6671 173C                                              ; displacement in BC and HL addressing
 6672 173C                                              ; the STRMS data entry.
 6673 173C 78                   LD      A,B             ; test for zero which
 6674 173D B1                   OR      C               ; indicates the stream is closed.
 6675 173E 28 16                JR      Z,L1756         ; skip forward to OPEN-1 if so.
 6676 1740
 6677 1740              ; if it is a system channel then it can re-attached.
 6678 1740
 6679 1740 EB                   EX      DE,HL           ; save STRMS address in DE.
 6680 1741 2A 4F 5C             LD      HL,($5C4F)      ; fetch CHANS.
 6681 1744 09                   ADD     HL,BC           ; add the offset to address the second
 6682 1745                                              ; byte of the channel.
 6683 1745 23                   INC     HL              ; skip over the
 6684 1746 23                   INC     HL              ; input routine.
 6685 1747 23                   INC     HL              ; and address the letter.
 6686 1748 7E                   LD      A,(HL)          ; pick up the letter.
 6687 1749 EB                   EX      DE,HL           ; save letter pointer and bring back
 6688 174A                                              ; the STRMS pointer.
 6689 174A
 6690 174A FE 4B                CP      $4B             ; is it 'K' ?
 6691 174C 28 08                JR      Z,L1756         ; forward to OPEN-1 if so
 6692 174E
 6693 174E FE 53                CP      $53             ; is it 'S' ?
 6694 1750 28 04                JR      Z,L1756         ; forward to OPEN-1 if so
 6695 1752
 6696 1752 FE 50                CP      $50             ; is it 'P' ?
 6697 1754 20 CF                JR      NZ,L1725        ; back to REPORT-Ob if not.
 6698 1756                                              ; to report 'Invalid stream'.
 6699 1756
 6700 1756              ; continue if one of the upper-case letters was found.
 6701 1756              ; and rejoin here from above if stream was closed.
 6702 1756
 6703 1756              ;; OPEN-1
 6704 1756 CD 5D 17     L1756:  CALL    L175D           ; routine OPEN-2 opens the stream.
 6705 1759
 6706 1759              ; it now remains to update the STRMS variable.
 6707 1759
 6708 1759 73                   LD      (HL),E          ; insert or overwrite the low byte.
 6709 175A 23                   INC     HL              ; address high byte in STRMS.
 6710 175B 72                   LD      (HL),D          ; insert or overwrite the high byte.
 6711 175C C9                   RET                     ; return.
 6712 175D
 6713 175D              ; -----------------
 6714 175D              ; OPEN-2 Subroutine
 6715 175D              ; -----------------
 6716 175D              ; There is some point in coming here as, as well as once creating buffers,
 6717 175D              ; this routine also sets flags.
 6718 175D
 6719 175D              ;; OPEN-2
 6720 175D E5           L175D:  PUSH    HL              ; * save the STRMS data entry pointer.
 6721 175E CD F1 2B             CALL    L2BF1           ; routine STK-FETCH now fetches the
 6722 1761                                              ; parameters of the channel string.
 6723 1761                                              ; start in DE, length in BC.
 6724 1761
 6725 1761 78                   LD      A,B             ; test that it is not
 6726 1762 B1                   OR      C               ; the null string.
 6727 1763 20 02                JR      NZ,L1767        ; skip forward to OPEN-3 with 1 character
 6728 1765                                              ; or more!
 6729 1765
 6730 1765              ;; REPORT-Fb
 6731 1765 CF           L1765:  RST     08H             ; ERROR-1
 6732 1766 0E                   DEFB    $0E             ; Error Report: Invalid file name
 6733 1767
 6734 1767              ;; OPEN-3
 6735 1767 C5           L1767:  PUSH    BC              ; save the length of the string.
 6736 1768 1A                   LD      A,(DE)          ; pick up the first character.
 6737 1769                                              ; Note. There can be more than one character.
 6738 1769 E6 DF                AND     $DF             ; make it upper-case.
 6739 176B 4F                   LD      C,A             ; place it in C.
 6740 176C 21 7A 17             LD      HL,L177A        ; address: op-str-lu is loaded.
 6741 176F CD DC 16             CALL    L16DC           ; routine INDEXER will search for letter.
 6742 1772 30 F1                JR      NC,L1765        ; back to REPORT-F if not found
 6743 1774                                              ; 'Invalid filename'
 6744 1774
 6745 1774 4E                   LD      C,(HL)          ; fetch the displacement to opening routine.
 6746 1775 06 00                LD      B,$00           ; prepare to add.
 6747 1777 09                   ADD     HL,BC           ; now form address of opening routine.
 6748 1778 C1                   POP     BC              ; restore the length of string.
 6749 1779 E9                   JP      (HL)            ; now jump forward to the relevant routine.
 6750 177A
 6751 177A              ; -------------------------
 6752 177A              ; OPEN stream look-up table
 6753 177A              ; -------------------------
 6754 177A              ; The open stream look-up table consists of matched pairs.
 6755 177A              ; The channel letter is followed by an 8-bit displacement to the
 6756 177A              ; associated stream-opening routine in this ROM.
 6757 177A              ; The table requires a zero end-marker as the letter has been
 6758 177A              ; provided by the user and not the operating system.
 6759 177A
 6760 177A              ;; op-str-lu
 6761 177A 4B 06        L177A:  DEFB    'K', L1781-$-1  ; $06 offset to OPEN-K
 6762 177C 53 08                DEFB    'S', L1785-$-1  ; $08 offset to OPEN-S
 6763 177E 50 0A                DEFB    'P', L1789-$-1  ; $0A offset to OPEN-P
 6764 1780
 6765 1780 00                   DEFB    $00             ; end-marker.
 6766 1781
 6767 1781              ; ----------------------------
 6768 1781              ; The Stream Opening Routines.
 6769 1781              ; ----------------------------
 6770 1781              ; These routines would have opened any buffers associated with the stream
 6771 1781              ; before jumping forward to OPEN-END with the displacement value in E
 6772 1781              ; and perhaps a modified value in BC. The strange pathing does seem to
 6773 1781              ; provide for flexibility in this respect.
 6774 1781              ;
 6775 1781              ; There is no need to open the printer buffer as it is there already
 6776 1781              ; even if you are still saving up for a ZX Printer or have moved onto
 6777 1781              ; something bigger. In any case it would have to be created after
 6778 1781              ; the system variables but apart from that it is a simple task
 6779 1781              ; and all but one of the ROM routines can handle a buffer in that position.
 6780 1781              ; (PR-ALL-6 would require an extra 3 bytes of code).
 6781 1781              ; However it wouldn't be wise to have two streams attached to the ZX Printer
 6782 1781              ; as you can now, so one assumes that if PR_CC_hi was non-zero then
 6783 1781              ; the OPEN-P routine would have refused to attach a stream if another
 6784 1781              ; stream was attached.
 6785 1781
 6786 1781              ; Something of significance is being passed to these ghost routines in the
 6787 1781              ; second character. Strings 'RB', 'RT' perhaps or a drive/station number.
 6788 1781              ; The routine would have to deal with that and exit to OPEN_END with BC
 6789 1781              ; containing $0001 or more likely there would be an exit within the routine.
 6790 1781              ; Anyway doesn't matter, these routines are long gone.
 6791 1781
 6792 1781              ; -----------------
 6793 1781              ; OPEN-K Subroutine
 6794 1781              ; -----------------
 6795 1781              ; Open Keyboard stream.
 6796 1781
 6797 1781              ;; OPEN-K
 6798 1781 1E 01        L1781:  LD      E,$01           ; 01 is offset to second byte of channel 'K'.
 6799 1783 18 06                JR      L178B           ; forward to OPEN-END
 6800 1785
 6801 1785              ; -----------------
 6802 1785              ; OPEN-S Subroutine
 6803 1785              ; -----------------
 6804 1785              ; Open Screen stream.
 6805 1785
 6806 1785              ;; OPEN-S
 6807 1785 1E 06        L1785:  LD      E,$06           ; 06 is offset to 2nd byte of channel 'S'
 6808 1787 18 02                JR      L178B           ; to OPEN-END
 6809 1789
 6810 1789              ; -----------------
 6811 1789              ; OPEN-P Subroutine
 6812 1789              ; -----------------
 6813 1789              ; Open Printer stream.
 6814 1789
 6815 1789              ;; OPEN-P
 6816 1789 1E 10        L1789:  LD      E,$10           ; 16d is offset to 2nd byte of channel 'P'
 6817 178B
 6818 178B              ;; OPEN-END
 6819 178B 0B           L178B:  DEC     BC              ; the stored length of 'K','S','P' or
 6820 178C                                              ; whatever is now tested. ??
 6821 178C 78                   LD      A,B             ; test now if initial or residual length
 6822 178D B1                   OR      C               ; is one character.
 6823 178E 20 D5                JR      NZ,L1765        ; to REPORT-Fb 'Invalid file name' if not.
 6824 1790
 6825 1790 57                   LD      D,A             ; load D with zero to form the displacement
 6826 1791                                              ; in the DE register.
 6827 1791 E1                   POP     HL              ; * restore the saved STRMS pointer.
 6828 1792 C9                   RET                     ; return to update STRMS entry thereby
 6829 1793                                              ; signaling stream is open.
 6830 1793
 6831 1793              ; ----------------------------------------
 6832 1793              ; Handle CAT, ERASE, FORMAT, MOVE commands
 6833 1793              ; ----------------------------------------
 6834 1793              ; These just generate an error report as the ROM is 'incomplete'.
 6835 1793              ;
 6836 1793              ; Luckily this provides a mechanism for extending these in a shadow ROM
 6837 1793              ; but without the powerful mechanisms set up in this ROM.
 6838 1793              ; An instruction fetch on $0008 may page in a peripheral ROM,
 6839 1793              ; e.g. the Sinclair Interface 1 ROM, to handle these commands.
 6840 1793              ; However that wasn't the plan.
 6841 1793              ; Development of this ROM continued for another three months until the cost
 6842 1793              ; of replacing it and the manual became unfeasible.
 6843 1793              ; The ultimate power of channels and streams died at birth.
 6844 1793
 6845 1793              ;; CAT-ETC
 6846 1793 18 90        L1793:  JR      L1725           ; to REPORT-Ob
 6847 1795
 6848 1795              ; -----------------
 6849 1795              ; Perform AUTO-LIST
 6850 1795              ; -----------------
 6851 1795              ; This produces an automatic listing in the upper screen.
 6852 1795
 6853 1795              ;; AUTO-LIST
 6854 1795 ED 73 3F 5C  L1795:  LD      ($5C3F),SP      ; save stack pointer in LIST_SP
 6855 1799 FD 36 02 10          LD      (IY+$02),$10    ; update TV_FLAG set bit 3
 6856 179D CD AF 0D             CALL    L0DAF           ; routine CL-ALL.
 6857 17A0 FD CB 02 C6          SET     0,(IY+$02)      ; update TV_FLAG  - signal lower screen in use
 6858 17A4
 6859 17A4 FD 46 31             LD      B,(IY+$31)      ; fetch DF_SZ to B.
 6860 17A7 CD 44 0E             CALL    L0E44           ; routine CL-LINE clears lower display
 6861 17AA                                              ; preserving B.
 6862 17AA FD CB 02 86          RES     0,(IY+$02)      ; update TV_FLAG  - signal main screen in use
 6863 17AE FD CB 30 C6          SET     0,(IY+$30)      ; update FLAGS2 - signal will be necessary to
 6864 17B2                                              ; clear main screen.
 6865 17B2 2A 49 5C             LD      HL,($5C49)      ; fetch E_PPC current edit line to HL.
 6866 17B5 ED 5B 6C 5C          LD      DE,($5C6C)      ; fetch S_TOP to DE, the current top line
 6867 17B9                                              ; (initially zero)
 6868 17B9 A7                   AND     A               ; prepare for true subtraction.
 6869 17BA ED 52                SBC     HL,DE           ; subtract and
 6870 17BC 19                   ADD     HL,DE           ; add back.
 6871 17BD 38 22                JR      C,L17E1         ; to AUTO-L-2 if S_TOP higher than E_PPC
 6872 17BF                                              ; to set S_TOP to E_PPC
 6873 17BF
 6874 17BF D5                   PUSH    DE              ; save the top line number.
 6875 17C0 CD 6E 19             CALL    L196E           ; routine LINE-ADDR gets address of E_PPC.
 6876 17C3 11 C0 02             LD      DE,$02C0        ; prepare known number of characters in
 6877 17C6                                              ; the default upper screen.
 6878 17C6 EB                   EX      DE,HL           ; offset to HL, program address to DE.
 6879 17C7 ED 52                SBC     HL,DE           ; subtract high value from low to obtain
 6880 17C9                                              ; negated result used in addition.
 6881 17C9 E3                   EX      (SP),HL         ; swap result with top line number on stack.
 6882 17CA CD 6E 19             CALL    L196E           ; routine LINE-ADDR  gets address of that
 6883 17CD                                              ; top line in HL and next line in DE.
 6884 17CD C1                   POP     BC              ; restore the result to balance stack.
 6885 17CE
 6886 17CE              ;; AUTO-L-1
 6887 17CE C5           L17CE:  PUSH    BC              ; save the result.
 6888 17CF CD B8 19             CALL    L19B8           ; routine NEXT-ONE gets address in HL of
 6889 17D2                                              ; line after auto-line (in DE).
 6890 17D2 C1                   POP     BC              ; restore result.
 6891 17D3 09                   ADD     HL,BC           ; compute back.
 6892 17D4 38 0E                JR      C,L17E4         ; to AUTO-L-3 if line 'should' appear
 6893 17D6
 6894 17D6 EB                   EX      DE,HL           ; address of next line to HL.
 6895 17D7 56                   LD      D,(HL)          ; get line
 6896 17D8 23                   INC     HL              ; number
 6897 17D9 5E                   LD      E,(HL)          ; in DE.
 6898 17DA 2B                   DEC     HL              ; adjust back to start.
 6899 17DB ED 53 6C 5C          LD      ($5C6C),DE      ; update S_TOP.
 6900 17DF 18 ED                JR      L17CE           ; to AUTO-L-1 until estimate reached.
 6901 17E1
 6902 17E1              ; ---
 6903 17E1
 6904 17E1              ; the jump was to here if S_TOP was greater than E_PPC
 6905 17E1
 6906 17E1              ;; AUTO-L-2
 6907 17E1 22 6C 5C     L17E1:  LD      ($5C6C),HL      ; make S_TOP the same as E_PPC.
 6908 17E4
 6909 17E4              ; continue here with valid starting point from above or good estimate
 6910 17E4              ; from computation
 6911 17E4
 6912 17E4              ;; AUTO-L-3
 6913 17E4 2A 6C 5C     L17E4:  LD      HL,($5C6C)      ; fetch S_TOP line number to HL.
 6914 17E7 CD 6E 19             CALL    L196E           ; routine LINE-ADDR gets address in HL.
 6915 17EA                                              ; address of next in DE.
 6916 17EA 28 01                JR      Z,L17ED         ; to AUTO-L-4 if line exists.
 6917 17EC
 6918 17EC EB                   EX      DE,HL           ; else use address of next line.
 6919 17ED
 6920 17ED              ;; AUTO-L-4
 6921 17ED CD 33 18     L17ED:  CALL    L1833           ; routine LIST-ALL                >>>
 6922 17F0
 6923 17F0              ; The return will be to here if no scrolling occurred
 6924 17F0
 6925 17F0 FD CB 02 A6          RES     4,(IY+$02)      ; update TV_FLAG  - signal no auto listing.
 6926 17F4 C9                   RET                     ; return.
 6927 17F5
 6928 17F5              ; ------------
 6929 17F5              ; Handle LLIST
 6930 17F5              ; ------------
 6931 17F5              ; A short form of LIST #3. The listing goes to stream 3 - default printer.
 6932 17F5
 6933 17F5              ;; LLIST
 6934 17F5 3E 03        L17F5:  LD      A,$03           ; the usual stream for ZX Printer
 6935 17F7 18 02                JR      L17FB           ; forward to LIST-1
 6936 17F9
 6937 17F9              ; -----------
 6938 17F9              ; Handle LIST
 6939 17F9              ; -----------
 6940 17F9              ; List to any stream.
 6941 17F9              ; Note. While a starting line can be specified it is
 6942 17F9              ; not possible to specify an end line.
 6943 17F9              ; Just listing a line makes it the current edit line.
 6944 17F9
 6945 17F9              ;; LIST
 6946 17F9 3E 02        L17F9:  LD      A,$02           ; default is stream 2 - the upper screen.
 6947 17FB
 6948 17FB              ;; LIST-1
 6949 17FB FD 36 02 00  L17FB:  LD      (IY+$02),$00    ; the TV_FLAG is initialized with bit 0 reset
 6950 17FF                                              ; indicating upper screen in use.
 6951 17FF CD 30 25             CALL    L2530           ; routine SYNTAX-Z - checking syntax ?
 6952 1802 C4 01 16             CALL    NZ,L1601        ; routine CHAN-OPEN if in run-time.
 6953 1805
 6954 1805 DF                   RST     18H             ; GET-CHAR
 6955 1806 CD 70 20             CALL    L2070           ; routine STR-ALTER will alter if '#'.
 6956 1809 38 14                JR      C,L181F         ; forward to LIST-4 not a '#' .
 6957 180B
 6958 180B
 6959 180B DF                   RST     18H             ; GET-CHAR
 6960 180C FE 3B                CP      $3B             ; is it ';' ?
 6961 180E 28 04                JR      Z,L1814         ; skip to LIST-2 if so.
 6962 1810
 6963 1810 FE 2C                CP      $2C             ; is it ',' ?
 6964 1812 20 06                JR      NZ,L181A        ; forward to LIST-3 if neither separator.
 6965 1814
 6966 1814              ; we have, say,  LIST #15, and a number must follow the separator.
 6967 1814
 6968 1814              ;; LIST-2
 6969 1814 E7           L1814:  RST     20H             ; NEXT-CHAR
 6970 1815 CD 82 1C             CALL    L1C82           ; routine EXPT-1NUM
 6971 1818 18 08                JR      L1822           ; forward to LIST-5
 6972 181A
 6973 181A              ; ---
 6974 181A
 6975 181A              ; the branch was here with just LIST #3 etc.
 6976 181A
 6977 181A              ;; LIST-3
 6978 181A CD E6 1C     L181A:  CALL    L1CE6           ; routine USE-ZERO
 6979 181D 18 03                JR      L1822           ; forward to LIST-5
 6980 181F
 6981 181F              ; ---
 6982 181F
 6983 181F              ; the branch was here with LIST
 6984 181F
 6985 181F              ;; LIST-4
 6986 181F CD DE 1C     L181F:  CALL    L1CDE           ; routine FETCH-NUM checks if a number
 6987 1822                                              ; follows else uses zero.
 6988 1822
 6989 1822              ;; LIST-5
 6990 1822 CD EE 1B     L1822:  CALL    L1BEE           ; routine CHECK-END quits if syntax OK >>>
 6991 1825
 6992 1825 CD 99 1E             CALL    L1E99           ; routine FIND-INT2 fetches the number
 6993 1828                                              ; from the calculator stack in run-time.
 6994 1828 78                   LD      A,B             ; fetch high byte of line number and
 6995 1829 E6 3F                AND     $3F             ; make less than $40 so that NEXT-ONE
 6996 182B                                              ; (from LINE-ADDR) doesn't lose context.
 6997 182B                                              ; Note. this is not satisfactory and the typo
 6998 182B                                              ; LIST 20000 will list an entirely different
 6999 182B                                              ; section than LIST 2000. Such typos are not
 7000 182B                                              ; available for checking if they are direct
 7001 182B                                              ; commands.
 7002 182B
 7003 182B 67                   LD      H,A             ; transfer the modified
 7004 182C 69                   LD      L,C             ; line number to HL.
 7005 182D 22 49 5C             LD      ($5C49),HL      ; update E_PPC to new line number.
 7006 1830 CD 6E 19             CALL    L196E           ; routine LINE-ADDR gets the address of the
 7007 1833                                              ; line.
 7008 1833
 7009 1833              ; This routine is called from AUTO-LIST
 7010 1833
 7011 1833              ;; LIST-ALL
 7012 1833 1E 01        L1833:  LD      E,$01           ; signal current line not yet printed
 7013 1835
 7014 1835              ;; LIST-ALL-2
 7015 1835 CD 55 18     L1835:  CALL    L1855           ; routine OUT-LINE outputs a BASIC line
 7016 1838                                              ; using PRINT-OUT and makes an early return
 7017 1838                                              ; when no more lines to print. >>>
 7018 1838
 7019 1838 D7                   RST     10H             ; PRINT-A prints the carriage return (in A)
 7020 1839
 7021 1839 FD CB 02 66          BIT     4,(IY+$02)      ; test TV_FLAG  - automatic listing ?
 7022 183D 28 F6                JR      Z,L1835         ; back to LIST-ALL-2 if not
 7023 183F                                              ; (loop exit is via OUT-LINE)
 7024 183F
 7025 183F              ; continue here if an automatic listing required.
 7026 183F
 7027 183F 3A 6B 5C             LD      A,($5C6B)       ; fetch DF_SZ lower display file size.
 7028 1842 FD 96 4F             SUB     (IY+$4F)        ; subtract S_POSN_hi ithe current line number.
 7029 1845 20 EE                JR      NZ,L1835        ; back to LIST-ALL-2 if upper screen not full.
 7030 1847
 7031 1847 AB                   XOR     E               ; A contains zero, E contains one if the
 7032 1848                                              ; current edit line has not been printed
 7033 1848                                              ; or zero if it has (from OUT-LINE).
 7034 1848 C8                   RET     Z               ; return if the screen is full and the line
 7035 1849                                              ; has been printed.
 7036 1849
 7037 1849              ; continue with automatic listings if the screen is full and the current
 7038 1849              ; edit line is missing. OUT-LINE will scroll automatically.
 7039 1849
 7040 1849 E5                   PUSH    HL              ; save the pointer address.
 7041 184A D5                   PUSH    DE              ; save the E flag.
 7042 184B 21 6C 5C             LD      HL,$5C6C        ; fetch S_TOP the rough estimate.
 7043 184E CD 0F 19             CALL    L190F           ; routine LN-FETCH updates S_TOP with
 7044 1851                                              ; the number of the next line.
 7045 1851 D1                   POP     DE              ; restore the E flag.
 7046 1852 E1                   POP     HL              ; restore the address of the next line.
 7047 1853 18 E0                JR      L1835           ; back to LIST-ALL-2.
 7048 1855
 7049 1855              ; ------------------------
 7050 1855              ; Print a whole BASIC line
 7051 1855              ; ------------------------
 7052 1855              ; This routine prints a whole BASIC line and it is called
 7053 1855              ; from LIST-ALL to output the line to current channel
 7054 1855              ; and from ED-EDIT to 'sprint' the line to the edit buffer.
 7055 1855
 7056 1855              ;; OUT-LINE
 7057 1855 ED 4B 49 5C  L1855:  LD      BC,($5C49)      ; fetch E_PPC the current line which may be
 7058 1859                                              ; unchecked and not exist.
 7059 1859 CD 80 19             CALL    L1980           ; routine CP-LINES finds match or line after.
 7060 185C 16 3E                LD      D,$3E           ; prepare cursor '>' in D.
 7061 185E 28 05                JR      Z,L1865         ; to OUT-LINE1 if matched or line after.
 7062 1860
 7063 1860 11 00 00             LD      DE,$0000        ; put zero in D, to suppress line cursor.
 7064 1863 CB 13                RL      E               ; pick up carry in E if line before current
 7065 1865                                              ; leave E zero if same or after.
 7066 1865
 7067 1865              ;; OUT-LINE1
 7068 1865 FD 73 2D     L1865:  LD      (IY+$2D),E      ; save flag in BREG which is spare.
 7069 1868 7E                   LD      A,(HL)          ; get high byte of line number.
 7070 1869 FE 40                CP      $40             ; is it too high ($2F is maximum possible) ?
 7071 186B C1                   POP     BC              ; drop the return address and
 7072 186C D0                   RET     NC              ; make an early return if so >>>
 7073 186D
 7074 186D C5                   PUSH    BC              ; save return address
 7075 186E CD 28 1A             CALL    L1A28           ; routine OUT-NUM-2 to print addressed number
 7076 1871                                              ; with leading space.
 7077 1871 23                   INC     HL              ; skip low number byte.
 7078 1872 23                   INC     HL              ; and the two
 7079 1873 23                   INC     HL              ; length bytes.
 7080 1874 FD CB 01 86          RES     0,(IY+$01)      ; update FLAGS - signal leading space required.
 7081 1878 7A                   LD      A,D             ; fetch the cursor.
 7082 1879 A7                   AND     A               ; test for zero.
 7083 187A 28 05                JR      Z,L1881         ; to OUT-LINE3 if zero.
 7084 187C
 7085 187C
 7086 187C D7                   RST     10H             ; PRINT-A prints '>' the current line cursor.
 7087 187D
 7088 187D              ; this entry point is called from ED-COPY
 7089 187D
 7090 187D              ;; OUT-LINE2
 7091 187D FD CB 01 C6  L187D:  SET     0,(IY+$01)      ; update FLAGS - suppress leading space.
 7092 1881
 7093 1881              ;; OUT-LINE3
 7094 1881 D5           L1881:  PUSH    DE              ; save flag E for a return value.
 7095 1882 EB                   EX      DE,HL           ; save HL address in DE.
 7096 1883 FD CB 30 96          RES     2,(IY+$30)      ; update FLAGS2 - signal NOT in QUOTES.
 7097 1887
 7098 1887 21 3B 5C             LD      HL,$5C3B        ; point to FLAGS.
 7099 188A CB 96                RES     2,(HL)          ; signal 'K' mode. (starts before keyword)
 7100 188C FD CB 37 6E          BIT     5,(IY+$37)      ; test FLAGX - input mode ?
 7101 1890 28 02                JR      Z,L1894         ; forward to OUT-LINE4 if not.
 7102 1892
 7103 1892 CB D6                SET     2,(HL)          ; signal 'L' mode. (used for input)
 7104 1894
 7105 1894              ;; OUT-LINE4
 7106 1894 2A 5F 5C     L1894:  LD      HL,($5C5F)      ; fetch X_PTR - possibly the error pointer
 7107 1897                                              ; address.
 7108 1897 A7                   AND     A               ; clear the carry flag.
 7109 1898 ED 52                SBC     HL,DE           ; test if an error address has been reached.
 7110 189A 20 05                JR      NZ,L18A1        ; forward to OUT-LINE5 if not.
 7111 189C
 7112 189C 3E 3F                LD      A,$3F           ; load A with '?' the error marker.
 7113 189E CD C1 18             CALL    L18C1           ; routine OUT-FLASH to print flashing marker.
 7114 18A1
 7115 18A1              ;; OUT-LINE5
 7116 18A1 CD E1 18     L18A1:  CALL    L18E1           ; routine OUT-CURS will print the cursor if
 7117 18A4                                              ; this is the right position.
 7118 18A4 EB                   EX      DE,HL           ; restore address pointer to HL.
 7119 18A5 7E                   LD      A,(HL)          ; fetch the addressed character.
 7120 18A6 CD B6 18             CALL    L18B6           ; routine NUMBER skips a hidden floating
 7121 18A9                                              ; point number if present.
 7122 18A9 23                   INC     HL              ; now increment the pointer.
 7123 18AA FE 0D                CP      $0D             ; is character end-of-line ?
 7124 18AC 28 06                JR      Z,L18B4         ; to OUT-LINE6, if so, as line is finished.
 7125 18AE
 7126 18AE EB                   EX      DE,HL           ; save the pointer in DE.
 7127 18AF CD 37 19             CALL    L1937           ; routine OUT-CHAR to output character/token.
 7128 18B2
 7129 18B2 18 E0                JR      L1894           ; back to OUT-LINE4 until entire line is done.
 7130 18B4
 7131 18B4              ; ---
 7132 18B4
 7133 18B4              ;; OUT-LINE6
 7134 18B4 D1           L18B4:  POP     DE              ; bring back the flag E, zero if current
 7135 18B5                                              ; line printed else 1 if still to print.
 7136 18B5 C9                   RET                     ; return with A holding $0D
 7137 18B6
 7138 18B6              ; -------------------------
 7139 18B6              ; Check for a number marker
 7140 18B6              ; -------------------------
 7141 18B6              ; this subroutine is called from two processes. while outputting BASIC lines
 7142 18B6              ; and while searching statements within a BASIC line.
 7143 18B6              ; during both, this routine will pass over an invisible number indicator
 7144 18B6              ; and the five bytes floating-point number that follows it.
 7145 18B6              ; Note that this causes floating point numbers to be stripped from
 7146 18B6              ; the BASIC line when it is fetched to the edit buffer by OUT_LINE.
 7147 18B6              ; the number marker also appears after the arguments of a DEF FN statement
 7148 18B6              ; and may mask old 5-byte string parameters.
 7149 18B6
 7150 18B6              ;; NUMBER
 7151 18B6 FE 0E        L18B6:  CP      $0E             ; character fourteen ?
 7152 18B8 C0                   RET     NZ              ; return if not.
 7153 18B9
 7154 18B9 23                   INC     HL              ; skip the character
 7155 18BA 23                   INC     HL              ; and five bytes
 7156 18BB 23                   INC     HL              ; following.
 7157 18BC 23                   INC     HL              ;
 7158 18BD 23                   INC     HL              ;
 7159 18BE 23                   INC     HL              ;
 7160 18BF 7E                   LD      A,(HL)          ; fetch the following character
 7161 18C0 C9                   RET                     ; for return value.
 7162 18C1
 7163 18C1              ; --------------------------
 7164 18C1              ; Print a flashing character
 7165 18C1              ; --------------------------
 7166 18C1              ; This subroutine is called from OUT-LINE to print a flashing error
 7167 18C1              ; marker '?' or from the next routine to print a flashing cursor e.g. 'L'.
 7168 18C1              ; However, this only gets called from OUT-LINE when printing the edit line
 7169 18C1              ; or the input buffer to the lower screen so a direct call to $09F4 can
 7170 18C1              ; be used, even though out-line outputs to other streams.
 7171 18C1              ; In fact the alternate set is used for the whole routine.
 7172 18C1
 7173 18C1              ;; OUT-FLASH
 7174 18C1 D9           L18C1:  EXX                     ; switch in alternate set
 7175 18C2
 7176 18C2 2A 8F 5C             LD      HL,($5C8F)      ; fetch L = ATTR_T, H = MASK-T
 7177 18C5 E5                   PUSH    HL              ; save masks.
 7178 18C6 CB BC                RES     7,H             ; reset flash mask bit so active.
 7179 18C8 CB FD                SET     7,L             ; make attribute FLASH.
 7180 18CA 22 8F 5C             LD      ($5C8F),HL      ; resave ATTR_T and MASK-T
 7181 18CD
 7182 18CD 21 91 5C             LD      HL,$5C91        ; address P_FLAG
 7183 18D0 56                   LD      D,(HL)          ; fetch to D
 7184 18D1 D5                   PUSH    DE              ; and save.
 7185 18D2 36 00                LD      (HL),$00        ; clear inverse, over, ink/paper 9
 7186 18D4
 7187 18D4 CD F4 09             CALL    L09F4           ; routine PRINT-OUT outputs character
 7188 18D7                                              ; without the need to vector via RST 10.
 7189 18D7
 7190 18D7 E1                   POP     HL              ; pop P_FLAG to H.
 7191 18D8 FD 74 57             LD      (IY+$57),H      ; and restore system variable P_FLAG.
 7192 18DB E1                   POP     HL              ; restore temporary masks
 7193 18DC 22 8F 5C             LD      ($5C8F),HL      ; and restore system variables ATTR_T/MASK_T
 7194 18DF
 7195 18DF D9                   EXX                     ; switch back to main set
 7196 18E0 C9                   RET                     ; return
 7197 18E1
 7198 18E1              ; ----------------
 7199 18E1              ; Print the cursor
 7200 18E1              ; ----------------
 7201 18E1              ; This routine is called before any character is output while outputting
 7202 18E1              ; a BASIC line or the input buffer. This includes listing to a printer
 7203 18E1              ; or screen, copying a BASIC line to the edit buffer and printing the
 7204 18E1              ; input buffer or edit buffer to the lower screen. It is only in the
 7205 18E1              ; latter two cases that it has any relevance and in the last case it
 7206 18E1              ; performs another very important function also.
 7207 18E1
 7208 18E1              ;; OUT-CURS
 7209 18E1 2A 5B 5C     L18E1:  LD      HL,($5C5B)      ; fetch K_CUR the current cursor address
 7210 18E4 A7                   AND     A               ; prepare for true subtraction.
 7211 18E5 ED 52                SBC     HL,DE           ; test against pointer address in DE and
 7212 18E7 C0                   RET     NZ              ; return if not at exact position.
 7213 18E8
 7214 18E8              ; the value of MODE, maintained by KEY-INPUT, is tested and if non-zero
 7215 18E8              ; then this value 'E' or 'G' will take precedence.
 7216 18E8
 7217 18E8 3A 41 5C             LD      A,($5C41)       ; fetch MODE  0='KLC', 1='E', 2='G'.
 7218 18EB CB 07                RLC     A               ; double the value and set flags.
 7219 18ED 28 04                JR      Z,L18F3         ; to OUT-C-1 if still zero ('KLC').
 7220 18EF
 7221 18EF C6 43                ADD     A,$43           ; add 'C' - will become 'E' if originally 1
 7222 18F1                                              ; or 'G' if originally 2.
 7223 18F1 18 16                JR      L1909           ; forward to OUT-C-2 to print.
 7224 18F3
 7225 18F3              ; ---
 7226 18F3
 7227 18F3              ; If mode was zero then, while printing a BASIC line, bit 2 of flags has been
 7228 18F3              ; set if 'THEN' or ':' was encountered as a main character and reset otherwise.
 7229 18F3              ; This is now used to determine if the 'K' cursor is to be printed but this
 7230 18F3              ; transient state is also now transferred permanently to bit 3 of FLAGS
 7231 18F3              ; to let the interrupt routine know how to decode the next key.
 7232 18F3
 7233 18F3              ;; OUT-C-1
 7234 18F3 21 3B 5C     L18F3:  LD      HL,$5C3B        ; Address FLAGS
 7235 18F6 CB 9E                RES     3,(HL)          ; signal 'K' mode initially.
 7236 18F8 3E 4B                LD      A,$4B           ; prepare letter 'K'.
 7237 18FA CB 56                BIT     2,(HL)          ; test FLAGS - was the
 7238 18FC                                              ; previous main character ':' or 'THEN' ?
 7239 18FC 28 0B                JR      Z,L1909         ; forward to OUT-C-2 if so to print.
 7240 18FE
 7241 18FE CB DE                SET     3,(HL)          ; signal 'L' mode to interrupt routine.
 7242 1900                                              ; Note. transient bit has been made permanent.
 7243 1900 3C                   INC     A               ; augment from 'K' to 'L'.
 7244 1901
 7245 1901 FD CB 30 5E          BIT     3,(IY+$30)      ; test FLAGS2 - consider caps lock ?
 7246 1905                                              ; which is maintained by KEY-INPUT.
 7247 1905 28 02                JR      Z,L1909         ; forward to OUT-C-2 if not set to print.
 7248 1907
 7249 1907 3E 43                LD      A,$43           ; alter 'L' to 'C'.
 7250 1909
 7251 1909              ;; OUT-C-2
 7252 1909 D5           L1909:  PUSH    DE              ; save address pointer but OK as OUT-FLASH
 7253 190A                                              ; uses alternate set without RST 10.
 7254 190A
 7255 190A CD C1 18             CALL    L18C1           ; routine OUT-FLASH to print.
 7256 190D
 7257 190D D1                   POP     DE              ; restore and
 7258 190E C9                   RET                     ; return.
 7259 190F
 7260 190F              ; ----------------------------
 7261 190F              ; Get line number of next line
 7262 190F              ; ----------------------------
 7263 190F              ; These two subroutines are called while editing.
 7264 190F              ; This entry point is from ED-DOWN with HL addressing E_PPC
 7265 190F              ; to fetch the next line number.
 7266 190F              ; Also from AUTO-LIST with HL addressing S_TOP just to update S_TOP
 7267 190F              ; with the value of the next line number. It gets fetched but is discarded.
 7268 190F              ; These routines never get called while the editor is being used for input.
 7269 190F
 7270 190F              ;; LN-FETCH
 7271 190F 5E           L190F:  LD      E,(HL)          ; fetch low byte
 7272 1910 23                   INC     HL              ; address next
 7273 1911 56                   LD      D,(HL)          ; fetch high byte.
 7274 1912 E5                   PUSH    HL              ; save system variable hi pointer.
 7275 1913 EB                   EX      DE,HL           ; line number to HL,
 7276 1914 23                   INC     HL              ; increment as a starting point.
 7277 1915 CD 6E 19             CALL    L196E           ; routine LINE-ADDR gets address in HL.
 7278 1918 CD 95 16             CALL    L1695           ; routine LINE-NO gets line number in DE.
 7279 191B E1                   POP     HL              ; restore system variable hi pointer.
 7280 191C
 7281 191C              ; This entry point is from the ED-UP with HL addressing E_PPC_hi
 7282 191C
 7283 191C              ;; LN-STORE
 7284 191C FD CB 37 6E  L191C:  BIT     5,(IY+$37)      ; test FLAGX - input mode ?
 7285 1920 C0                   RET     NZ              ; return if so.
 7286 1921                                              ; Note. above already checked by ED-UP/ED-DOWN.
 7287 1921
 7288 1921 72                   LD      (HL),D          ; save high byte of line number.
 7289 1922 2B                   DEC     HL              ; address lower
 7290 1923 73                   LD      (HL),E          ; save low byte of line number.
 7291 1924 C9                   RET                     ; return.
 7292 1925
 7293 1925              ; -----------------------------------------
 7294 1925              ; Outputting numbers at start of BASIC line
 7295 1925              ; -----------------------------------------
 7296 1925              ; This routine entered at OUT-SP-NO is used to compute then output the first
 7297 1925              ; three digits of a 4-digit BASIC line printing a space if necessary.
 7298 1925              ; The line number, or residual part, is held in HL and the BC register
 7299 1925              ; holds a subtraction value -1000, -100 or -10.
 7300 1925              ; Note. for example line number 200 -
 7301 1925              ; space(out_char), 2(out_code), 0(out_char) final number always out-code.
 7302 1925
 7303 1925              ;; OUT-SP-2
 7304 1925 7B           L1925:  LD      A,E             ; will be space if OUT-CODE not yet called.
 7305 1926                                              ; or $FF if spaces are suppressed.
 7306 1926                                              ; else $30 ('0').
 7307 1926                                              ; (from the first instruction at OUT-CODE)
 7308 1926                                              ; this guy is just too clever.
 7309 1926 A7                   AND     A               ; test bit 7 of A.
 7310 1927 F8                   RET     M               ; return if $FF, as leading spaces not
 7311 1928                                              ; required. This is set when printing line
 7312 1928                                              ; number and statement in MAIN-5.
 7313 1928
 7314 1928 18 0D                JR      L1937           ; forward to exit via OUT-CHAR.
 7315 192A
 7316 192A              ; ---
 7317 192A
 7318 192A              ; -> the single entry point.
 7319 192A
 7320 192A              ;; OUT-SP-NO
 7321 192A AF           L192A:  XOR     A               ; initialize digit to 0
 7322 192B
 7323 192B              ;; OUT-SP-1
 7324 192B 09           L192B:  ADD     HL,BC           ; add negative number to HL.
 7325 192C 3C                   INC     A               ; increment digit
 7326 192D 38 FC                JR      C,L192B         ; back to OUT-SP-1 until no carry from
 7327 192F                                              ; the addition.
 7328 192F
 7329 192F ED 42                SBC     HL,BC           ; cancel the last addition
 7330 1931 3D                   DEC     A               ; and decrement the digit.
 7331 1932 28 F1                JR      Z,L1925         ; back to OUT-SP-2 if it is zero.
 7332 1934
 7333 1934 C3 EF 15             JP      L15EF           ; jump back to exit via OUT-CODE.    ->
 7334 1937
 7335 1937
 7336 1937              ; -------------------------------------
 7337 1937              ; Outputting characters in a BASIC line
 7338 1937              ; -------------------------------------
 7339 1937              ; This subroutine ...
 7340 1937
 7341 1937              ;; OUT-CHAR
 7342 1937 CD 1B 2D     L1937:  CALL    L2D1B           ; routine NUMERIC tests if it is a digit ?
 7343 193A 30 30                JR      NC,L196C        ; to OUT-CH-3 to print digit without
 7344 193C                                              ; changing mode. Will be 'K' mode if digits
 7345 193C                                              ; are at beginning of edit line.
 7346 193C
 7347 193C FE 21                CP      $21             ; less than quote character ?
 7348 193E 38 2C                JR      C,L196C         ; to OUT-CH-3 to output controls and space.
 7349 1940
 7350 1940 FD CB 01 96          RES     2,(IY+$01)      ; initialize FLAGS to 'K' mode and leave
 7351 1944                                              ; unchanged if this character would precede
 7352 1944                                              ; a keyword.
 7353 1944
 7354 1944 FE CB                CP      $CB             ; is character 'THEN' token ?
 7355 1946 28 24                JR      Z,L196C         ; to OUT-CH-3 to output if so.
 7356 1948
 7357 1948 FE 3A                CP      $3A             ; is it ':' ?
 7358 194A 20 0E                JR      NZ,L195A        ; to OUT-CH-1 if not statement separator
 7359 194C                                              ; to change mode back to 'L'.
 7360 194C
 7361 194C FD CB 37 6E          BIT     5,(IY+$37)      ; FLAGX  - Input Mode ??
 7362 1950 20 16                JR      NZ,L1968        ; to OUT-CH-2 if in input as no statements.
 7363 1952                                              ; Note. this check should seemingly be at
 7364 1952                                              ; the start. Commands seem inappropriate in
 7365 1952                                              ; INPUT mode and are rejected by the syntax
 7366 1952                                              ; checker anyway.
 7367 1952                                              ; unless INPUT LINE is being used.
 7368 1952
 7369 1952 FD CB 30 56          BIT     2,(IY+$30)      ; test FLAGS2 - is the ':' within quotes ?
 7370 1956 28 14                JR      Z,L196C         ; to OUT-CH-3 if ':' is outside quoted text.
 7371 1958
 7372 1958 18 0E                JR      L1968           ; to OUT-CH-2 as ':' is within quotes
 7373 195A
 7374 195A              ; ---
 7375 195A
 7376 195A              ;; OUT-CH-1
 7377 195A FE 22        L195A:  CP      $22             ; is it quote character '"'  ?
 7378 195C 20 0A                JR      NZ,L1968        ; to OUT-CH-2 with others to set 'L' mode.
 7379 195E
 7380 195E F5                   PUSH    AF              ; save character.
 7381 195F 3A 6A 5C             LD      A,($5C6A)       ; fetch FLAGS2.
 7382 1962 EE 04                XOR     $04             ; toggle the quotes flag.
 7383 1964 32 6A 5C             LD      ($5C6A),A       ; update FLAGS2
 7384 1967 F1                   POP     AF              ; and restore character.
 7385 1968
 7386 1968              ;; OUT-CH-2
 7387 1968 FD CB 01 D6  L1968:  SET     2,(IY+$01)      ; update FLAGS - signal L mode if the cursor
 7388 196C                                              ; is next.
 7389 196C
 7390 196C              ;; OUT-CH-3
 7391 196C D7           L196C:  RST     10H             ; PRINT-A vectors the character to
 7392 196D                                              ; channel 'S', 'K', 'R' or 'P'.
 7393 196D C9                   RET                     ; return.
 7394 196E
 7395 196E              ; -------------------------------------------
 7396 196E              ; Get starting address of line, or line after
 7397 196E              ; -------------------------------------------
 7398 196E              ; This routine is used often to get the address, in HL, of a BASIC line
 7399 196E              ; number supplied in HL, or failing that the address of the following line
 7400 196E              ; and the address of the previous line in DE.
 7401 196E
 7402 196E              ;; LINE-ADDR
 7403 196E E5           L196E:  PUSH    HL              ; save line number in HL register
 7404 196F 2A 53 5C             LD      HL,($5C53)      ; fetch start of program from PROG
 7405 1972 54                   LD      D,H             ; transfer address to
 7406 1973 5D                   LD      E,L             ; the DE register pair.
 7407 1974
 7408 1974              ;; LINE-AD-1
 7409 1974 C1           L1974:  POP     BC              ; restore the line number to BC
 7410 1975 CD 80 19             CALL    L1980           ; routine CP-LINES compares with that
 7411 1978                                              ; addressed by HL
 7412 1978 D0                   RET     NC              ; return if line has been passed or matched.
 7413 1979                                              ; if NZ, address of previous is in DE
 7414 1979
 7415 1979 C5                   PUSH    BC              ; save the current line number
 7416 197A CD B8 19             CALL    L19B8           ; routine NEXT-ONE finds address of next
 7417 197D                                              ; line number in DE, previous in HL.
 7418 197D EB                   EX      DE,HL           ; switch so next in HL
 7419 197E 18 F4                JR      L1974           ; back to LINE-AD-1 for another comparison
 7420 1980
 7421 1980              ; --------------------
 7422 1980              ; Compare line numbers
 7423 1980              ; --------------------
 7424 1980              ; This routine compares a line number supplied in BC with an addressed
 7425 1980              ; line number pointed to by HL.
 7426 1980
 7427 1980              ;; CP-LINES
 7428 1980 7E           L1980:  LD      A,(HL)          ; Load the high byte of line number and
 7429 1981 B8                   CP      B               ; compare with that of supplied line number.
 7430 1982 C0                   RET     NZ              ; return if yet to match (carry will be set).
 7431 1983
 7432 1983 23                   INC     HL              ; address low byte of
 7433 1984 7E                   LD      A,(HL)          ; number and pick up in A.
 7434 1985 2B                   DEC     HL              ; step back to first position.
 7435 1986 B9                   CP      C               ; now compare.
 7436 1987 C9                   RET                     ; zero set if exact match.
 7437 1988                                              ; carry set if yet to match.
 7438 1988                                              ; no carry indicates a match or
 7439 1988                                              ; next available BASIC line or
 7440 1988                                              ; program end marker.
 7441 1988
 7442 1988              ; -------------------
 7443 1988              ; Find each statement
 7444 1988              ; -------------------
 7445 1988              ; The single entry point EACH-STMT is used to
 7446 1988              ; 1) To find the D'th statement in a line.
 7447 1988              ; 2) To find a token in held E.
 7448 1988
 7449 1988              ;; not-used
 7450 1988 23           L1988:  INC     HL              ;
 7451 1989 23                   INC     HL              ;
 7452 198A 23                   INC     HL              ;
 7453 198B
 7454 198B              ; -> entry point.
 7455 198B
 7456 198B              ;; EACH-STMT
 7457 198B 22 5D 5C     L198B:  LD      ($5C5D),HL      ; save HL in CH_ADD
 7458 198E 0E 00                LD      C,$00           ; initialize quotes flag
 7459 1990
 7460 1990              ;; EACH-S-1
 7461 1990 15           L1990:  DEC     D               ; decrease statement count
 7462 1991 C8                   RET     Z               ; return if zero
 7463 1992
 7464 1992
 7465 1992 E7                   RST     20H             ; NEXT-CHAR
 7466 1993 BB                   CP      E               ; is it the search token ?
 7467 1994 20 04                JR      NZ,L199A        ; forward to EACH-S-3 if not
 7468 1996
 7469 1996 A7                   AND     A               ; clear carry
 7470 1997 C9                   RET                     ; return signalling success.
 7471 1998
 7472 1998              ; ---
 7473 1998
 7474 1998              ;; EACH-S-2
 7475 1998 23           L1998:  INC     HL              ; next address
 7476 1999 7E                   LD      A,(HL)          ; next character
 7477 199A
 7478 199A              ;; EACH-S-3
 7479 199A CD B6 18     L199A:  CALL    L18B6           ; routine NUMBER skips if number marker
 7480 199D 22 5D 5C             LD      ($5C5D),HL      ; save in CH_ADD
 7481 19A0 FE 22                CP      $22             ; is it quotes '"' ?
 7482 19A2 20 01                JR      NZ,L19A5        ; to EACH-S-4 if not
 7483 19A4
 7484 19A4 0D                   DEC     C               ; toggle bit 0 of C
 7485 19A5
 7486 19A5              ;; EACH-S-4
 7487 19A5 FE 3A        L19A5:  CP      $3A             ; is it ':'
 7488 19A7 28 04                JR      Z,L19AD         ; to EACH-S-5
 7489 19A9
 7490 19A9 FE CB                CP      $CB             ; 'THEN'
 7491 19AB 20 04                JR      NZ,L19B1        ; to EACH-S-6
 7492 19AD
 7493 19AD              ;; EACH-S-5
 7494 19AD CB 41        L19AD:  BIT     0,C             ; is it in quotes
 7495 19AF 28 DF                JR      Z,L1990         ; to EACH-S-1 if not
 7496 19B1
 7497 19B1              ;; EACH-S-6
 7498 19B1 FE 0D        L19B1:  CP      $0D             ; end of line ?
 7499 19B3 20 E3                JR      NZ,L1998        ; to EACH-S-2
 7500 19B5
 7501 19B5 15                   DEC     D               ; decrease the statement counter
 7502 19B6                                              ; which should be zero else
 7503 19B6                                              ; 'Statement Lost'.
 7504 19B6 37                   SCF                     ; set carry flag - not found
 7505 19B7 C9                   RET                     ; return
 7506 19B8
 7507 19B8              ; -----------------------------------------------------------------------
 7508 19B8              ; Storage of variables. For full details - see chapter 24.
 7509 19B8              ; ZX Spectrum BASIC Programming by Steven Vickers 1982.
 7510 19B8              ; It is bits 7-5 of the first character of a variable that allow
 7511 19B8              ; the six types to be distinguished. Bits 4-0 are the reduced letter.
 7512 19B8              ; So any variable name is higher that $3F and can be distinguished
 7513 19B8              ; also from the variables area end-marker $80.
 7514 19B8              ;
 7515 19B8              ; 76543210 meaning                               brief outline of format.
 7516 19B8              ; -------- ------------------------              -----------------------
 7517 19B8              ; 010      string variable.                      2 byte length + contents.
 7518 19B8              ; 110      string array.                         2 byte length + contents.
 7519 19B8              ; 100      array of numbers.                     2 byte length + contents.
 7520 19B8              ; 011      simple numeric variable.              5 bytes.
 7521 19B8              ; 101      variable length named numeric.        5 bytes.
 7522 19B8              ; 111      for-next loop variable.               18 bytes.
 7523 19B8              ; 10000000 the variables area end-marker.
 7524 19B8              ;
 7525 19B8              ; Note. any of the above seven will serve as a program end-marker.
 7526 19B8              ;
 7527 19B8              ; -----------------------------------------------------------------------
 7528 19B8
 7529 19B8              ; ------------
 7530 19B8              ; Get next one
 7531 19B8              ; ------------
 7532 19B8              ; This versatile routine is used to find the address of the next line
 7533 19B8              ; in the program area or the next variable in the variables area.
 7534 19B8              ; The reason one routine is made to handle two apparently unrelated tasks
 7535 19B8              ; is that it can be called indiscriminately when merging a line or a
 7536 19B8              ; variable.
 7537 19B8
 7538 19B8              ;; NEXT-ONE
 7539 19B8 E5           L19B8:  PUSH    HL              ; save the pointer address.
 7540 19B9 7E                   LD      A,(HL)          ; get first byte.
 7541 19BA FE 40                CP      $40             ; compare with upper limit for line numbers.
 7542 19BC 38 17                JR      C,L19D5         ; forward to NEXT-O-3 if within BASIC area.
 7543 19BE
 7544 19BE              ; the continuation here is for the next variable unless the supplied
 7545 19BE              ; line number was erroneously over 16383. see RESTORE command.
 7546 19BE
 7547 19BE CB 6F                BIT     5,A             ; is it a string or an array variable ?
 7548 19C0 28 14                JR      Z,L19D6         ; forward to NEXT-O-4 to compute length.
 7549 19C2
 7550 19C2 87                   ADD     A,A             ; test bit 6 for single-character variables.
 7551 19C3 FA C7 19             JP      M,L19C7         ; forward to NEXT-O-1 if so
 7552 19C6
 7553 19C6 3F                   CCF                     ; clear the carry for long-named variables.
 7554 19C7                                              ; it remains set for for-next loop variables.
 7555 19C7
 7556 19C7              ;; NEXT-O-1
 7557 19C7 01 05 00     L19C7:  LD      BC,$0005        ; set BC to 5 for floating point number
 7558 19CA 30 02                JR      NC,L19CE        ; forward to NEXT-O-2 if not a for/next
 7559 19CC                                              ; variable.
 7560 19CC
 7561 19CC 0E 12                LD      C,$12           ; set BC to eighteen locations.
 7562 19CE                                              ; value, limit, step, line and statement.
 7563 19CE
 7564 19CE              ; now deal with long-named variables
 7565 19CE
 7566 19CE              ;; NEXT-O-2
 7567 19CE 17           L19CE:  RLA                     ; test if character inverted. carry will also
 7568 19CF                                              ; be set for single character variables
 7569 19CF 23                   INC     HL              ; address next location.
 7570 19D0 7E                   LD      A,(HL)          ; and load character.
 7571 19D1 30 FB                JR      NC,L19CE        ; back to NEXT-O-2 if not inverted bit.
 7572 19D3                                              ; forward immediately with single character
 7573 19D3                                              ; variable names.
 7574 19D3
 7575 19D3 18 06                JR      L19DB           ; forward to NEXT-O-5 to add length of
 7576 19D5                                              ; floating point number(s etc.).
 7577 19D5
 7578 19D5              ; ---
 7579 19D5
 7580 19D5              ; this branch is for line numbers.
 7581 19D5
 7582 19D5              ;; NEXT-O-3
 7583 19D5 23           L19D5:  INC     HL              ; increment pointer to low byte of line no.
 7584 19D6
 7585 19D6              ; strings and arrays rejoin here
 7586 19D6
 7587 19D6              ;; NEXT-O-4
 7588 19D6 23           L19D6:  INC     HL              ; increment to address the length low byte.
 7589 19D7 4E                   LD      C,(HL)          ; transfer to C and
 7590 19D8 23                   INC     HL              ; point to high byte of length.
 7591 19D9 46                   LD      B,(HL)          ; transfer that to B
 7592 19DA 23                   INC     HL              ; point to start of BASIC/variable contents.
 7593 19DB
 7594 19DB              ; the three types of numeric variables rejoin here
 7595 19DB
 7596 19DB              ;; NEXT-O-5
 7597 19DB 09           L19DB:  ADD     HL,BC           ; add the length to give address of next
 7598 19DC                                              ; line/variable in HL.
 7599 19DC D1                   POP     DE              ; restore previous address to DE.
 7600 19DD
 7601 19DD              ; ------------------
 7602 19DD              ; Difference routine
 7603 19DD              ; ------------------
 7604 19DD              ; This routine terminates the above routine and is also called from the
 7605 19DD              ; start of the next routine to calculate the length to reclaim.
 7606 19DD
 7607 19DD              ;; DIFFER
 7608 19DD A7           L19DD:  AND     A               ; prepare for true subtraction.
 7609 19DE ED 52                SBC     HL,DE           ; subtract the two pointers.
 7610 19E0 44                   LD      B,H             ; transfer result
 7611 19E1 4D                   LD      C,L             ; to BC register pair.
 7612 19E2 19                   ADD     HL,DE           ; add back
 7613 19E3 EB                   EX      DE,HL           ; and switch pointers
 7614 19E4 C9                   RET                     ; return values are the length of area in BC,
 7615 19E5                                              ; low pointer (previous) in HL,
 7616 19E5                                              ; high pointer (next) in DE.
 7617 19E5
 7618 19E5              ; -----------------------
 7619 19E5              ; Handle reclaiming space
 7620 19E5              ; -----------------------
 7621 19E5              ;
 7622 19E5
 7623 19E5              ;; RECLAIM-1
 7624 19E5 CD DD 19     L19E5:  CALL    L19DD           ; routine DIFFER immediately above
 7625 19E8
 7626 19E8              ;; RECLAIM-2
 7627 19E8 C5           L19E8:  PUSH    BC              ;
 7628 19E9
 7629 19E9 78                   LD      A,B             ;
 7630 19EA 2F                   CPL                     ;
 7631 19EB 47                   LD      B,A             ;
 7632 19EC 79                   LD      A,C             ;
 7633 19ED 2F                   CPL                     ;
 7634 19EE 4F                   LD      C,A             ;
 7635 19EF 03                   INC     BC              ;
 7636 19F0
 7637 19F0 CD 64 16             CALL    L1664           ; routine POINTERS
 7638 19F3 EB                   EX      DE,HL           ;
 7639 19F4 E1                   POP     HL              ;
 7640 19F5
 7641 19F5 19                   ADD     HL,DE           ;
 7642 19F6 D5                   PUSH    DE              ;
 7643 19F7 ED B0                LDIR                    ; copy bytes
 7644 19F9
 7645 19F9 E1                   POP     HL              ;
 7646 19FA C9                   RET                     ;
 7647 19FB
 7648 19FB              ; ----------------------------------------
 7649 19FB              ; Read line number of line in editing area
 7650 19FB              ; ----------------------------------------
 7651 19FB              ; This routine reads a line number in the editing area returning the number
 7652 19FB              ; in the BC register or zero if no digits exist before commands.
 7653 19FB              ; It is called from LINE-SCAN to check the syntax of the digits.
 7654 19FB              ; It is called from MAIN-3 to extract the line number in preparation for
 7655 19FB              ; inclusion of the line in the BASIC program area.
 7656 19FB              ;
 7657 19FB              ; Interestingly the calculator stack is moved from its normal place at the
 7658 19FB              ; end of dynamic memory to an adequate area within the system variables area.
 7659 19FB              ; This ensures that in a low memory situation, that valid line numbers can
 7660 19FB              ; be extracted without raising an error and that memory can be reclaimed
 7661 19FB              ; by deleting lines. If the stack was in its normal place then a situation
 7662 19FB              ; arises whereby the Spectrum becomes locked with no means of reclaiming space.
 7663 19FB
 7664 19FB              ;; E-LINE-NO
 7665 19FB 2A 59 5C     L19FB:  LD      HL,($5C59)      ; load HL from system variable E_LINE.
 7666 19FE
 7667 19FE 2B                   DEC     HL              ; decrease so that NEXT_CHAR can be used
 7668 19FF                                              ; without skipping the first digit.
 7669 19FF
 7670 19FF 22 5D 5C             LD      ($5C5D),HL      ; store in the system variable CH_ADD.
 7671 1A02
 7672 1A02 E7                   RST     20H             ; NEXT-CHAR skips any noise and white-space
 7673 1A03                                              ; to point exactly at the first digit.
 7674 1A03
 7675 1A03 21 92 5C             LD      HL,$5C92        ; use MEM-0 as a temporary calculator stack
 7676 1A06                                              ; an overhead of three locations are needed.
 7677 1A06 22 65 5C             LD      ($5C65),HL      ; set new STKEND.
 7678 1A09
 7679 1A09 CD 3B 2D             CALL    L2D3B           ; routine INT-TO-FP will read digits till
 7680 1A0C                                              ; a non-digit found.
 7681 1A0C CD A2 2D             CALL    L2DA2           ; routine FP-TO-BC will retrieve number
 7682 1A0F                                              ; from stack at membot.
 7683 1A0F 38 04                JR      C,L1A15         ; forward to E-L-1 if overflow i.e. > 65535.
 7684 1A11                                              ; 'Nonsense in BASIC'
 7685 1A11
 7686 1A11 21 F0 D8             LD      HL,$D8F0        ; load HL with value -9999
 7687 1A14 09                   ADD     HL,BC           ; add to line number in BC
 7688 1A15
 7689 1A15              ;; E-L-1
 7690 1A15 DA 8A 1C     L1A15:  JP      C,L1C8A         ; to REPORT-C 'Nonsense in BASIC' if over.
 7691 1A18                                              ; Note. As ERR_SP points to ED_ERROR
 7692 1A18                                              ; the report is never produced although
 7693 1A18                                              ; the RST $08 will update X_PTR leading to
 7694 1A18                                              ; the error marker being displayed when
 7695 1A18                                              ; the ED_LOOP is reiterated.
 7696 1A18                                              ; in fact, since it is immediately
 7697 1A18                                              ; cancelled, any report will do.
 7698 1A18
 7699 1A18              ; a line in the range 0 - 9999 has been entered.
 7700 1A18
 7701 1A18 C3 C5 16             JP      L16C5           ; jump back to SET-STK to set the calculator
 7702 1A1B                                              ; stack back to its normal place and exit
 7703 1A1B                                              ; from there.
 7704 1A1B
 7705 1A1B              ; ---------------------------------
 7706 1A1B              ; Report and line number outputting
 7707 1A1B              ; ---------------------------------
 7708 1A1B              ; Entry point OUT-NUM-1 is used by the Error Reporting code to print
 7709 1A1B              ; the line number and later the statement number held in BC.
 7710 1A1B              ; If the statement was part of a direct command then -2 is used as a
 7711 1A1B              ; dummy line number so that zero will be printed in the report.
 7712 1A1B              ; This routine is also used to print the exponent of E-format numbers.
 7713 1A1B              ;
 7714 1A1B              ; Entry point OUT-NUM-2 is used from OUT-LINE to output the line number
 7715 1A1B              ; addressed by HL with leading spaces if necessary.
 7716 1A1B
 7717 1A1B              ;; OUT-NUM-1
 7718 1A1B D5           L1A1B:  PUSH    DE              ; save the
 7719 1A1C E5                   PUSH    HL              ; registers.
 7720 1A1D AF                   XOR     A               ; set A to zero.
 7721 1A1E CB 78                BIT     7,B             ; is the line number minus two ?
 7722 1A20 20 20                JR      NZ,L1A42        ; forward to OUT-NUM-4 if so to print zero
 7723 1A22                                              ; for a direct command.
 7724 1A22
 7725 1A22 60                   LD      H,B             ; transfer the
 7726 1A23 69                   LD      L,C             ; number to HL.
 7727 1A24 1E FF                LD      E,$FF           ; signal 'no leading zeros'.
 7728 1A26 18 08                JR      L1A30           ; forward to continue at OUT-NUM-3
 7729 1A28
 7730 1A28              ; ---
 7731 1A28
 7732 1A28              ; from OUT-LINE - HL addresses line number.
 7733 1A28
 7734 1A28              ;; OUT-NUM-2
 7735 1A28 D5           L1A28:  PUSH    DE              ; save flags
 7736 1A29 56                   LD      D,(HL)          ; high byte to D
 7737 1A2A 23                   INC     HL              ; address next
 7738 1A2B 5E                   LD      E,(HL)          ; low byte to E
 7739 1A2C E5                   PUSH    HL              ; save pointer
 7740 1A2D EB                   EX      DE,HL           ; transfer number to HL
 7741 1A2E 1E 20                LD      E,$20           ; signal 'output leading spaces'
 7742 1A30
 7743 1A30              ;; OUT-NUM-3
 7744 1A30 01 18 FC     L1A30:  LD      BC,$FC18        ; value -1000
 7745 1A33 CD 2A 19             CALL    L192A           ; routine OUT-SP-NO outputs space or number
 7746 1A36 01 9C FF             LD      BC,$FF9C        ; value -100
 7747 1A39 CD 2A 19             CALL    L192A           ; routine OUT-SP-NO
 7748 1A3C 0E F6                LD      C,$F6           ; value -10 ( B is still $FF )
 7749 1A3E CD 2A 19             CALL    L192A           ; routine OUT-SP-NO
 7750 1A41 7D                   LD      A,L             ; remainder to A.
 7751 1A42
 7752 1A42              ;; OUT-NUM-4
 7753 1A42 CD EF 15     L1A42:  CALL    L15EF           ; routine OUT-CODE for final digit.
 7754 1A45                                              ; else report code zero wouldn't get
 7755 1A45                                              ; printed.
 7756 1A45 E1                   POP     HL              ; restore the
 7757 1A46 D1                   POP     DE              ; registers and
 7758 1A47 C9                   RET                     ; return.
 7759 1A48
 7760 1A48
 7761 1A48              ;***************************************************
 7762 1A48              ;** Part 7. BASIC LINE AND COMMAND INTERPRETATION **
 7763 1A48              ;***************************************************
 7764 1A48
 7765 1A48              ; ----------------
 7766 1A48              ; The offset table
 7767 1A48              ; ----------------
 7768 1A48              ; The BASIC interpreter has found a command code $CE - $FF
 7769 1A48              ; which is then reduced to range $00 - $31 and added to the base address
 7770 1A48              ; of this table to give the address of an offset which, when added to
 7771 1A48              ; the offset therein, gives the location in the following parameter table
 7772 1A48              ; where a list of class codes, separators and addresses relevant to the
 7773 1A48              ; command exists.
 7774 1A48
 7775 1A48              ;; offst-tbl
 7776 1A48 B1           L1A48:  DEFB    L1AF9 - $       ; B1 offset to Address: P-DEF-FN
 7777 1A49 CB                   DEFB    L1B14 - $       ; CB offset to Address: P-CAT
 7778 1A4A BC                   DEFB    L1B06 - $       ; BC offset to Address: P-FORMAT
 7779 1A4B BF                   DEFB    L1B0A - $       ; BF offset to Address: P-MOVE
 7780 1A4C C4                   DEFB    L1B10 - $       ; C4 offset to Address: P-ERASE
 7781 1A4D AF                   DEFB    L1AFC - $       ; AF offset to Address: P-OPEN
 7782 1A4E B4                   DEFB    L1B02 - $       ; B4 offset to Address: P-CLOSE
 7783 1A4F 93                   DEFB    L1AE2 - $       ; 93 offset to Address: P-MERGE
 7784 1A50 91                   DEFB    L1AE1 - $       ; 91 offset to Address: P-VERIFY
 7785 1A51 92                   DEFB    L1AE3 - $       ; 92 offset to Address: P-BEEP
 7786 1A52 95                   DEFB    L1AE7 - $       ; 95 offset to Address: P-CIRCLE
 7787 1A53 98                   DEFB    L1AEB - $       ; 98 offset to Address: P-INK
 7788 1A54 98                   DEFB    L1AEC - $       ; 98 offset to Address: P-PAPER
 7789 1A55 98                   DEFB    L1AED - $       ; 98 offset to Address: P-FLASH
 7790 1A56 98                   DEFB    L1AEE - $       ; 98 offset to Address: P-BRIGHT
 7791 1A57 98                   DEFB    L1AEF - $       ; 98 offset to Address: P-INVERSE
 7792 1A58 98                   DEFB    L1AF0 - $       ; 98 offset to Address: P-OVER
 7793 1A59 98                   DEFB    L1AF1 - $       ; 98 offset to Address: P-OUT
 7794 1A5A 7F                   DEFB    L1AD9 - $       ; 7F offset to Address: P-LPRINT
 7795 1A5B 81                   DEFB    L1ADC - $       ; 81 offset to Address: P-LLIST
 7796 1A5C 2E                   DEFB    L1A8A - $       ; 2E offset to Address: P-STOP
 7797 1A5D 6C                   DEFB    L1AC9 - $       ; 6C offset to Address: P-READ
 7798 1A5E 6E                   DEFB    L1ACC - $       ; 6E offset to Address: P-DATA
 7799 1A5F 70                   DEFB    L1ACF - $       ; 70 offset to Address: P-RESTORE
 7800 1A60 48                   DEFB    L1AA8 - $       ; 48 offset to Address: P-NEW
 7801 1A61 94                   DEFB    L1AF5 - $       ; 94 offset to Address: P-BORDER
 7802 1A62 56                   DEFB    L1AB8 - $       ; 56 offset to Address: P-CONT
 7803 1A63 3F                   DEFB    L1AA2 - $       ; 3F offset to Address: P-DIM
 7804 1A64 41                   DEFB    L1AA5 - $       ; 41 offset to Address: P-REM
 7805 1A65 2B                   DEFB    L1A90 - $       ; 2B offset to Address: P-FOR
 7806 1A66 17                   DEFB    L1A7D - $       ; 17 offset to Address: P-GO-TO
 7807 1A67 1F                   DEFB    L1A86 - $       ; 1F offset to Address: P-GO-SUB
 7808 1A68 37                   DEFB    L1A9F - $       ; 37 offset to Address: P-INPUT
 7809 1A69 77                   DEFB    L1AE0 - $       ; 77 offset to Address: P-LOAD
 7810 1A6A 44                   DEFB    L1AAE - $       ; 44 offset to Address: P-LIST
 7811 1A6B 0F                   DEFB    L1A7A - $       ; 0F offset to Address: P-LET
 7812 1A6C 59                   DEFB    L1AC5 - $       ; 59 offset to Address: P-PAUSE
 7813 1A6D 2B                   DEFB    L1A98 - $       ; 2B offset to Address: P-NEXT
 7814 1A6E 43                   DEFB    L1AB1 - $       ; 43 offset to Address: P-POKE
 7815 1A6F 2D                   DEFB    L1A9C - $       ; 2D offset to Address: P-PRINT
 7816 1A70 51                   DEFB    L1AC1 - $       ; 51 offset to Address: P-PLOT
 7817 1A71 3A                   DEFB    L1AAB - $       ; 3A offset to Address: P-RUN
 7818 1A72 6D                   DEFB    L1ADF - $       ; 6D offset to Address: P-SAVE
 7819 1A73 42                   DEFB    L1AB5 - $       ; 42 offset to Address: P-RANDOM
 7820 1A74 0D                   DEFB    L1A81 - $       ; 0D offset to Address: P-IF
 7821 1A75 49                   DEFB    L1ABE - $       ; 49 offset to Address: P-CLS
 7822 1A76 5C                   DEFB    L1AD2 - $       ; 5C offset to Address: P-DRAW
 7823 1A77 44                   DEFB    L1ABB - $       ; 44 offset to Address: P-CLEAR
 7824 1A78 15                   DEFB    L1A8D - $       ; 15 offset to Address: P-RETURN
 7825 1A79 5D                   DEFB    L1AD6 - $       ; 5D offset to Address: P-COPY
 7826 1A7A
 7827 1A7A
 7828 1A7A              ; -------------------------------
 7829 1A7A              ; The parameter or "Syntax" table
 7830 1A7A              ; -------------------------------
 7831 1A7A              ; For each command there exists a variable list of parameters.
 7832 1A7A              ; If the character is greater than a space it is a required separator.
 7833 1A7A              ; If less, then it is a command class in the range 00 - 0B.
 7834 1A7A              ; Note that classes 00, 03 and 05 will fetch the addresses from this table.
 7835 1A7A              ; Some classes e.g. 07 and 0B have the same address in all invocations
 7836 1A7A              ; and the command is re-computed from the low-byte of the parameter address.
 7837 1A7A              ; Some e.g. 02 are only called once so a call to the command is made from
 7838 1A7A              ; within the class routine rather than holding the address within the table.
 7839 1A7A              ; Some class routines check syntax entirely and some leave this task for the
 7840 1A7A              ; command itself.
 7841 1A7A              ; Others for example CIRCLE (x,y,z) check the first part (x,y) using the
 7842 1A7A              ; class routine and the final part (,z) within the command.
 7843 1A7A              ; The last few commands appear to have been added in a rush but their syntax
 7844 1A7A              ; is rather simple e.g. MOVE "M1","M2"
 7845 1A7A
 7846 1A7A              ;; P-LET
 7847 1A7A 01           L1A7A:  DEFB    $01             ; Class-01 - A variable is required.
 7848 1A7B 3D                   DEFB    $3D             ; Separator:  '='
 7849 1A7C 02                   DEFB    $02             ; Class-02 - An expression, numeric or string,
 7850 1A7D                                              ; must follow.
 7851 1A7D
 7852 1A7D              ;; P-GO-TO
 7853 1A7D 06           L1A7D:  DEFB    $06             ; Class-06 - A numeric expression must follow.
 7854 1A7E 00                   DEFB    $00             ; Class-00 - No further operands.
 7855 1A7F 67 1E                DEFW    L1E67           ; Address: $1E67; Address: GO-TO
 7856 1A81
 7857 1A81              ;; P-IF
 7858 1A81 06           L1A81:  DEFB    $06             ; Class-06 - A numeric expression must follow.
 7859 1A82 CB                   DEFB    $CB             ; Separator:  'THEN'
 7860 1A83 05                   DEFB    $05             ; Class-05 - Variable syntax checked
 7861 1A84                                              ; by routine.
 7862 1A84 F0 1C                DEFW    L1CF0           ; Address: $1CF0; Address: IF
 7863 1A86
 7864 1A86              ;; P-GO-SUB
 7865 1A86 06           L1A86:  DEFB    $06             ; Class-06 - A numeric expression must follow.
 7866 1A87 00                   DEFB    $00             ; Class-00 - No further operands.
 7867 1A88 ED 1E                DEFW    L1EED           ; Address: $1EED; Address: GO-SUB
 7868 1A8A
 7869 1A8A              ;; P-STOP
 7870 1A8A 00           L1A8A:  DEFB    $00             ; Class-00 - No further operands.
 7871 1A8B EE 1C                DEFW    L1CEE           ; Address: $1CEE; Address: STOP
 7872 1A8D
 7873 1A8D              ;; P-RETURN
 7874 1A8D 00           L1A8D:  DEFB    $00             ; Class-00 - No further operands.
 7875 1A8E 23 1F                DEFW    L1F23           ; Address: $1F23; Address: RETURN
 7876 1A90
 7877 1A90              ;; P-FOR
 7878 1A90 04           L1A90:  DEFB    $04             ; Class-04 - A single character variable must
 7879 1A91                                              ; follow.
 7880 1A91 3D                   DEFB    $3D             ; Separator:  '='
 7881 1A92 06                   DEFB    $06             ; Class-06 - A numeric expression must follow.
 7882 1A93 CC                   DEFB    $CC             ; Separator:  'TO'
 7883 1A94 06                   DEFB    $06             ; Class-06 - A numeric expression must follow.
 7884 1A95 05                   DEFB    $05             ; Class-05 - Variable syntax checked
 7885 1A96                                              ; by routine.
 7886 1A96 03 1D                DEFW    L1D03           ; Address: $1D03; Address: FOR
 7887 1A98
 7888 1A98              ;; P-NEXT
 7889 1A98 04           L1A98:  DEFB    $04             ; Class-04 - A single character variable must
 7890 1A99                                              ; follow.
 7891 1A99 00                   DEFB    $00             ; Class-00 - No further operands.
 7892 1A9A AB 1D                DEFW    L1DAB           ; Address: $1DAB; Address: NEXT
 7893 1A9C
 7894 1A9C              ;; P-PRINT
 7895 1A9C 05           L1A9C:  DEFB    $05             ; Class-05 - Variable syntax checked entirely
 7896 1A9D                                              ; by routine.
 7897 1A9D CD 1F                DEFW    L1FCD           ; Address: $1FCD; Address: PRINT
 7898 1A9F
 7899 1A9F              ;; P-INPUT
 7900 1A9F 05           L1A9F:  DEFB    $05             ; Class-05 - Variable syntax checked entirely
 7901 1AA0                                              ; by routine.
 7902 1AA0 89 20                DEFW    L2089           ; Address: $2089; Address: INPUT
 7903 1AA2
 7904 1AA2              ;; P-DIM
 7905 1AA2 05           L1AA2:  DEFB    $05             ; Class-05 - Variable syntax checked entirely
 7906 1AA3                                              ; by routine.
 7907 1AA3 02 2C                DEFW    L2C02           ; Address: $2C02; Address: DIM
 7908 1AA5
 7909 1AA5              ;; P-REM
 7910 1AA5 05           L1AA5:  DEFB    $05             ; Class-05 - Variable syntax checked entirely
 7911 1AA6                                              ; by routine.
 7912 1AA6 B2 1B                DEFW    L1BB2           ; Address: $1BB2; Address: REM
 7913 1AA8
 7914 1AA8              ;; P-NEW
 7915 1AA8 00           L1AA8:  DEFB    $00             ; Class-00 - No further operands.
 7916 1AA9 B7 11                DEFW    L11B7           ; Address: $11B7; Address: NEW
 7917 1AAB
 7918 1AAB              ;; P-RUN
 7919 1AAB 03           L1AAB:  DEFB    $03             ; Class-03 - A numeric expression may follow
 7920 1AAC                                              ; else default to zero.
 7921 1AAC A1 1E                DEFW    L1EA1           ; Address: $1EA1; Address: RUN
 7922 1AAE
 7923 1AAE              ;; P-LIST
 7924 1AAE 05           L1AAE:  DEFB    $05             ; Class-05 - Variable syntax checked entirely
 7925 1AAF                                              ; by routine.
 7926 1AAF F9 17                DEFW    L17F9           ; Address: $17F9; Address: LIST
 7927 1AB1
 7928 1AB1              ;; P-POKE
 7929 1AB1 08           L1AB1:  DEFB    $08             ; Class-08 - Two comma-separated numeric
 7930 1AB2                                              ; expressions required.
 7931 1AB2 00                   DEFB    $00             ; Class-00 - No further operands.
 7932 1AB3 80 1E                DEFW    L1E80           ; Address: $1E80; Address: POKE
 7933 1AB5
 7934 1AB5              ;; P-RANDOM
 7935 1AB5 03           L1AB5:  DEFB    $03             ; Class-03 - A numeric expression may follow
 7936 1AB6                                              ; else default to zero.
 7937 1AB6 4F 1E                DEFW    L1E4F           ; Address: $1E4F; Address: RANDOMIZE
 7938 1AB8
 7939 1AB8              ;; P-CONT
 7940 1AB8 00           L1AB8:  DEFB    $00             ; Class-00 - No further operands.
 7941 1AB9 5F 1E                DEFW    L1E5F           ; Address: $1E5F; Address: CONTINUE
 7942 1ABB
 7943 1ABB              ;; P-CLEAR
 7944 1ABB 03           L1ABB:  DEFB    $03             ; Class-03 - A numeric expression may follow
 7945 1ABC                                              ; else default to zero.
 7946 1ABC AC 1E                DEFW    L1EAC           ; Address: $1EAC; Address: CLEAR
 7947 1ABE
 7948 1ABE              ;; P-CLS
 7949 1ABE 00           L1ABE:  DEFB    $00             ; Class-00 - No further operands.
 7950 1ABF 6B 0D                DEFW    L0D6B           ; Address: $0D6B; Address: CLS
 7951 1AC1
 7952 1AC1              ;; P-PLOT
 7953 1AC1 09           L1AC1:  DEFB    $09             ; Class-09 - Two comma-separated numeric
 7954 1AC2                                              ; expressions required with optional colour
 7955 1AC2                                              ; items.
 7956 1AC2 00                   DEFB    $00             ; Class-00 - No further operands.
 7957 1AC3 DC 22                DEFW    L22DC           ; Address: $22DC; Address: PLOT
 7958 1AC5
 7959 1AC5              ;; P-PAUSE
 7960 1AC5 06           L1AC5:  DEFB    $06             ; Class-06 - A numeric expression must follow.
 7961 1AC6 00                   DEFB    $00             ; Class-00 - No further operands.
 7962 1AC7 3A 1F                DEFW    L1F3A           ; Address: $1F3A; Address: PAUSE
 7963 1AC9
 7964 1AC9              ;; P-READ
 7965 1AC9 05           L1AC9:  DEFB    $05             ; Class-05 - Variable syntax checked entirely
 7966 1ACA                                              ; by routine.
 7967 1ACA ED 1D                DEFW    L1DED           ; Address: $1DED; Address: READ
 7968 1ACC
 7969 1ACC              ;; P-DATA
 7970 1ACC 05           L1ACC:  DEFB    $05             ; Class-05 - Variable syntax checked entirely
 7971 1ACD                                              ; by routine.
 7972 1ACD 27 1E                DEFW    L1E27           ; Address: $1E27; Address: DATA
 7973 1ACF
 7974 1ACF              ;; P-RESTORE
 7975 1ACF 03           L1ACF:  DEFB    $03             ; Class-03 - A numeric expression may follow
 7976 1AD0                                              ; else default to zero.
 7977 1AD0 42 1E                DEFW    L1E42           ; Address: $1E42; Address: RESTORE
 7978 1AD2
 7979 1AD2              ;; P-DRAW
 7980 1AD2 09           L1AD2:  DEFB    $09             ; Class-09 - Two comma-separated numeric
 7981 1AD3                                              ; expressions required with optional colour
 7982 1AD3                                              ; items.
 7983 1AD3 05                   DEFB    $05             ; Class-05 - Variable syntax checked
 7984 1AD4                                              ; by routine.
 7985 1AD4 82 23                DEFW    L2382           ; Address: $2382; Address: DRAW
 7986 1AD6
 7987 1AD6              ;; P-COPY
 7988 1AD6 00           L1AD6:  DEFB    $00             ; Class-00 - No further operands.
 7989 1AD7 AC 0E                DEFW    L0EAC           ; Address: $0EAC; Address: COPY
 7990 1AD9
 7991 1AD9              ;; P-LPRINT
 7992 1AD9 05           L1AD9:  DEFB    $05             ; Class-05 - Variable syntax checked entirely
 7993 1ADA                                              ; by routine.
 7994 1ADA C9 1F                DEFW    L1FC9           ; Address: $1FC9; Address: LPRINT
 7995 1ADC
 7996 1ADC              ;; P-LLIST
 7997 1ADC 05           L1ADC:  DEFB    $05             ; Class-05 - Variable syntax checked entirely
 7998 1ADD                                              ; by routine.
 7999 1ADD F5 17                DEFW    L17F5           ; Address: $17F5; Address: LLIST
 8000 1ADF
 8001 1ADF              ;; P-SAVE
 8002 1ADF 0B           L1ADF:  DEFB    $0B             ; Class-0B - Offset address converted to tape
 8003 1AE0                                              ; command.
 8004 1AE0
 8005 1AE0              ;; P-LOAD
 8006 1AE0 0B           L1AE0:  DEFB    $0B             ; Class-0B - Offset address converted to tape
 8007 1AE1                                              ; command.
 8008 1AE1
 8009 1AE1              ;; P-VERIFY
 8010 1AE1 0B           L1AE1:  DEFB    $0B             ; Class-0B - Offset address converted to tape
 8011 1AE2                                              ; command.
 8012 1AE2
 8013 1AE2              ;; P-MERGE
 8014 1AE2 0B           L1AE2:  DEFB    $0B             ; Class-0B - Offset address converted to tape
 8015 1AE3                                              ; command.
 8016 1AE3
 8017 1AE3              ;; P-BEEP
 8018 1AE3 08           L1AE3:  DEFB    $08             ; Class-08 - Two comma-separated numeric
 8019 1AE4                                              ; expressions required.
 8020 1AE4 00                   DEFB    $00             ; Class-00 - No further operands.
 8021 1AE5 F8 03                DEFW    L03F8           ; Address: $03F8; Address: BEEP
 8022 1AE7
 8023 1AE7              ;; P-CIRCLE
 8024 1AE7 09           L1AE7:  DEFB    $09             ; Class-09 - Two comma-separated numeric
 8025 1AE8                                              ; expressions required with optional colour
 8026 1AE8                                              ; items.
 8027 1AE8 05                   DEFB    $05             ; Class-05 - Variable syntax checked
 8028 1AE9                                              ; by routine.
 8029 1AE9 20 23                DEFW    L2320           ; Address: $2320; Address: CIRCLE
 8030 1AEB
 8031 1AEB              ;; P-INK
 8032 1AEB 07           L1AEB:  DEFB    $07             ; Class-07 - Offset address is converted to
 8033 1AEC                                              ; colour code.
 8034 1AEC
 8035 1AEC              ;; P-PAPER
 8036 1AEC 07           L1AEC:  DEFB    $07             ; Class-07 - Offset address is converted to
 8037 1AED                                              ; colour code.
 8038 1AED
 8039 1AED              ;; P-FLASH
 8040 1AED 07           L1AED:  DEFB    $07             ; Class-07 - Offset address is converted to
 8041 1AEE                                              ; colour code.
 8042 1AEE
 8043 1AEE              ;; P-BRIGHT
 8044 1AEE 07           L1AEE:  DEFB    $07             ; Class-07 - Offset address is converted to
 8045 1AEF                                              ; colour code.
 8046 1AEF
 8047 1AEF              ;; P-INVERSE
 8048 1AEF 07           L1AEF:  DEFB    $07             ; Class-07 - Offset address is converted to
 8049 1AF0                                              ; colour code.
 8050 1AF0
 8051 1AF0              ;; P-OVER
 8052 1AF0 07           L1AF0:  DEFB    $07             ; Class-07 - Offset address is converted to
 8053 1AF1                                              ; colour code.
 8054 1AF1
 8055 1AF1              ;; P-OUT
 8056 1AF1 08           L1AF1:  DEFB    $08             ; Class-08 - Two comma-separated numeric
 8057 1AF2                                              ; expressions required.
 8058 1AF2 00                   DEFB    $00             ; Class-00 - No further operands.
 8059 1AF3 7A 1E                DEFW    L1E7A           ; Address: $1E7A; Address: OUT
 8060 1AF5
 8061 1AF5              ;; P-BORDER
 8062 1AF5 06           L1AF5:  DEFB    $06             ; Class-06 - A numeric expression must follow.
 8063 1AF6 00                   DEFB    $00             ; Class-00 - No further operands.
 8064 1AF7 94 22                DEFW    L2294           ; Address: $2294; Address: BORDER
 8065 1AF9
 8066 1AF9              ;; P-DEF-FN
 8067 1AF9 05           L1AF9:  DEFB    $05             ; Class-05 - Variable syntax checked entirely
 8068 1AFA                                              ; by routine.
 8069 1AFA 60 1F                DEFW    L1F60           ; Address: $1F60; Address: DEF-FN
 8070 1AFC
 8071 1AFC              ;; P-OPEN
 8072 1AFC 06           L1AFC:  DEFB    $06             ; Class-06 - A numeric expression must follow.
 8073 1AFD 2C                   DEFB    $2C             ; Separator:  ','          see Footnote *
 8074 1AFE 0A                   DEFB    $0A             ; Class-0A - A string expression must follow.
 8075 1AFF 00                   DEFB    $00             ; Class-00 - No further operands.
 8076 1B00 36 17                DEFW    L1736           ; Address: $1736; Address: OPEN
 8077 1B02
 8078 1B02              ;; P-CLOSE
 8079 1B02 06           L1B02:  DEFB    $06             ; Class-06 - A numeric expression must follow.
 8080 1B03 00                   DEFB    $00             ; Class-00 - No further operands.
 8081 1B04 E5 16                DEFW    L16E5           ; Address: $16E5; Address: CLOSE
 8082 1B06
 8083 1B06              ;; P-FORMAT
 8084 1B06 0A           L1B06:  DEFB    $0A             ; Class-0A - A string expression must follow.
 8085 1B07 00                   DEFB    $00             ; Class-00 - No further operands.
 8086 1B08 93 17                DEFW    L1793           ; Address: $1793; Address: CAT-ETC
 8087 1B0A
 8088 1B0A              ;; P-MOVE
 8089 1B0A 0A           L1B0A:  DEFB    $0A             ; Class-0A - A string expression must follow.
 8090 1B0B 2C                   DEFB    $2C             ; Separator:  ','
 8091 1B0C 0A                   DEFB    $0A             ; Class-0A - A string expression must follow.
 8092 1B0D 00                   DEFB    $00             ; Class-00 - No further operands.
 8093 1B0E 93 17                DEFW    L1793           ; Address: $1793; Address: CAT-ETC
 8094 1B10
 8095 1B10              ;; P-ERASE
 8096 1B10 0A           L1B10:  DEFB    $0A             ; Class-0A - A string expression must follow.
 8097 1B11 00                   DEFB    $00             ; Class-00 - No further operands.
 8098 1B12 93 17                DEFW    L1793           ; Address: $1793; Address: CAT-ETC
 8099 1B14
 8100 1B14              ;; P-CAT
 8101 1B14 00           L1B14:  DEFB    $00             ; Class-00 - No further operands.
 8102 1B15 93 17                DEFW    L1793           ; Address: $1793; Address: CAT-ETC
 8103 1B17
 8104 1B17              ; * Note that a comma is required as a separator with the OPEN command
 8105 1B17              ; but the Interface 1 programmers relaxed this allowing ';' as an
 8106 1B17              ; alternative for their channels creating a confusing mixture of
 8107 1B17              ; allowable syntax as it is this ROM which opens or re-opens the
 8108 1B17              ; normal channels.
 8109 1B17
 8110 1B17              ; -------------------------------
 8111 1B17              ; Main parser (BASIC interpreter)
 8112 1B17              ; -------------------------------
 8113 1B17              ; This routine is called once from MAIN-2 when the BASIC line is to
 8114 1B17              ; be entered or re-entered into the Program area and the syntax
 8115 1B17              ; requires checking.
 8116 1B17
 8117 1B17              ;; LINE-SCAN
 8118 1B17 FD CB 01 BE  L1B17:  RES     7,(IY+$01)      ; update FLAGS - signal checking syntax
 8119 1B1B CD FB 19             CALL    L19FB           ; routine E-LINE-NO              >>
 8120 1B1E                                              ; fetches the line number if in range.
 8121 1B1E
 8122 1B1E AF                   XOR     A               ; clear the accumulator.
 8123 1B1F 32 47 5C             LD      ($5C47),A       ; set statement number SUBPPC to zero.
 8124 1B22 3D                   DEC     A               ; set accumulator to $FF.
 8125 1B23 32 3A 5C             LD      ($5C3A),A       ; set ERR_NR to 'OK' - 1.
 8126 1B26 18 01                JR      L1B29           ; forward to continue at STMT-L-1.
 8127 1B28
 8128 1B28              ; --------------
 8129 1B28              ; Statement loop
 8130 1B28              ; --------------
 8131 1B28              ;
 8132 1B28              ;
 8133 1B28
 8134 1B28              ;; STMT-LOOP
 8135 1B28 E7           L1B28:  RST     20H             ; NEXT-CHAR
 8136 1B29
 8137 1B29              ; -> the entry point from above or LINE-RUN
 8138 1B29              ;; STMT-L-1
 8139 1B29 CD BF 16     L1B29:  CALL    L16BF           ; routine SET-WORK clears workspace etc.
 8140 1B2C
 8141 1B2C FD 34 0D             INC     (IY+$0D)        ; increment statement number SUBPPC
 8142 1B2F FA 8A 1C             JP      M,L1C8A         ; to REPORT-C to raise
 8143 1B32                                              ; 'Nonsense in BASIC' if over 127.
 8144 1B32
 8145 1B32 DF                   RST     18H             ; GET-CHAR
 8146 1B33
 8147 1B33 06 00                LD      B,$00           ; set B to zero for later indexing.
 8148 1B35                                              ; early so any other reason ???
 8149 1B35
 8150 1B35 FE 0D                CP      $0D             ; is character carriage return ?
 8151 1B37                                              ; i.e. an empty statement.
 8152 1B37 28 7A                JR      Z,L1BB3         ; forward to LINE-END if so.
 8153 1B39
 8154 1B39 FE 3A                CP      $3A             ; is it statement end marker ':' ?
 8155 1B3B                                              ; i.e. another type of empty statement.
 8156 1B3B 28 EB                JR      Z,L1B28         ; back to STMT-LOOP if so.
 8157 1B3D
 8158 1B3D 21 76 1B             LD      HL,L1B76        ; address: STMT-RET
 8159 1B40 E5                   PUSH    HL              ; is now pushed as a return address
 8160 1B41 4F                   LD      C,A             ; transfer the current character to C.
 8161 1B42
 8162 1B42              ; advance CH_ADD to a position after command and test if it is a command.
 8163 1B42
 8164 1B42 E7                   RST     20H             ; NEXT-CHAR to advance pointer
 8165 1B43 79                   LD      A,C             ; restore current character
 8166 1B44 D6 CE                SUB     $CE             ; subtract 'DEF FN' - first command
 8167 1B46 DA 8A 1C             JP      C,L1C8A         ; jump to REPORT-C if less than a command
 8168 1B49                                              ; raising
 8169 1B49                                              ; 'Nonsense in BASIC'
 8170 1B49
 8171 1B49 4F                   LD      C,A             ; put the valid command code back in C.
 8172 1B4A                                              ; register B is zero.
 8173 1B4A 21 48 1A             LD      HL,L1A48        ; address: offst-tbl
 8174 1B4D 09                   ADD     HL,BC           ; index into table with one of 50 commands.
 8175 1B4E 4E                   LD      C,(HL)          ; pick up displacement to syntax table entry.
 8176 1B4F 09                   ADD     HL,BC           ; add to address the relevant entry.
 8177 1B50 18 03                JR      L1B55           ; forward to continue at GET-PARAM
 8178 1B52
 8179 1B52              ; ----------------------
 8180 1B52              ; The main scanning loop
 8181 1B52              ; ----------------------
 8182 1B52              ; not documented properly
 8183 1B52              ;
 8184 1B52
 8185 1B52              ;; SCAN-LOOP
 8186 1B52 2A 74 5C     L1B52:  LD      HL,($5C74)      ; fetch temporary address from T_ADDR
 8187 1B55                                              ; during subsequent loops.
 8188 1B55
 8189 1B55              ; -> the initial entry point with HL addressing start of syntax table entry.
 8190 1B55
 8191 1B55              ;; GET-PARAM
 8192 1B55 7E           L1B55:  LD      A,(HL)          ; pick up the parameter.
 8193 1B56 23                   INC     HL              ; address next one.
 8194 1B57 22 74 5C             LD      ($5C74),HL      ; save pointer in system variable T_ADDR
 8195 1B5A
 8196 1B5A 01 52 1B             LD      BC,L1B52        ; address: SCAN-LOOP
 8197 1B5D C5                   PUSH    BC              ; is now pushed on stack as looping address.
 8198 1B5E 4F                   LD      C,A             ; store parameter in C.
 8199 1B5F FE 20                CP      $20             ; is it greater than ' '  ?
 8200 1B61 30 0C                JR      NC,L1B6F        ; forward to SEPARATOR to check that correct
 8201 1B63                                              ; separator appears in statement if so.
 8202 1B63
 8203 1B63 21 01 1C             LD      HL,L1C01        ; address: class-tbl.
 8204 1B66 06 00                LD      B,$00           ; prepare to index into the class table.
 8205 1B68 09                   ADD     HL,BC           ; index to find displacement to routine.
 8206 1B69 4E                   LD      C,(HL)          ; displacement to BC
 8207 1B6A 09                   ADD     HL,BC           ; add to address the CLASS routine.
 8208 1B6B E5                   PUSH    HL              ; push the address on the stack.
 8209 1B6C
 8210 1B6C DF                   RST     18H             ; GET-CHAR - HL points to place in statement.
 8211 1B6D
 8212 1B6D 05                   DEC     B               ; reset the zero flag - the initial state
 8213 1B6E                                              ; for all class routines.
 8214 1B6E
 8215 1B6E C9                   RET                     ; and make an indirect jump to routine
 8216 1B6F                                              ; and then SCAN-LOOP (also on stack).
 8217 1B6F
 8218 1B6F              ; Note. one of the class routines will eventually drop the return address
 8219 1B6F              ; off the stack breaking out of the above seemingly endless loop.
 8220 1B6F
 8221 1B6F              ; -----------------------
 8222 1B6F              ; THE 'SEPARATOR' ROUTINE
 8223 1B6F              ; -----------------------
 8224 1B6F              ;   This routine is called once to verify that the mandatory separator
 8225 1B6F              ;   present in the parameter table is also present in the correct
 8226 1B6F              ;   location following the command.  For example, the 'THEN' token after
 8227 1B6F              ;   the 'IF' token and expression.
 8228 1B6F
 8229 1B6F              ;; SEPARATOR
 8230 1B6F DF           L1B6F:  RST     18H             ; GET-CHAR
 8231 1B70 B9                   CP      C               ; does it match the character in C ?
 8232 1B71 C2 8A 1C             JP      NZ,L1C8A        ; jump forward to REPORT-C if not
 8233 1B74                                              ; 'Nonsense in BASIC'.
 8234 1B74
 8235 1B74 E7                   RST     20H             ; NEXT-CHAR advance to next character
 8236 1B75 C9                   RET                     ; return.
 8237 1B76
 8238 1B76              ; ------------------------------
 8239 1B76              ; Come here after interpretation
 8240 1B76              ; ------------------------------
 8241 1B76              ;
 8242 1B76              ;
 8243 1B76
 8244 1B76              ;; STMT-RET
 8245 1B76 CD 54 1F     L1B76:  CALL    L1F54           ; routine BREAK-KEY is tested after every
 8246 1B79                                              ; statement.
 8247 1B79 38 02                JR      C,L1B7D         ; step forward to STMT-R-1 if not pressed.
 8248 1B7B
 8249 1B7B              ;; REPORT-L
 8250 1B7B CF           L1B7B:  RST     08H             ; ERROR-1
 8251 1B7C 14                   DEFB    $14             ; Error Report: BREAK into program
 8252 1B7D
 8253 1B7D              ;; STMT-R-1
 8254 1B7D FD CB 0A 7E  L1B7D:  BIT     7,(IY+$0A)      ; test NSPPC - will be set if $FF -
 8255 1B81                                              ; no jump to be made.
 8256 1B81 20 71                JR      NZ,L1BF4        ; forward to STMT-NEXT if a program line.
 8257 1B83
 8258 1B83 2A 42 5C             LD      HL,($5C42)      ; fetch line number from NEWPPC
 8259 1B86 CB 7C                BIT     7,H             ; will be set if minus two - direct command(s)
 8260 1B88 28 14                JR      Z,L1B9E         ; forward to LINE-NEW if a jump is to be
 8261 1B8A                                              ; made to a new program line/statement.
 8262 1B8A
 8263 1B8A              ; --------------------
 8264 1B8A              ; Run a direct command
 8265 1B8A              ; --------------------
 8266 1B8A              ; A direct command is to be run or, if continuing from above,
 8267 1B8A              ; the next statement of a direct command is to be considered.
 8268 1B8A
 8269 1B8A              ;; LINE-RUN
 8270 1B8A 21 FE FF     L1B8A:  LD      HL,$FFFE        ; The dummy value minus two
 8271 1B8D 22 45 5C             LD      ($5C45),HL      ; is set/reset as line number in PPC.
 8272 1B90 2A 61 5C             LD      HL,($5C61)      ; point to end of line + 1 - WORKSP.
 8273 1B93 2B                   DEC     HL              ; now point to $80 end-marker.
 8274 1B94 ED 5B 59 5C          LD      DE,($5C59)      ; address the start of line E_LINE.
 8275 1B98 1B                   DEC     DE              ; now location before - for GET-CHAR.
 8276 1B99 3A 44 5C             LD      A,($5C44)       ; load statement to A from NSPPC.
 8277 1B9C 18 33                JR      L1BD1           ; forward to NEXT-LINE.
 8278 1B9E
 8279 1B9E              ; ------------------------------
 8280 1B9E              ; Find start address of new line
 8281 1B9E              ; ------------------------------
 8282 1B9E              ; The branch was to here if a jump is to made to a new line number
 8283 1B9E              ; and statement.
 8284 1B9E              ; That is the previous statement was a GO TO, GO SUB, RUN, RETURN, NEXT etc..
 8285 1B9E
 8286 1B9E              ;; LINE-NEW
 8287 1B9E CD 6E 19     L1B9E:  CALL    L196E           ; routine LINE-ADDR gets address of line
 8288 1BA1                                              ; returning zero flag set if line found.
 8289 1BA1 3A 44 5C             LD      A,($5C44)       ; fetch new statement from NSPPC
 8290 1BA4 28 19                JR      Z,L1BBF         ; forward to LINE-USE if line matched.
 8291 1BA6
 8292 1BA6              ; continue as must be a direct command.
 8293 1BA6
 8294 1BA6 A7                   AND     A               ; test statement which should be zero
 8295 1BA7 20 43                JR      NZ,L1BEC        ; forward to REPORT-N if not.
 8296 1BA9                                              ; 'Statement lost'
 8297 1BA9
 8298 1BA9              ;
 8299 1BA9
 8300 1BA9 47                   LD      B,A             ; save statement in B.??
 8301 1BAA 7E                   LD      A,(HL)          ; fetch high byte of line number.
 8302 1BAB E6 C0                AND     $C0             ; test if using direct command
 8303 1BAD                                              ; a program line is less than $3F
 8304 1BAD 78                   LD      A,B             ; retrieve statement.
 8305 1BAE                                              ; (we can assume it is zero).
 8306 1BAE 28 0F                JR      Z,L1BBF         ; forward to LINE-USE if was a program line
 8307 1BB0
 8308 1BB0              ; Alternatively a direct statement has finished correctly.
 8309 1BB0
 8310 1BB0              ;; REPORT-0
 8311 1BB0 CF           L1BB0:  RST     08H             ; ERROR-1
 8312 1BB1 FF                   DEFB    $FF             ; Error Report: OK
 8313 1BB2
 8314 1BB2              ; -----------------
 8315 1BB2              ; THE 'REM' COMMAND
 8316 1BB2              ; -----------------
 8317 1BB2              ; The REM command routine.
 8318 1BB2              ; The return address STMT-RET is dropped and the rest of line ignored.
 8319 1BB2
 8320 1BB2              ;; REM
 8321 1BB2 C1           L1BB2:  POP     BC              ; drop return address STMT-RET and
 8322 1BB3                                              ; continue ignoring rest of line.
 8323 1BB3
 8324 1BB3              ; ------------
 8325 1BB3              ; End of line?
 8326 1BB3              ; ------------
 8327 1BB3              ;
 8328 1BB3              ;
 8329 1BB3
 8330 1BB3              ;; LINE-END
 8331 1BB3 CD 30 25     L1BB3:  CALL    L2530           ; routine SYNTAX-Z  (UNSTACK-Z?)
 8332 1BB6 C8                   RET     Z               ; return if checking syntax.
 8333 1BB7
 8334 1BB7 2A 55 5C             LD      HL,($5C55)      ; fetch NXTLIN to HL.
 8335 1BBA 3E C0                LD      A,$C0           ; test against the
 8336 1BBC A6                   AND     (HL)            ; system limit $3F.
 8337 1BBD C0                   RET     NZ              ; return if more as must be
 8338 1BBE                                              ; end of program.
 8339 1BBE                                              ; (or direct command)
 8340 1BBE
 8341 1BBE AF                   XOR     A               ; set statement to zero.
 8342 1BBF
 8343 1BBF              ; and continue to set up the next following line and then consider this new one.
 8344 1BBF
 8345 1BBF              ; ---------------------
 8346 1BBF              ; General line checking
 8347 1BBF              ; ---------------------
 8348 1BBF              ; The branch was here from LINE-NEW if BASIC is branching.
 8349 1BBF              ; or a continuation from above if dealing with a new sequential line.
 8350 1BBF              ; First make statement zero number one leaving others unaffected.
 8351 1BBF
 8352 1BBF              ;; LINE-USE
 8353 1BBF FE 01        L1BBF:  CP      $01             ; will set carry if zero.
 8354 1BC1 CE 00                ADC     A,$00           ; add in any carry.
 8355 1BC3
 8356 1BC3 56                   LD      D,(HL)          ; high byte of line number to D.
 8357 1BC4 23                   INC     HL              ; advance pointer.
 8358 1BC5 5E                   LD      E,(HL)          ; low byte of line number to E.
 8359 1BC6 ED 53 45 5C          LD      ($5C45),DE      ; set system variable PPC.
 8360 1BCA
 8361 1BCA 23                   INC     HL              ; advance pointer.
 8362 1BCB 5E                   LD      E,(HL)          ; low byte of line length to E.
 8363 1BCC 23                   INC     HL              ; advance pointer.
 8364 1BCD 56                   LD      D,(HL)          ; high byte of line length to D.
 8365 1BCE
 8366 1BCE EB                   EX      DE,HL           ; swap pointer to DE before
 8367 1BCF 19                   ADD     HL,DE           ; adding to address the end of line.
 8368 1BD0 23                   INC     HL              ; advance to start of next line.
 8369 1BD1
 8370 1BD1              ; -----------------------------
 8371 1BD1              ; Update NEXT LINE but consider
 8372 1BD1              ; previous line or edit line.
 8373 1BD1              ; -----------------------------
 8374 1BD1              ; The pointer will be the next line if continuing from above or to
 8375 1BD1              ; edit line end-marker ($80) if from LINE-RUN.
 8376 1BD1
 8377 1BD1              ;; NEXT-LINE
 8378 1BD1 22 55 5C     L1BD1:  LD      ($5C55),HL      ; store pointer in system variable NXTLIN
 8379 1BD4
 8380 1BD4 EB                   EX      DE,HL           ; bring back pointer to previous or edit line
 8381 1BD5 22 5D 5C             LD      ($5C5D),HL      ; and update CH_ADD with character address.
 8382 1BD8
 8383 1BD8 57                   LD      D,A             ; store statement in D.
 8384 1BD9 1E 00                LD      E,$00           ; set E to zero to suppress token searching
 8385 1BDB                                              ; if EACH-STMT is to be called.
 8386 1BDB FD 36 0A FF          LD      (IY+$0A),$FF    ; set statement NSPPC to $FF signalling
 8387 1BDF                                              ; no jump to be made.
 8388 1BDF 15                   DEC     D               ; decrement and test statement
 8389 1BE0 FD 72 0D             LD      (IY+$0D),D      ; set SUBPPC to decremented statement number.
 8390 1BE3 CA 28 1B             JP      Z,L1B28         ; to STMT-LOOP if result zero as statement is
 8391 1BE6                                              ; at start of line and address is known.
 8392 1BE6
 8393 1BE6 14                   INC     D               ; else restore statement.
 8394 1BE7 CD 8B 19             CALL    L198B           ; routine EACH-STMT finds the D'th statement
 8395 1BEA                                              ; address as E does not contain a token.
 8396 1BEA 28 08                JR      Z,L1BF4         ; forward to STMT-NEXT if address found.
 8397 1BEC
 8398 1BEC              ;; REPORT-N
 8399 1BEC CF           L1BEC:  RST     08H             ; ERROR-1
 8400 1BED 16                   DEFB    $16             ; Error Report: Statement lost
 8401 1BEE
 8402 1BEE              ; -----------------
 8403 1BEE              ; End of statement?
 8404 1BEE              ; -----------------
 8405 1BEE              ; This combination of routines is called from 20 places when
 8406 1BEE              ; the end of a statement should have been reached and all preceding
 8407 1BEE              ; syntax is in order.
 8408 1BEE
 8409 1BEE              ;; CHECK-END
 8410 1BEE CD 30 25     L1BEE:  CALL    L2530           ; routine SYNTAX-Z
 8411 1BF1 C0                   RET     NZ              ; return immediately in runtime
 8412 1BF2
 8413 1BF2 C1                   POP     BC              ; drop address of calling routine.
 8414 1BF3 C1                   POP     BC              ; drop address STMT-RET.
 8415 1BF4                                              ; and continue to find next statement.
 8416 1BF4
 8417 1BF4              ; --------------------
 8418 1BF4              ; Go to next statement
 8419 1BF4              ; --------------------
 8420 1BF4              ; Acceptable characters at this point are carriage return and ':'.
 8421 1BF4              ; If so go to next statement which in the first case will be on next line.
 8422 1BF4
 8423 1BF4              ;; STMT-NEXT
 8424 1BF4 DF           L1BF4:  RST     18H             ; GET-CHAR - ignoring white space etc.
 8425 1BF5
 8426 1BF5 FE 0D                CP      $0D             ; is it carriage return ?
 8427 1BF7 28 BA                JR      Z,L1BB3         ; back to LINE-END if so.
 8428 1BF9
 8429 1BF9 FE 3A                CP      $3A             ; is it ':' ?
 8430 1BFB CA 28 1B             JP      Z,L1B28         ; jump back to STMT-LOOP to consider
 8431 1BFE                                              ; further statements
 8432 1BFE
 8433 1BFE C3 8A 1C             JP      L1C8A           ; jump to REPORT-C with any other character
 8434 1C01                                              ; 'Nonsense in BASIC'.
 8435 1C01
 8436 1C01              ; Note. the two-byte sequence 'rst 08; defb $0b' could replace the above jp.
 8437 1C01
 8438 1C01              ; -------------------
 8439 1C01              ; Command class table
 8440 1C01              ; -------------------
 8441 1C01              ;
 8442 1C01
 8443 1C01              ;; class-tbl
 8444 1C01 0F           L1C01:  DEFB    L1C10 - $       ; 0F offset to Address: CLASS-00
 8445 1C02 1D                   DEFB    L1C1F - $       ; 1D offset to Address: CLASS-01
 8446 1C03 4B                   DEFB    L1C4E - $       ; 4B offset to Address: CLASS-02
 8447 1C04 09                   DEFB    L1C0D - $       ; 09 offset to Address: CLASS-03
 8448 1C05 67                   DEFB    L1C6C - $       ; 67 offset to Address: CLASS-04
 8449 1C06 0B                   DEFB    L1C11 - $       ; 0B offset to Address: CLASS-05
 8450 1C07 7B                   DEFB    L1C82 - $       ; 7B offset to Address: CLASS-06
 8451 1C08 8E                   DEFB    L1C96 - $       ; 8E offset to Address: CLASS-07
 8452 1C09 71                   DEFB    L1C7A - $       ; 71 offset to Address: CLASS-08
 8453 1C0A B4                   DEFB    L1CBE - $       ; B4 offset to Address: CLASS-09
 8454 1C0B 81                   DEFB    L1C8C - $       ; 81 offset to Address: CLASS-0A
 8455 1C0C CF                   DEFB    L1CDB - $       ; CF offset to Address: CLASS-0B
 8456 1C0D
 8457 1C0D
 8458 1C0D              ; --------------------------------
 8459 1C0D              ; Command classes---00, 03, and 05
 8460 1C0D              ; --------------------------------
 8461 1C0D              ; class-03 e.g. RUN or RUN 200   ;  optional operand
 8462 1C0D              ; class-00 e.g. CONTINUE         ;  no operand
 8463 1C0D              ; class-05 e.g. PRINT            ;  variable syntax checked by routine
 8464 1C0D
 8465 1C0D              ;; CLASS-03
 8466 1C0D CD DE 1C     L1C0D:  CALL    L1CDE           ; routine FETCH-NUM
 8467 1C10
 8468 1C10              ;; CLASS-00
 8469 1C10
 8470 1C10 BF           L1C10:  CP      A               ; reset zero flag.
 8471 1C11
 8472 1C11              ; if entering here then all class routines are entered with zero reset.
 8473 1C11
 8474 1C11              ;; CLASS-05
 8475 1C11 C1           L1C11:  POP     BC              ; drop address SCAN-LOOP.
 8476 1C12 CC EE 1B             CALL    Z,L1BEE         ; if zero set then call routine CHECK-END >>>
 8477 1C15                                              ; as should be no further characters.
 8478 1C15
 8479 1C15 EB                   EX      DE,HL           ; save HL to DE.
 8480 1C16 2A 74 5C             LD      HL,($5C74)      ; fetch T_ADDR
 8481 1C19 4E                   LD      C,(HL)          ; fetch low byte of routine
 8482 1C1A 23                   INC     HL              ; address next.
 8483 1C1B 46                   LD      B,(HL)          ; fetch high byte of routine.
 8484 1C1C EB                   EX      DE,HL           ; restore HL from DE
 8485 1C1D C5                   PUSH    BC              ; push the address
 8486 1C1E C9                   RET                     ; and make an indirect jump to the command.
 8487 1C1F
 8488 1C1F              ; --------------------------------
 8489 1C1F              ; Command classes---01, 02, and 04
 8490 1C1F              ; --------------------------------
 8491 1C1F              ; class-01  e.g. LET A = 2*3     ; a variable is reqd
 8492 1C1F
 8493 1C1F              ; This class routine is also called from INPUT and READ to find the
 8494 1C1F              ; destination variable for an assignment.
 8495 1C1F
 8496 1C1F              ;; CLASS-01
 8497 1C1F CD B2 28     L1C1F:  CALL    L28B2           ; routine LOOK-VARS returns carry set if not
 8498 1C22                                              ; found in runtime.
 8499 1C22
 8500 1C22              ; ----------------------
 8501 1C22              ; Variable in assignment
 8502 1C22              ; ----------------------
 8503 1C22              ;
 8504 1C22              ;
 8505 1C22
 8506 1C22              ;; VAR-A-1
 8507 1C22 FD 36 37 00  L1C22:  LD      (IY+$37),$00    ; set FLAGX to zero
 8508 1C26 30 08                JR      NC,L1C30        ; forward to VAR-A-2 if found or checking
 8509 1C28                                              ; syntax.
 8510 1C28
 8511 1C28 FD CB 37 CE          SET     1,(IY+$37)      ; FLAGX  - Signal a new variable
 8512 1C2C 20 18                JR      NZ,L1C46        ; to VAR-A-3 if not assigning to an array
 8513 1C2E                                              ; e.g. LET a$(3,3) = "X"
 8514 1C2E
 8515 1C2E              ;; REPORT-2
 8516 1C2E CF           L1C2E:  RST     08H             ; ERROR-1
 8517 1C2F 01                   DEFB    $01             ; Error Report: Variable not found
 8518 1C30
 8519 1C30              ;; VAR-A-2
 8520 1C30 CC 96 29     L1C30:  CALL    Z,L2996         ; routine STK-VAR considers a subscript/slice
 8521 1C33 FD CB 01 76          BIT     6,(IY+$01)      ; test FLAGS  - Numeric or string result ?
 8522 1C37 20 0D                JR      NZ,L1C46        ; to VAR-A-3 if numeric
 8523 1C39
 8524 1C39 AF                   XOR     A               ; default to array/slice - to be retained.
 8525 1C3A CD 30 25             CALL    L2530           ; routine SYNTAX-Z
 8526 1C3D C4 F1 2B             CALL    NZ,L2BF1        ; routine STK-FETCH is called in runtime
 8527 1C40                                              ; may overwrite A with 1.
 8528 1C40 21 71 5C             LD      HL,$5C71        ; address system variable FLAGX
 8529 1C43 B6                   OR      (HL)            ; set bit 0 if simple variable to be reclaimed
 8530 1C44 77                   LD      (HL),A          ; update FLAGX
 8531 1C45 EB                   EX      DE,HL           ; start of string/subscript to DE
 8532 1C46
 8533 1C46              ;; VAR-A-3
 8534 1C46 ED 43 72 5C  L1C46:  LD      ($5C72),BC      ; update STRLEN
 8535 1C4A 22 4D 5C             LD      ($5C4D),HL      ; and DEST of assigned string.
 8536 1C4D C9                   RET                     ; return.
 8537 1C4E
 8538 1C4E              ; -------------------------------------------------
 8539 1C4E              ; class-02 e.g. LET a = 1 + 1   ; an expression must follow
 8540 1C4E
 8541 1C4E              ;; CLASS-02
 8542 1C4E C1           L1C4E:  POP     BC              ; drop return address SCAN-LOOP
 8543 1C4F CD 56 1C             CALL    L1C56           ; routine VAL-FET-1 is called to check
 8544 1C52                                              ; expression and assign result in runtime
 8545 1C52 CD EE 1B             CALL    L1BEE           ; routine CHECK-END checks nothing else
 8546 1C55                                              ; is present in statement.
 8547 1C55 C9                   RET                     ; Return
 8548 1C56
 8549 1C56              ; -------------
 8550 1C56              ; Fetch a value
 8551 1C56              ; -------------
 8552 1C56              ;
 8553 1C56              ;
 8554 1C56
 8555 1C56              ;; VAL-FET-1
 8556 1C56 3A 3B 5C     L1C56:  LD      A,($5C3B)       ; initial FLAGS to A
 8557 1C59
 8558 1C59              ;; VAL-FET-2
 8559 1C59 F5           L1C59:  PUSH    AF              ; save A briefly
 8560 1C5A CD FB 24             CALL    L24FB           ; routine SCANNING evaluates expression.
 8561 1C5D F1                   POP     AF              ; restore A
 8562 1C5E FD 56 01             LD      D,(IY+$01)      ; post-SCANNING FLAGS to D
 8563 1C61 AA                   XOR     D               ; xor the two sets of flags
 8564 1C62 E6 40                AND     $40             ; pick up bit 6 of xored FLAGS should be zero
 8565 1C64 20 24                JR      NZ,L1C8A        ; forward to REPORT-C if not zero
 8566 1C66                                              ; 'Nonsense in BASIC' - results don't agree.
 8567 1C66
 8568 1C66 CB 7A                BIT     7,D             ; test FLAGS - is syntax being checked ?
 8569 1C68 C2 FF 2A             JP      NZ,L2AFF        ; jump forward to LET to make the assignment
 8570 1C6B                                              ; in runtime.
 8571 1C6B
 8572 1C6B C9                   RET                     ; but return from here if checking syntax.
 8573 1C6C
 8574 1C6C              ; ------------------
 8575 1C6C              ; Command class---04
 8576 1C6C              ; ------------------
 8577 1C6C              ; class-04 e.g. FOR i            ; a single character variable must follow
 8578 1C6C
 8579 1C6C              ;; CLASS-04
 8580 1C6C CD B2 28     L1C6C:  CALL    L28B2           ; routine LOOK-VARS
 8581 1C6F F5                   PUSH    AF              ; preserve flags.
 8582 1C70 79                   LD      A,C             ; fetch type - should be 011xxxxx
 8583 1C71 F6 9F                OR      $9F             ; combine with 10011111.
 8584 1C73 3C                   INC     A               ; test if now $FF by incrementing.
 8585 1C74 20 14                JR      NZ,L1C8A        ; forward to REPORT-C if result not zero.
 8586 1C76
 8587 1C76 F1                   POP     AF              ; else restore flags.
 8588 1C77 18 A9                JR      L1C22           ; back to VAR-A-1
 8589 1C79
 8590 1C79
 8591 1C79              ; --------------------------------
 8592 1C79              ; Expect numeric/string expression
 8593 1C79              ; --------------------------------
 8594 1C79              ; This routine is used to get the two coordinates of STRING$, ATTR and POINT.
 8595 1C79              ; It is also called from PRINT-ITEM to get the two numeric expressions that
 8596 1C79              ; follow the AT ( in PRINT AT, INPUT AT).
 8597 1C79
 8598 1C79              ;; NEXT-2NUM
 8599 1C79 E7           L1C79:  RST     20H             ; NEXT-CHAR advance past 'AT' or '('.
 8600 1C7A
 8601 1C7A              ; --------
 8602 1C7A              ; class-08 e.g. POKE 65535,2     ; two numeric expressions separated by comma
 8603 1C7A              ;; CLASS-08
 8604 1C7A              ;; EXPT-2NUM
 8605 1C7A CD 82 1C     L1C7A:  CALL    L1C82           ; routine EXPT-1NUM is called for first
 8606 1C7D                                              ; numeric expression
 8607 1C7D FE 2C                CP      $2C             ; is character ',' ?
 8608 1C7F 20 09                JR      NZ,L1C8A        ; to REPORT-C if not required separator.
 8609 1C81                                              ; 'Nonsense in BASIC'.
 8610 1C81
 8611 1C81 E7                   RST     20H             ; NEXT-CHAR
 8612 1C82
 8613 1C82              ; ->
 8614 1C82              ;  class-06  e.g. GOTO a*1000   ; a numeric expression must follow
 8615 1C82              ;; CLASS-06
 8616 1C82              ;; EXPT-1NUM
 8617 1C82 CD FB 24     L1C82:  CALL    L24FB           ; routine SCANNING
 8618 1C85 FD CB 01 76          BIT     6,(IY+$01)      ; test FLAGS  - Numeric or string result ?
 8619 1C89 C0                   RET     NZ              ; return if result is numeric.
 8620 1C8A
 8621 1C8A              ;; REPORT-C
 8622 1C8A CF           L1C8A:  RST     08H             ; ERROR-1
 8623 1C8B 0B                   DEFB    $0B             ; Error Report: Nonsense in BASIC
 8624 1C8C
 8625 1C8C              ; ---------------------------------------------------------------
 8626 1C8C              ; class-0A e.g. ERASE "????"    ; a string expression must follow.
 8627 1C8C              ;                               ; these only occur in unimplemented commands
 8628 1C8C              ;                               ; although the routine expt-exp is called
 8629 1C8C              ;                               ; from SAVE-ETC
 8630 1C8C
 8631 1C8C              ;; CLASS-0A
 8632 1C8C              ;; EXPT-EXP
 8633 1C8C CD FB 24     L1C8C:  CALL    L24FB           ; routine SCANNING
 8634 1C8F FD CB 01 76          BIT     6,(IY+$01)      ; test FLAGS  - Numeric or string result ?
 8635 1C93 C8                   RET     Z               ; return if string result.
 8636 1C94
 8637 1C94 18 F4                JR      L1C8A           ; back to REPORT-C if numeric.
 8638 1C96
 8639 1C96              ; ---------------------
 8640 1C96              ; Set permanent colours
 8641 1C96              ; class 07
 8642 1C96              ; ---------------------
 8643 1C96              ; class-07 e.g. PAPER 6          ; a single class for a collection of
 8644 1C96              ;                               ; similar commands. Clever.
 8645 1C96              ;
 8646 1C96              ; Note. these commands should ensure that current channel is 'S'
 8647 1C96
 8648 1C96              ;; CLASS-07
 8649 1C96 FD CB 01 7E  L1C96:  BIT     7,(IY+$01)      ; test FLAGS - checking syntax only ?
 8650 1C9A                                              ; Note. there is a subroutine to do this.
 8651 1C9A FD CB 02 86          RES     0,(IY+$02)      ; update TV_FLAG - signal main screen in use
 8652 1C9E C4 4D 0D             CALL    NZ,L0D4D        ; routine TEMPS is called in runtime.
 8653 1CA1 F1                   POP     AF              ; drop return address SCAN-LOOP
 8654 1CA2 3A 74 5C             LD      A,($5C74)       ; T_ADDR_lo to accumulator.
 8655 1CA5                                              ; points to '$07' entry + 1
 8656 1CA5                                              ; e.g. for INK points to $EC now
 8657 1CA5
 8658 1CA5              ; Note if you move alter the syntax table next line may have to be altered.
 8659 1CA5
 8660 1CA5              ; Note. For ZASM assembler replace following expression with SUB $13.
 8661 1CA5
spectrum_rom.asm(8662): warning: value 0x1A13 is truncated to 8bit value: 0x13
 8662 1CA5 D6 13        L1CA5:  SUB     L1AEB-$D8 % 256 ; convert $EB to $D8 ('INK') etc.
 8663 1CA7                                              ; ( is SUB $13 in standard ROM )
 8664 1CA7
 8665 1CA7 CD FC 21             CALL    L21FC           ; routine CO-TEMP-4
 8666 1CAA CD EE 1B             CALL    L1BEE           ; routine CHECK-END check that nothing else
 8667 1CAD                                              ; in statement.
 8668 1CAD
 8669 1CAD              ; return here in runtime.
 8670 1CAD
 8671 1CAD 2A 8F 5C             LD      HL,($5C8F)      ; pick up ATTR_T and MASK_T
 8672 1CB0 22 8D 5C             LD      ($5C8D),HL      ; and store in ATTR_P and MASK_P
 8673 1CB3 21 91 5C             LD      HL,$5C91        ; point to P_FLAG.
 8674 1CB6 7E                   LD      A,(HL)          ; pick up in A
 8675 1CB7 07                   RLCA                    ; rotate to left
 8676 1CB8 AE                   XOR     (HL)            ; combine with HL
 8677 1CB9 E6 AA                AND     $AA             ; 10101010
 8678 1CBB AE                   XOR     (HL)            ; only permanent bits affected
 8679 1CBC 77                   LD      (HL),A          ; reload into P_FLAG.
 8680 1CBD C9                   RET                     ; return.
 8681 1CBE
 8682 1CBE              ; ------------------
 8683 1CBE              ; Command class---09
 8684 1CBE              ; ------------------
 8685 1CBE              ; e.g. PLOT PAPER 0; 128,88     ; two coordinates preceded by optional
 8686 1CBE              ;                               ; embedded colour items.
 8687 1CBE              ;
 8688 1CBE              ; Note. this command should ensure that current channel is actually 'S'.
 8689 1CBE
 8690 1CBE              ;; CLASS-09
 8691 1CBE CD 30 25     L1CBE:  CALL    L2530           ; routine SYNTAX-Z
 8692 1CC1 28 13                JR      Z,L1CD6         ; forward to CL-09-1 if checking syntax.
 8693 1CC3
 8694 1CC3 FD CB 02 86          RES     0,(IY+$02)      ; update TV_FLAG - signal main screen in use
 8695 1CC7 CD 4D 0D             CALL    L0D4D           ; routine TEMPS is called.
 8696 1CCA 21 90 5C             LD      HL,$5C90        ; point to MASK_T
 8697 1CCD 7E                   LD      A,(HL)          ; fetch mask to accumulator.
 8698 1CCE F6 F8                OR      $F8             ; or with 11111000 paper/bright/flash 8
 8699 1CD0 77                   LD      (HL),A          ; mask back to MASK_T system variable.
 8700 1CD1 FD CB 57 B6          RES     6,(IY+$57)      ; reset P_FLAG  - signal NOT PAPER 9 ?
 8701 1CD5
 8702 1CD5 DF                   RST     18H             ; GET-CHAR
 8703 1CD6
 8704 1CD6              ;; CL-09-1
 8705 1CD6 CD E2 21     L1CD6:  CALL    L21E2           ; routine CO-TEMP-2 deals with any embedded
 8706 1CD9                                              ; colour items.
 8707 1CD9 18 9F                JR      L1C7A           ; exit via EXPT-2NUM to check for x,y.
 8708 1CDB
 8709 1CDB              ; Note. if either of the numeric expressions contain STR$ then the flag setting
 8710 1CDB              ; above will be undone when the channel flags are reset during STR$.
 8711 1CDB              ; e.g.
 8712 1CDB              ; 10 BORDER 3 : PLOT VAL STR$ 128, VAL STR$ 100
 8713 1CDB              ; credit John Elliott.
 8714 1CDB
 8715 1CDB              ; ------------------
 8716 1CDB              ; Command class---0B
 8717 1CDB              ; ------------------
 8718 1CDB              ; Again a single class for four commands.
 8719 1CDB              ; This command just jumps back to SAVE-ETC to handle the four tape commands.
 8720 1CDB              ; The routine itself works out which command has called it by examining the
 8721 1CDB              ; address in T_ADDR_lo. Note therefore that the syntax table has to be
 8722 1CDB              ; located where these and other sequential command addresses are not split
 8723 1CDB              ; over a page boundary.
 8724 1CDB
 8725 1CDB              ;; CLASS-0B
 8726 1CDB C3 05 06     L1CDB:  JP      L0605           ; jump way back to SAVE-ETC
 8727 1CDE
 8728 1CDE              ; --------------
 8729 1CDE              ; Fetch a number
 8730 1CDE              ; --------------
 8731 1CDE              ; This routine is called from CLASS-03 when a command may be followed by
 8732 1CDE              ; an optional numeric expression e.g. RUN. If the end of statement has
 8733 1CDE              ; been reached then zero is used as the default.
 8734 1CDE              ; Also called from LIST-4.
 8735 1CDE
 8736 1CDE              ;; FETCH-NUM
 8737 1CDE FE 0D        L1CDE:  CP      $0D             ; is character a carriage return ?
 8738 1CE0 28 04                JR      Z,L1CE6         ; forward to USE-ZERO if so
 8739 1CE2
 8740 1CE2 FE 3A                CP      $3A             ; is it ':' ?
 8741 1CE4 20 9C                JR      NZ,L1C82        ; forward to EXPT-1NUM if not.
 8742 1CE6                                              ; else continue and use zero.
 8743 1CE6
 8744 1CE6              ; ----------------
 8745 1CE6              ; Use zero routine
 8746 1CE6              ; ----------------
 8747 1CE6              ; This routine is called four times to place the value zero on the
 8748 1CE6              ; calculator stack as a default value in runtime.
 8749 1CE6
 8750 1CE6              ;; USE-ZERO
 8751 1CE6 CD 30 25     L1CE6:  CALL    L2530           ; routine SYNTAX-Z  (UNSTACK-Z?)
 8752 1CE9 C8                   RET     Z               ;
 8753 1CEA
 8754 1CEA EF                   RST     28H             ;; FP-CALC
 8755 1CEB A0                   DEFB    $A0             ;;stk-zero       ;0.
 8756 1CEC 38                   DEFB    $38             ;;end-calc
 8757 1CED
 8758 1CED C9                   RET                     ; return.
 8759 1CEE
 8760 1CEE              ; -------------------
 8761 1CEE              ; Handle STOP command
 8762 1CEE              ; -------------------
 8763 1CEE              ; Command Syntax: STOP
 8764 1CEE              ; One of the shortest and least used commands. As with 'OK' not an error.
 8765 1CEE
 8766 1CEE              ;; REPORT-9
 8767 1CEE              ;; STOP
 8768 1CEE CF           L1CEE:  RST     08H             ; ERROR-1
 8769 1CEF 08                   DEFB    $08             ; Error Report: STOP statement
 8770 1CF0
 8771 1CF0              ; -----------------
 8772 1CF0              ; Handle IF command
 8773 1CF0              ; -----------------
 8774 1CF0              ; e.g. IF score>100 THEN PRINT "You Win"
 8775 1CF0              ; The parser has already checked the expression the result of which is on
 8776 1CF0              ; the calculator stack. The presence of the 'THEN' separator has also been
 8777 1CF0              ; checked and CH-ADD points to the command after THEN.
 8778 1CF0              ;
 8779 1CF0
 8780 1CF0              ;; IF
 8781 1CF0 C1           L1CF0:  POP     BC              ; drop return address - STMT-RET
 8782 1CF1 CD 30 25             CALL    L2530           ; routine SYNTAX-Z
 8783 1CF4 28 0A                JR      Z,L1D00         ; forward to IF-1 if checking syntax
 8784 1CF6                                              ; to check syntax of PRINT "You Win"
 8785 1CF6
 8786 1CF6
 8787 1CF6 EF                   RST     28H             ;; FP-CALC    score>100 (1=TRUE 0=FALSE)
 8788 1CF7 02                   DEFB    $02             ;;delete      .
 8789 1CF8 38                   DEFB    $38             ;;end-calc
 8790 1CF9
 8791 1CF9 EB                   EX      DE,HL           ; make HL point to deleted value
 8792 1CFA CD E9 34             CALL    L34E9           ; routine TEST-ZERO
 8793 1CFD DA B3 1B             JP      C,L1BB3         ; jump to LINE-END if FALSE (0)
 8794 1D00
 8795 1D00              ;; IF-1
 8796 1D00 C3 29 1B     L1D00:  JP      L1B29           ; to STMT-L-1, if true (1) to execute command
 8797 1D03                                              ; after 'THEN' token.
 8798 1D03
 8799 1D03              ; ------------------
 8800 1D03              ; Handle FOR command
 8801 1D03              ; ------------------
 8802 1D03              ; e.g. FOR i = 0 TO 1 STEP 0.1
 8803 1D03              ; Using the syntax tables, the parser has already checked for a start and
 8804 1D03              ; limit value and also for the intervening separator.
 8805 1D03              ; the two values v,l are on the calculator stack.
 8806 1D03              ; CLASS-04 has also checked the variable and the name is in STRLEN_lo.
 8807 1D03              ; The routine begins by checking for an optional STEP.
 8808 1D03
 8809 1D03              ;; FOR
 8810 1D03 FE CD        L1D03:  CP      $CD             ; is there a 'STEP' ?
 8811 1D05 20 09                JR      NZ,L1D10        ; to F-USE-1 if not to use 1 as default.
 8812 1D07
 8813 1D07 E7                   RST     20H             ; NEXT-CHAR
 8814 1D08 CD 82 1C             CALL    L1C82           ; routine EXPT-1NUM
 8815 1D0B CD EE 1B             CALL    L1BEE           ; routine CHECK-END
 8816 1D0E 18 06                JR      L1D16           ; to F-REORDER
 8817 1D10
 8818 1D10              ; ---
 8819 1D10
 8820 1D10              ;; F-USE-1
 8821 1D10 CD EE 1B     L1D10:  CALL    L1BEE           ; routine CHECK-END
 8822 1D13
 8823 1D13 EF                   RST     28H             ;; FP-CALC      v,l.
 8824 1D14 A1                   DEFB    $A1             ;;stk-one       v,l,1=s.
 8825 1D15 38                   DEFB    $38             ;;end-calc
 8826 1D16
 8827 1D16
 8828 1D16              ;; F-REORDER
 8829 1D16 EF           L1D16:  RST     28H             ;; FP-CALC       v,l,s.
 8830 1D17 C0                   DEFB    $C0             ;;st-mem-0       v,l,s.
 8831 1D18 02                   DEFB    $02             ;;delete         v,l.
 8832 1D19 01                   DEFB    $01             ;;exchange       l,v.
 8833 1D1A E0                   DEFB    $E0             ;;get-mem-0      l,v,s.
 8834 1D1B 01                   DEFB    $01             ;;exchange       l,s,v.
 8835 1D1C 38                   DEFB    $38             ;;end-calc
 8836 1D1D
 8837 1D1D CD FF 2A             CALL    L2AFF           ; routine LET assigns the initial value v to
 8838 1D20                                              ; the variable altering type if necessary.
 8839 1D20 22 68 5C             LD      ($5C68),HL      ; The system variable MEM is made to point to
 8840 1D23                                              ; the variable instead of its normal
 8841 1D23                                              ; location MEMBOT
 8842 1D23 2B                   DEC     HL              ; point to single-character name
 8843 1D24 7E                   LD      A,(HL)          ; fetch name
 8844 1D25 CB FE                SET     7,(HL)          ; set bit 7 at location
 8845 1D27 01 06 00             LD      BC,$0006        ; add six to HL
 8846 1D2A 09                   ADD     HL,BC           ; to address where limit should be.
 8847 1D2B 07                   RLCA                    ; test bit 7 of original name.
 8848 1D2C 38 06                JR      C,L1D34         ; forward to F-L-S if already a FOR/NEXT
 8849 1D2E                                              ; variable
 8850 1D2E
 8851 1D2E 0E 0D                LD      C,$0D           ; otherwise an additional 13 bytes are needed.
 8852 1D30                                              ; 5 for each value, two for line number and
 8853 1D30                                              ; 1 byte for looping statement.
 8854 1D30 CD 55 16             CALL    L1655           ; routine MAKE-ROOM creates them.
 8855 1D33 23                   INC     HL              ; make HL address limit.
 8856 1D34
 8857 1D34              ;; F-L-S
 8858 1D34 E5           L1D34:  PUSH    HL              ; save position.
 8859 1D35
 8860 1D35 EF                   RST     28H             ;; FP-CALC         l,s.
 8861 1D36 02                   DEFB    $02             ;;delete           l.
 8862 1D37 02                   DEFB    $02             ;;delete           .
 8863 1D38 38                   DEFB    $38             ;;end-calc
 8864 1D39                                              ; DE points to STKEND, l.
 8865 1D39
 8866 1D39 E1                   POP     HL              ; restore variable position
 8867 1D3A EB                   EX      DE,HL           ; swap pointers
 8868 1D3B 0E 0A                LD      C,$0A           ; ten bytes to move
 8869 1D3D ED B0                LDIR                    ; Copy 'deleted' values to variable.
 8870 1D3F 2A 45 5C             LD      HL,($5C45)      ; Load with current line number from PPC
 8871 1D42 EB                   EX      DE,HL           ; exchange pointers.
 8872 1D43 73                   LD      (HL),E          ; save the looping line
 8873 1D44 23                   INC     HL              ; in the next
 8874 1D45 72                   LD      (HL),D          ; two locations.
 8875 1D46 FD 56 0D             LD      D,(IY+$0D)      ; fetch statement from SUBPPC system variable.
 8876 1D49 14                   INC     D               ; increment statement.
 8877 1D4A 23                   INC     HL              ; and pointer
 8878 1D4B 72                   LD      (HL),D          ; and store the looping statement.
 8879 1D4C                                              ;
 8880 1D4C CD DA 1D             CALL    L1DDA           ; routine NEXT-LOOP considers an initial
 8881 1D4F D0                   RET     NC              ; iteration. Return to STMT-RET if a loop is
 8882 1D50                                              ; possible to execute next statement.
 8883 1D50
 8884 1D50              ; no loop is possible so execution continues after the matching 'NEXT'
 8885 1D50
 8886 1D50 FD 46 38             LD      B,(IY+$38)      ; get single-character name from STRLEN_lo
 8887 1D53 2A 45 5C             LD      HL,($5C45)      ; get the current line from PPC
 8888 1D56 22 42 5C             LD      ($5C42),HL      ; and store it in NEWPPC
 8889 1D59 3A 47 5C             LD      A,($5C47)       ; fetch current statement from SUBPPC
 8890 1D5C ED 44                NEG                     ; Negate as counter decrements from zero
 8891 1D5E                                              ; initially and we are in the middle of a
 8892 1D5E                                              ; line.
 8893 1D5E 57                   LD      D,A             ; Store result in D.
 8894 1D5F 2A 5D 5C             LD      HL,($5C5D)      ; get current address from CH_ADD
 8895 1D62 1E F3                LD      E,$F3           ; search will be for token 'NEXT'
 8896 1D64
 8897 1D64              ;; F-LOOP
 8898 1D64 C5           L1D64:  PUSH    BC              ; save variable name.
 8899 1D65 ED 4B 55 5C          LD      BC,($5C55)      ; fetch NXTLIN
 8900 1D69 CD 86 1D             CALL    L1D86           ; routine LOOK-PROG searches for 'NEXT' token.
 8901 1D6C ED 43 55 5C          LD      ($5C55),BC      ; update NXTLIN
 8902 1D70 C1                   POP     BC              ; and fetch the letter
 8903 1D71 38 11                JR      C,L1D84         ; forward to REPORT-I if the end of program
 8904 1D73                                              ; was reached by LOOK-PROG.
 8905 1D73                                              ; 'FOR without NEXT'
 8906 1D73
 8907 1D73 E7                   RST     20H             ; NEXT-CHAR fetches character after NEXT
 8908 1D74 F6 20                OR      $20             ; ensure it is upper-case.
 8909 1D76 B8                   CP      B               ; compare with FOR variable name
 8910 1D77 28 03                JR      Z,L1D7C         ; forward to F-FOUND if it matches.
 8911 1D79
 8912 1D79              ; but if no match i.e. nested FOR/NEXT loops then continue search.
 8913 1D79
 8914 1D79 E7                   RST     20H             ; NEXT-CHAR
 8915 1D7A 18 E8                JR      L1D64           ; back to F-LOOP
 8916 1D7C
 8917 1D7C              ; ---
 8918 1D7C
 8919 1D7C
 8920 1D7C              ;; F-FOUND
 8921 1D7C E7           L1D7C:  RST     20H             ; NEXT-CHAR
 8922 1D7D 3E 01                LD      A,$01           ; subtract the negated counter from 1
 8923 1D7F 92                   SUB     D               ; to give the statement after the NEXT
 8924 1D80 32 44 5C             LD      ($5C44),A       ; set system variable NSPPC
 8925 1D83 C9                   RET                     ; return to STMT-RET to branch to new
 8926 1D84                                              ; line and statement. ->
 8927 1D84              ; ---
 8928 1D84
 8929 1D84              ;; REPORT-I
 8930 1D84 CF           L1D84:  RST     08H             ; ERROR-1
 8931 1D85 11                   DEFB    $11             ; Error Report: FOR without NEXT
 8932 1D86
 8933 1D86              ; ---------
 8934 1D86              ; LOOK-PROG
 8935 1D86              ; ---------
 8936 1D86              ; Find DATA, DEF FN or NEXT.
 8937 1D86              ; This routine searches the program area for one of the above three keywords.
 8938 1D86              ; On entry, HL points to start of search area.
 8939 1D86              ; The token is in E, and D holds a statement count, decremented from zero.
 8940 1D86
 8941 1D86              ;; LOOK-PROG
 8942 1D86 7E           L1D86:  LD      A,(HL)          ; fetch current character
 8943 1D87 FE 3A                CP      $3A             ; is it ':' a statement separator ?
 8944 1D89 28 18                JR      Z,L1DA3         ; forward to LOOK-P-2 if so.
 8945 1D8B
 8946 1D8B              ; The starting point was PROG - 1 or the end of a line.
 8947 1D8B
 8948 1D8B              ;; LOOK-P-1
 8949 1D8B 23           L1D8B:  INC     HL              ; increment pointer to address
 8950 1D8C 7E                   LD      A,(HL)          ; the high byte of line number
 8951 1D8D E6 C0                AND     $C0             ; test for program end marker $80 or a
 8952 1D8F                                              ; variable
 8953 1D8F 37                   SCF                     ; Set Carry Flag
 8954 1D90 C0                   RET     NZ              ; return with carry set if at end
 8955 1D91                                              ; of program.           ->
 8956 1D91
 8957 1D91 46                   LD      B,(HL)          ; high byte of line number to B
 8958 1D92 23                   INC     HL              ;
 8959 1D93 4E                   LD      C,(HL)          ; low byte to C.
 8960 1D94 ED 43 42 5C          LD      ($5C42),BC      ; set system variable NEWPPC.
 8961 1D98 23                   INC     HL              ;
 8962 1D99 4E                   LD      C,(HL)          ; low byte of line length to C.
 8963 1D9A 23                   INC     HL              ;
 8964 1D9B 46                   LD      B,(HL)          ; high byte to B.
 8965 1D9C E5                   PUSH    HL              ; save address
 8966 1D9D 09                   ADD     HL,BC           ; add length to position.
 8967 1D9E 44                   LD      B,H             ; and save result
 8968 1D9F 4D                   LD      C,L             ; in BC.
 8969 1DA0 E1                   POP     HL              ; restore address.
 8970 1DA1 16 00                LD      D,$00           ; initialize statement counter to zero.
 8971 1DA3
 8972 1DA3              ;; LOOK-P-2
 8973 1DA3 C5           L1DA3:  PUSH    BC              ; save address of next line
 8974 1DA4 CD 8B 19             CALL    L198B           ; routine EACH-STMT searches current line.
 8975 1DA7 C1                   POP     BC              ; restore address.
 8976 1DA8 D0                   RET     NC              ; return if match was found. ->
 8977 1DA9
 8978 1DA9 18 E0                JR      L1D8B           ; back to LOOK-P-1 for next line.
 8979 1DAB
 8980 1DAB              ; -------------------
 8981 1DAB              ; Handle NEXT command
 8982 1DAB              ; -------------------
 8983 1DAB              ; e.g. NEXT i
 8984 1DAB              ; The parameter tables have already evaluated the presence of a variable
 8985 1DAB
 8986 1DAB              ;; NEXT
 8987 1DAB FD CB 37 4E  L1DAB:  BIT     1,(IY+$37)      ; test FLAGX - handling a new variable ?
 8988 1DAF C2 2E 1C             JP      NZ,L1C2E        ; jump back to REPORT-2 if so
 8989 1DB2                                              ; 'Variable not found'
 8990 1DB2
 8991 1DB2              ; now test if found variable is a simple variable uninitialized by a FOR.
 8992 1DB2
 8993 1DB2 2A 4D 5C             LD      HL,($5C4D)      ; load address of variable from DEST
 8994 1DB5 CB 7E                BIT     7,(HL)          ; is it correct type ?
 8995 1DB7 28 1F                JR      Z,L1DD8         ; forward to REPORT-1 if not
 8996 1DB9                                              ; 'NEXT without FOR'
 8997 1DB9
 8998 1DB9 23                   INC     HL              ; step past variable name
 8999 1DBA 22 68 5C             LD      ($5C68),HL      ; and set MEM to point to three 5-byte values
 9000 1DBD                                              ; value, limit, step.
 9001 1DBD
 9002 1DBD EF                   RST     28H             ;; FP-CALC     add step and re-store
 9003 1DBE E0                   DEFB    $E0             ;;get-mem-0    v.
 9004 1DBF E2                   DEFB    $E2             ;;get-mem-2    v,s.
 9005 1DC0 0F                   DEFB    $0F             ;;addition     v+s.
 9006 1DC1 C0                   DEFB    $C0             ;;st-mem-0     v+s.
 9007 1DC2 02                   DEFB    $02             ;;delete       .
 9008 1DC3 38                   DEFB    $38             ;;end-calc
 9009 1DC4
 9010 1DC4 CD DA 1D             CALL    L1DDA           ; routine NEXT-LOOP tests against limit.
 9011 1DC7 D8                   RET     C               ; return if no more iterations possible.
 9012 1DC8
 9013 1DC8 2A 68 5C             LD      HL,($5C68)      ; find start of variable contents from MEM.
 9014 1DCB 11 0F 00             LD      DE,$000F        ; add 3*5 to
 9015 1DCE 19                   ADD     HL,DE           ; address the looping line number
 9016 1DCF 5E                   LD      E,(HL)          ; low byte to E
 9017 1DD0 23                   INC     HL              ;
 9018 1DD1 56                   LD      D,(HL)          ; high byte to D
 9019 1DD2 23                   INC     HL              ; address looping statement
 9020 1DD3 66                   LD      H,(HL)          ; and store in H
 9021 1DD4 EB                   EX      DE,HL           ; swap registers
 9022 1DD5 C3 73 1E             JP      L1E73           ; exit via GO-TO-2 to execute another loop.
 9023 1DD8
 9024 1DD8              ; ---
 9025 1DD8
 9026 1DD8              ;; REPORT-1
 9027 1DD8 CF           L1DD8:  RST     08H             ; ERROR-1
 9028 1DD9 00                   DEFB    $00             ; Error Report: NEXT without FOR
 9029 1DDA
 9030 1DDA
 9031 1DDA              ; -----------------
 9032 1DDA              ; Perform NEXT loop
 9033 1DDA              ; -----------------
 9034 1DDA              ; This routine is called from the FOR command to test for an initial
 9035 1DDA              ; iteration and from the NEXT command to test for all subsequent iterations.
 9036 1DDA              ; the system variable MEM addresses the variable's contents which, in the
 9037 1DDA              ; latter case, have had the step, possibly negative, added to the value.
 9038 1DDA
 9039 1DDA              ;; NEXT-LOOP
 9040 1DDA EF           L1DDA:  RST     28H             ;; FP-CALC
 9041 1DDB E1                   DEFB    $E1             ;;get-mem-1        l.
 9042 1DDC E0                   DEFB    $E0             ;;get-mem-0        l,v.
 9043 1DDD E2                   DEFB    $E2             ;;get-mem-2        l,v,s.
 9044 1DDE 36                   DEFB    $36             ;;less-0           l,v,(1/0) negative step ?
 9045 1DDF 00                   DEFB    $00             ;;jump-true        l,v.(1/0)
 9046 1DE0
 9047 1DE0 02                   DEFB    $02             ;;to L1DE2, NEXT-1 if step negative
 9048 1DE1
 9049 1DE1 01                   DEFB    $01             ;;exchange         v,l.
 9050 1DE2
 9051 1DE2              ;; NEXT-1
 9052 1DE2 03           L1DE2:  DEFB    $03             ;;subtract         l-v OR v-l.
 9053 1DE3 37                   DEFB    $37             ;;greater-0        (1/0)
 9054 1DE4 00                   DEFB    $00             ;;jump-true        .
 9055 1DE5
 9056 1DE5 04                   DEFB    $04             ;;to L1DE9, NEXT-2 if no more iterations.
 9057 1DE6
 9058 1DE6 38                   DEFB    $38             ;;end-calc         .
 9059 1DE7
 9060 1DE7 A7                   AND     A               ; clear carry flag signalling another loop.
 9061 1DE8 C9                   RET                     ; return
 9062 1DE9
 9063 1DE9              ; ---
 9064 1DE9
 9065 1DE9              ;; NEXT-2
 9066 1DE9 38           L1DE9:  DEFB    $38             ;;end-calc         .
 9067 1DEA
 9068 1DEA 37                   SCF                     ; set carry flag signalling looping exhausted.
 9069 1DEB C9                   RET                     ; return
 9070 1DEC
 9071 1DEC
 9072 1DEC              ; -------------------
 9073 1DEC              ; Handle READ command
 9074 1DEC              ; -------------------
 9075 1DEC              ; e.g. READ a, b$, c$(1000 TO 3000)
 9076 1DEC              ; A list of comma-separated variables is assigned from a list of
 9077 1DEC              ; comma-separated expressions.
 9078 1DEC              ; As it moves along the first list, the character address CH_ADD is stored
 9079 1DEC              ; in X_PTR while CH_ADD is used to read the second list.
 9080 1DEC
 9081 1DEC              ;; READ-3
 9082 1DEC E7           L1DEC:  RST     20H             ; NEXT-CHAR
 9083 1DED
 9084 1DED              ; -> Entry point.
 9085 1DED              ;; READ
 9086 1DED CD 1F 1C     L1DED:  CALL    L1C1F           ; routine CLASS-01 checks variable.
 9087 1DF0 CD 30 25             CALL    L2530           ; routine SYNTAX-Z
 9088 1DF3 28 29                JR      Z,L1E1E         ; forward to READ-2 if checking syntax
 9089 1DF5
 9090 1DF5
 9091 1DF5 DF                   RST     18H             ; GET-CHAR
 9092 1DF6 22 5F 5C             LD      ($5C5F),HL      ; save character position in X_PTR.
 9093 1DF9 2A 57 5C             LD      HL,($5C57)      ; load HL with Data Address DATADD, which is
 9094 1DFC                                              ; the start of the program or the address
 9095 1DFC                                              ; after the last expression that was read or
 9096 1DFC                                              ; the address of the line number of the
 9097 1DFC                                              ; last RESTORE command.
 9098 1DFC 7E                   LD      A,(HL)          ; fetch character
 9099 1DFD FE 2C                CP      $2C             ; is it a comma ?
 9100 1DFF 28 09                JR      Z,L1E0A         ; forward to READ-1 if so.
 9101 1E01
 9102 1E01              ; else all data in this statement has been read so look for next DATA token
 9103 1E01
 9104 1E01 1E E4                LD      E,$E4           ; token 'DATA'
 9105 1E03 CD 86 1D             CALL    L1D86           ; routine LOOK-PROG
 9106 1E06 30 02                JR      NC,L1E0A        ; forward to READ-1 if DATA found
 9107 1E08
 9108 1E08              ; else report the error.
 9109 1E08
 9110 1E08              ;; REPORT-E
 9111 1E08 CF           L1E08:  RST     08H             ; ERROR-1
 9112 1E09 0D                   DEFB    $0D             ; Error Report: Out of DATA
 9113 1E0A
 9114 1E0A              ;; READ-1
 9115 1E0A CD 77 00     L1E0A:  CALL    L0077           ; routine TEMP-PTR1 advances updating CH_ADD
 9116 1E0D                                              ; with new DATADD position.
 9117 1E0D CD 56 1C             CALL    L1C56           ; routine VAL-FET-1 assigns value to variable
 9118 1E10                                              ; checking type match and adjusting CH_ADD.
 9119 1E10
 9120 1E10 DF                   RST     18H             ; GET-CHAR fetches adjusted character position
 9121 1E11 22 57 5C             LD      ($5C57),HL      ; store back in DATADD
 9122 1E14 2A 5F 5C             LD      HL,($5C5F)      ; fetch X_PTR  the original READ CH_ADD
 9123 1E17 FD 36 26 00          LD      (IY+$26),$00    ; now nullify X_PTR_hi
 9124 1E1B CD 78 00             CALL    L0078           ; routine TEMP-PTR2 restores READ CH_ADD
 9125 1E1E
 9126 1E1E              ;; READ-2
 9127 1E1E DF           L1E1E:  RST     18H             ; GET-CHAR
 9128 1E1F FE 2C                CP      $2C             ; is it ',' indicating more variables to read ?
 9129 1E21 28 C9                JR      Z,L1DEC         ; back to READ-3 if so
 9130 1E23
 9131 1E23 CD EE 1B             CALL    L1BEE           ; routine CHECK-END
 9132 1E26 C9                   RET                     ; return from here in runtime to STMT-RET.
 9133 1E27
 9134 1E27              ; -------------------
 9135 1E27              ; Handle DATA command
 9136 1E27              ; -------------------
 9137 1E27              ; In runtime this 'command' is passed by but the syntax is checked when such
 9138 1E27              ; a statement is found while parsing a line.
 9139 1E27              ; e.g. DATA 1, 2, "text", score-1, a$(location, room, object), FN r(49),
 9140 1E27              ;         wages - tax, TRUE, The meaning of life
 9141 1E27
 9142 1E27              ;; DATA
 9143 1E27 CD 30 25     L1E27:  CALL    L2530           ; routine SYNTAX-Z to check status
 9144 1E2A 20 0B                JR      NZ,L1E37        ; forward to DATA-2 if in runtime
 9145 1E2C
 9146 1E2C              ;; DATA-1
 9147 1E2C CD FB 24     L1E2C:  CALL    L24FB           ; routine SCANNING to check syntax of
 9148 1E2F                                              ; expression
 9149 1E2F FE 2C                CP      $2C             ; is it a comma ?
 9150 1E31 C4 EE 1B             CALL    NZ,L1BEE        ; routine CHECK-END checks that statement
 9151 1E34                                              ; is complete. Will make an early exit if
 9152 1E34                                              ; so. >>>
 9153 1E34 E7                   RST     20H             ; NEXT-CHAR
 9154 1E35 18 F5                JR      L1E2C           ; back to DATA-1
 9155 1E37
 9156 1E37              ; ---
 9157 1E37
 9158 1E37              ;; DATA-2
 9159 1E37 3E E4        L1E37:  LD      A,$E4           ; set token to 'DATA' and continue into
 9160 1E39                                              ; the PASS-BY routine.
 9161 1E39
 9162 1E39
 9163 1E39              ; ----------------------------------
 9164 1E39              ; Check statement for DATA or DEF FN
 9165 1E39              ; ----------------------------------
 9166 1E39              ; This routine is used to backtrack to a command token and then
 9167 1E39              ; forward to the next statement in runtime.
 9168 1E39
 9169 1E39              ;; PASS-BY
 9170 1E39 47           L1E39:  LD      B,A             ; Give BC enough space to find token.
 9171 1E3A ED B9                CPDR                    ; Compare decrement and repeat. (Only use).
 9172 1E3C                                              ; Work backwards till keyword is found which
 9173 1E3C                                              ; is start of statement before any quotes.
 9174 1E3C                                              ; HL points to location before keyword.
 9175 1E3C 11 00 02             LD      DE,$0200        ; count 1+1 statements, dummy value in E to
 9176 1E3F                                              ; inhibit searching for a token.
 9177 1E3F C3 8B 19             JP      L198B           ; to EACH-STMT to find next statement
 9178 1E42
 9179 1E42              ; -----------------------------------------------------------------------
 9180 1E42              ; A General Note on Invalid Line Numbers.
 9181 1E42              ; =======================================
 9182 1E42              ; One of the revolutionary concepts of Sinclair BASIC was that it supported
 9183 1E42              ; virtual line numbers. That is the destination of a GO TO, RESTORE etc. need
 9184 1E42              ; not exist. It could be a point before or after an actual line number.
 9185 1E42              ; Zero suffices for a before but the after should logically be infinity.
 9186 1E42              ; Since the maximum actual line limit is 9999 then the system limit, 16383
 9187 1E42              ; when variables kick in, would serve fine as a virtual end point.
 9188 1E42              ; However, ironically, only the LOAD command gets it right. It will not
 9189 1E42              ; autostart a program that has been saved with a line higher than 16383.
 9190 1E42              ; All the other commands deal with the limit unsatisfactorily.
 9191 1E42              ; LIST, RUN, GO TO, GO SUB and RESTORE have problems and the latter may
 9192 1E42              ; crash the machine when supplied with an inappropriate virtual line number.
 9193 1E42              ; This is puzzling as very careful consideration must have been given to
 9194 1E42              ; this point when the new variable types were allocated their masks and also
 9195 1E42              ; when the routine NEXT-ONE was successfully re-written to reflect this.
 9196 1E42              ; An enigma.
 9197 1E42              ; -------------------------------------------------------------------------
 9198 1E42
 9199 1E42              ; ----------------------
 9200 1E42              ; Handle RESTORE command
 9201 1E42              ; ----------------------
 9202 1E42              ; The restore command sets the system variable for the data address to
 9203 1E42              ; point to the location before the supplied line number or first line
 9204 1E42              ; thereafter.
 9205 1E42              ; This alters the position where subsequent READ commands look for data.
 9206 1E42              ; Note. If supplied with inappropriate high numbers the system may crash
 9207 1E42              ; in the LINE-ADDR routine as it will pass the program/variables end-marker
 9208 1E42              ; and then lose control of what it is looking for - variable or line number.
 9209 1E42              ; - observation, Steven Vickers, 1984, Pitman.
 9210 1E42
 9211 1E42              ;; RESTORE
 9212 1E42 CD 99 1E     L1E42:  CALL    L1E99           ; routine FIND-INT2 puts integer in BC.
 9213 1E45                                              ; Note. B should be checked against limit $3F
 9214 1E45                                              ; and an error generated if higher.
 9215 1E45
 9216 1E45              ; this entry point is used from RUN command with BC holding zero
 9217 1E45
 9218 1E45              ;; REST-RUN
 9219 1E45 60           L1E45:  LD      H,B             ; transfer the line
 9220 1E46 69                   LD      L,C             ; number to the HL register.
 9221 1E47 CD 6E 19             CALL    L196E           ; routine LINE-ADDR to fetch the address.
 9222 1E4A 2B                   DEC     HL              ; point to the location before the line.
 9223 1E4B 22 57 5C             LD      ($5C57),HL      ; update system variable DATADD.
 9224 1E4E C9                   RET                     ; return to STMT-RET (or RUN)
 9225 1E4F
 9226 1E4F              ; ------------------------
 9227 1E4F              ; Handle RANDOMIZE command
 9228 1E4F              ; ------------------------
 9229 1E4F              ; This command sets the SEED for the RND function to a fixed value.
 9230 1E4F              ; With the parameter zero, a random start point is used depending on
 9231 1E4F              ; how long the computer has been switched on.
 9232 1E4F
 9233 1E4F              ;; RANDOMIZE
 9234 1E4F CD 99 1E     L1E4F:  CALL    L1E99           ; routine FIND-INT2 puts parameter in BC.
 9235 1E52 78                   LD      A,B             ; test this
 9236 1E53 B1                   OR      C               ; for zero.
 9237 1E54 20 04                JR      NZ,L1E5A        ; forward to RAND-1 if not zero.
 9238 1E56
 9239 1E56 ED 4B 78 5C          LD      BC,($5C78)      ; use the lower two bytes at FRAMES1.
 9240 1E5A
 9241 1E5A              ;; RAND-1
 9242 1E5A ED 43 76 5C  L1E5A:  LD      ($5C76),BC      ; place in SEED system variable.
 9243 1E5E C9                   RET                     ; return to STMT-RET
 9244 1E5F
 9245 1E5F              ; -----------------------
 9246 1E5F              ; Handle CONTINUE command
 9247 1E5F              ; -----------------------
 9248 1E5F              ; The CONTINUE command transfers the OLD (but incremented) values of
 9249 1E5F              ; line number and statement to the equivalent "NEW VALUE" system variables
 9250 1E5F              ; by using the last part of GO TO and exits indirectly to STMT-RET.
 9251 1E5F
 9252 1E5F              ;; CONTINUE
 9253 1E5F 2A 6E 5C     L1E5F:  LD      HL,($5C6E)      ; fetch OLDPPC line number.
 9254 1E62 FD 56 36             LD      D,(IY+$36)      ; fetch OSPPC statement.
 9255 1E65 18 0C                JR      L1E73           ; forward to GO-TO-2
 9256 1E67
 9257 1E67              ; --------------------
 9258 1E67              ; Handle GO TO command
 9259 1E67              ; --------------------
 9260 1E67              ; The GO TO command routine is also called by GO SUB and RUN routines
 9261 1E67              ; to evaluate the parameters of both commands.
 9262 1E67              ; It updates the system variables used to fetch the next line/statement.
 9263 1E67              ; It is at STMT-RET that the actual change in control takes place.
 9264 1E67              ; Unlike some BASICs the line number need not exist.
 9265 1E67              ; Note. the high byte of the line number is incorrectly compared with $F0
 9266 1E67              ; instead of $3F. This leads to commands with operands greater than 32767
 9267 1E67              ; being considered as having been run from the editing area and the
 9268 1E67              ; error report 'Statement Lost' is given instead of 'OK'.
 9269 1E67              ; - Steven Vickers, 1984.
 9270 1E67
 9271 1E67              ;; GO-TO
 9272 1E67 CD 99 1E     L1E67:  CALL    L1E99           ; routine FIND-INT2 puts operand in BC
 9273 1E6A 60                   LD      H,B             ; transfer line
 9274 1E6B 69                   LD      L,C             ; number to HL.
 9275 1E6C 16 00                LD      D,$00           ; set statement to 0 - first.
 9276 1E6E 7C                   LD      A,H             ; compare high byte only
 9277 1E6F FE F0                CP      $F0             ; to $F0 i.e. 61439 in full.
 9278 1E71 30 2C                JR      NC,L1E9F        ; forward to REPORT-B if above.
 9279 1E73
 9280 1E73              ; This call entry point is used to update the system variables e.g. by RETURN.
 9281 1E73
 9282 1E73              ;; GO-TO-2
 9283 1E73 22 42 5C     L1E73:  LD      ($5C42),HL      ; save line number in NEWPPC
 9284 1E76 FD 72 0A             LD      (IY+$0A),D      ; and statement in NSPPC
 9285 1E79 C9                   RET                     ; to STMT-RET (or GO-SUB command)
 9286 1E7A
 9287 1E7A              ; ------------------
 9288 1E7A              ; Handle OUT command
 9289 1E7A              ; ------------------
 9290 1E7A              ; Syntax has been checked and the two comma-separated values are on the
 9291 1E7A              ; calculator stack.
 9292 1E7A
 9293 1E7A              ;; OUT
 9294 1E7A CD 85 1E     L1E7A:  CALL    L1E85           ; routine TWO-PARAM fetches values
 9295 1E7D                                              ; to BC and A.
 9296 1E7D ED 79                OUT     (C),A           ; perform the operation.
 9297 1E7F C9                   RET                     ; return to STMT-RET.
 9298 1E80
 9299 1E80              ; -------------------
 9300 1E80              ; Handle POKE command
 9301 1E80              ; -------------------
 9302 1E80              ; This routine alters a single byte in the 64K address space.
 9303 1E80              ; Happily no check is made as to whether ROM or RAM is addressed.
 9304 1E80              ; Sinclair BASIC requires no poking of system variables.
 9305 1E80
 9306 1E80              ;; POKE
 9307 1E80 CD 85 1E     L1E80:  CALL    L1E85           ; routine TWO-PARAM fetches values
 9308 1E83                                              ; to BC and A.
 9309 1E83 02                   LD      (BC),A          ; load memory location with A.
 9310 1E84 C9                   RET                     ; return to STMT-RET.
 9311 1E85
 9312 1E85              ; ------------------------------------
 9313 1E85              ; Fetch two  parameters from calculator stack
 9314 1E85              ; ------------------------------------
 9315 1E85              ; This routine fetches a byte and word from the calculator stack
 9316 1E85              ; producing an error if either is out of range.
 9317 1E85
 9318 1E85              ;; TWO-PARAM
 9319 1E85 CD D5 2D     L1E85:  CALL    L2DD5           ; routine FP-TO-A
 9320 1E88 38 15                JR      C,L1E9F         ; forward to REPORT-B if overflow occurred
 9321 1E8A
 9322 1E8A 28 02                JR      Z,L1E8E         ; forward to TWO-P-1 if positive
 9323 1E8C
 9324 1E8C ED 44                NEG                     ; negative numbers are made positive
 9325 1E8E
 9326 1E8E              ;; TWO-P-1
 9327 1E8E F5           L1E8E:  PUSH    AF              ; save the value
 9328 1E8F CD 99 1E             CALL    L1E99           ; routine FIND-INT2 gets integer to BC
 9329 1E92 F1                   POP     AF              ; restore the value
 9330 1E93 C9                   RET                     ; return
 9331 1E94
 9332 1E94              ; -------------
 9333 1E94              ; Find integers
 9334 1E94              ; -------------
 9335 1E94              ; The first of these routines fetches a 8-bit integer (range 0-255) from the
 9336 1E94              ; calculator stack to the accumulator and is used for colours, streams,
 9337 1E94              ; durations and coordinates.
 9338 1E94              ; The second routine fetches 16-bit integers to the BC register pair
 9339 1E94              ; and is used to fetch command and function arguments involving line numbers
 9340 1E94              ; or memory addresses and also array subscripts and tab arguments.
 9341 1E94              ; ->
 9342 1E94
 9343 1E94              ;; FIND-INT1
 9344 1E94 CD D5 2D     L1E94:  CALL    L2DD5           ; routine FP-TO-A
 9345 1E97 18 03                JR      L1E9C           ; forward to FIND-I-1 for common exit routine.
 9346 1E99
 9347 1E99              ; ---
 9348 1E99
 9349 1E99              ; ->
 9350 1E99
 9351 1E99              ;; FIND-INT2
 9352 1E99 CD A2 2D     L1E99:  CALL    L2DA2           ; routine FP-TO-BC
 9353 1E9C
 9354 1E9C              ;; FIND-I-1
 9355 1E9C 38 01        L1E9C:  JR      C,L1E9F         ; to REPORT-Bb with overflow.
 9356 1E9E
 9357 1E9E C8                   RET     Z               ; return if positive.
 9358 1E9F
 9359 1E9F
 9360 1E9F              ;; REPORT-Bb
 9361 1E9F CF           L1E9F:  RST     08H             ; ERROR-1
 9362 1EA0 0A                   DEFB    $0A             ; Error Report: Integer out of range
 9363 1EA1
 9364 1EA1              ; ------------------
 9365 1EA1              ; Handle RUN command
 9366 1EA1              ; ------------------
 9367 1EA1              ; This command runs a program starting at an optional line.
 9368 1EA1              ; It performs a 'RESTORE 0' then CLEAR
 9369 1EA1
 9370 1EA1              ;; RUN
 9371 1EA1 CD 67 1E     L1EA1:  CALL    L1E67           ; routine GO-TO puts line number in
 9372 1EA4                                              ; system variables.
 9373 1EA4 01 00 00             LD      BC,$0000        ; prepare to set DATADD to first line.
 9374 1EA7 CD 45 1E             CALL    L1E45           ; routine REST-RUN does the 'restore'.
 9375 1EAA                                              ; Note BC still holds zero.
 9376 1EAA 18 03                JR      L1EAF           ; forward to CLEAR-RUN to clear variables
 9377 1EAC                                              ; without disturbing RAMTOP and
 9378 1EAC                                              ; exit indirectly to STMT-RET
 9379 1EAC
 9380 1EAC              ; --------------------
 9381 1EAC              ; Handle CLEAR command
 9382 1EAC              ; --------------------
 9383 1EAC              ; This command reclaims the space used by the variables.
 9384 1EAC              ; It also clears the screen and the GO SUB stack.
 9385 1EAC              ; With an integer expression, it sets the uppermost memory
 9386 1EAC              ; address within the BASIC system.
 9387 1EAC              ; "Contrary to the manual, CLEAR doesn't execute a RESTORE" -
 9388 1EAC              ; Steven Vickers, Pitman Pocket Guide to the Spectrum, 1984.
 9389 1EAC
 9390 1EAC              ;; CLEAR
 9391 1EAC CD 99 1E     L1EAC:  CALL    L1E99           ; routine FIND-INT2 fetches to BC.
 9392 1EAF
 9393 1EAF              ;; CLEAR-RUN
 9394 1EAF 78           L1EAF:  LD      A,B             ; test for
 9395 1EB0 B1                   OR      C               ; zero.
 9396 1EB1 20 04                JR      NZ,L1EB7        ; skip to CLEAR-1 if not zero.
 9397 1EB3
 9398 1EB3 ED 4B B2 5C          LD      BC,($5CB2)      ; use the existing value of RAMTOP if zero.
 9399 1EB7
 9400 1EB7              ;; CLEAR-1
 9401 1EB7 C5           L1EB7:  PUSH    BC              ; save ramtop value.
 9402 1EB8
 9403 1EB8 ED 5B 4B 5C          LD      DE,($5C4B)      ; fetch VARS
 9404 1EBC 2A 59 5C             LD      HL,($5C59)      ; fetch E_LINE
 9405 1EBF 2B                   DEC     HL              ; adjust to point at variables end-marker.
 9406 1EC0 CD E5 19             CALL    L19E5           ; routine RECLAIM-1 reclaims the space used by
 9407 1EC3                                              ; the variables.
 9408 1EC3
 9409 1EC3 CD 6B 0D             CALL    L0D6B           ; routine CLS to clear screen.
 9410 1EC6
 9411 1EC6 2A 65 5C             LD      HL,($5C65)      ; fetch STKEND the start of free memory.
 9412 1EC9 11 32 00             LD      DE,$0032        ; allow for another 50 bytes.
 9413 1ECC 19                   ADD     HL,DE           ; add the overhead to HL.
 9414 1ECD
 9415 1ECD D1                   POP     DE              ; restore the ramtop value.
 9416 1ECE ED 52                SBC     HL,DE           ; if HL is greater than the value then jump
 9417 1ED0 30 08                JR      NC,L1EDA        ; forward to REPORT-M
 9418 1ED2                                              ; 'RAMTOP no good'
 9419 1ED2
 9420 1ED2 2A B4 5C             LD      HL,($5CB4)      ; now P-RAMT ($7FFF on 16K RAM machine)
 9421 1ED5 A7                   AND     A               ; exact this time.
 9422 1ED6 ED 52                SBC     HL,DE           ; new ramtop must be lower or the same.
 9423 1ED8 30 02                JR      NC,L1EDC        ; skip to CLEAR-2 if in actual RAM.
 9424 1EDA
 9425 1EDA              ;; REPORT-M
 9426 1EDA CF           L1EDA:  RST     08H             ; ERROR-1
 9427 1EDB 15                   DEFB    $15             ; Error Report: RAMTOP no good
 9428 1EDC
 9429 1EDC              ;; CLEAR-2
 9430 1EDC EB           L1EDC:  EX      DE,HL           ; transfer ramtop value to HL.
 9431 1EDD 22 B2 5C             LD      ($5CB2),HL      ; update system variable RAMTOP.
 9432 1EE0 D1                   POP     DE              ; pop the return address STMT-RET.
 9433 1EE1 C1                   POP     BC              ; pop the Error Address.
 9434 1EE2 36 3E                LD      (HL),$3E        ; now put the GO SUB end-marker at RAMTOP.
 9435 1EE4 2B                   DEC     HL              ; leave a location beneath it.
 9436 1EE5 F9                   LD      SP,HL           ; initialize the machine stack pointer.
 9437 1EE6 C5                   PUSH    BC              ; push the error address.
 9438 1EE7 ED 73 3D 5C          LD      ($5C3D),SP      ; make ERR_SP point to location.
 9439 1EEB EB                   EX      DE,HL           ; put STMT-RET in HL.
 9440 1EEC E9                   JP      (HL)            ; and go there directly.
 9441 1EED
 9442 1EED              ; ---------------------
 9443 1EED              ; Handle GO SUB command
 9444 1EED              ; ---------------------
 9445 1EED              ; The GO SUB command diverts BASIC control to a new line number
 9446 1EED              ; in a very similar manner to GO TO but
 9447 1EED              ; the current line number and current statement + 1
 9448 1EED              ; are placed on the GO SUB stack as a RETURN point.
 9449 1EED
 9450 1EED              ;; GO-SUB
 9451 1EED D1           L1EED:  POP     DE              ; drop the address STMT-RET
 9452 1EEE FD 66 0D             LD      H,(IY+$0D)      ; fetch statement from SUBPPC and
 9453 1EF1 24                   INC     H               ; increment it
 9454 1EF2 E3                   EX      (SP),HL         ; swap - error address to HL,
 9455 1EF3                                              ; H (statement) at top of stack,
 9456 1EF3                                              ; L (unimportant) beneath.
 9457 1EF3 33                   INC     SP              ; adjust to overwrite unimportant byte
 9458 1EF4 ED 4B 45 5C          LD      BC,($5C45)      ; fetch the current line number from PPC
 9459 1EF8 C5                   PUSH    BC              ; and PUSH onto GO SUB stack.
 9460 1EF9                                              ; the empty machine-stack can be rebuilt
 9461 1EF9 E5                   PUSH    HL              ; push the error address.
 9462 1EFA ED 73 3D 5C          LD      ($5C3D),SP      ; make system variable ERR_SP point to it.
 9463 1EFE D5                   PUSH    DE              ; push the address STMT-RET.
 9464 1EFF CD 67 1E             CALL    L1E67           ; call routine GO-TO to update the system
 9465 1F02                                              ; variables NEWPPC and NSPPC.
 9466 1F02                                              ; then make an indirect exit to STMT-RET via
 9467 1F02 01 14 00             LD      BC,$0014        ; a 20-byte overhead memory check.
 9468 1F05
 9469 1F05              ; ----------------------
 9470 1F05              ; Check available memory
 9471 1F05              ; ----------------------
 9472 1F05              ; This routine is used on many occasions when extending a dynamic area
 9473 1F05              ; upwards or the GO SUB stack downwards.
 9474 1F05
 9475 1F05              ;; TEST-ROOM
 9476 1F05 2A 65 5C     L1F05:  LD      HL,($5C65)      ; fetch STKEND
 9477 1F08 09                   ADD     HL,BC           ; add the supplied test value
 9478 1F09 38 0A                JR      C,L1F15         ; forward to REPORT-4 if over $FFFF
 9479 1F0B
 9480 1F0B EB                   EX      DE,HL           ; was less so transfer to DE
 9481 1F0C 21 50 00             LD      HL,$0050        ; test against another 80 bytes
 9482 1F0F 19                   ADD     HL,DE           ; anyway
 9483 1F10 38 03                JR      C,L1F15         ; forward to REPORT-4 if this passes $FFFF
 9484 1F12
 9485 1F12 ED 72                SBC     HL,SP           ; if less than the machine stack pointer
 9486 1F14 D8                   RET     C               ; then return - OK.
 9487 1F15
 9488 1F15              ;; REPORT-4
 9489 1F15 2E 03        L1F15:  LD      L,$03           ; prepare 'Out of Memory'
 9490 1F17 C3 55 00             JP      L0055           ; jump back to ERROR-3 at $0055
 9491 1F1A                                              ; Note. this error can't be trapped at $0008
 9492 1F1A
 9493 1F1A              ; ------------------------------
 9494 1F1A              ; THE 'FREE MEMORY' USER ROUTINE
 9495 1F1A              ; ------------------------------
 9496 1F1A              ; This routine is not used by the ROM but allows users to evaluate
 9497 1F1A              ; approximate free memory with PRINT 65536 - USR 7962.
 9498 1F1A
 9499 1F1A              ;; free-mem
 9500 1F1A 01 00 00     L1F1A:  LD      BC,$0000        ; allow no overhead.
 9501 1F1D
 9502 1F1D CD 05 1F             CALL    L1F05           ; routine TEST-ROOM.
 9503 1F20
 9504 1F20 44                   LD      B,H             ; transfer the result
 9505 1F21 4D                   LD      C,L             ; to the BC register.
 9506 1F22 C9                   RET                     ; the USR function returns value of BC.
 9507 1F23
 9508 1F23              ; --------------------
 9509 1F23              ; THE 'RETURN' COMMAND
 9510 1F23              ; --------------------
 9511 1F23              ; As with any command, there are two values on the machine stack at the time
 9512 1F23              ; it is invoked.  The machine stack is below the GOSUB stack.  Both grow
 9513 1F23              ; downwards, the machine stack by two bytes, the GOSUB stack by 3 bytes.
 9514 1F23              ; The highest location is a statement byte followed by a two-byte line number.
 9515 1F23
 9516 1F23              ;; RETURN
 9517 1F23 C1           L1F23:  POP     BC              ; drop the address STMT-RET.
 9518 1F24 E1                   POP     HL              ; now the error address.
 9519 1F25 D1                   POP     DE              ; now a possible BASIC return line.
 9520 1F26 7A                   LD      A,D             ; the high byte $00 - $27 is
 9521 1F27 FE 3E                CP      $3E             ; compared with the traditional end-marker $3E.
 9522 1F29 28 0B                JR      Z,L1F36         ; forward to REPORT-7 with a match.
 9523 1F2B                                              ; 'RETURN without GOSUB'
 9524 1F2B
 9525 1F2B              ; It was not the end-marker so a single statement byte remains at the base of
 9526 1F2B              ; the calculator stack. It can't be popped off.
 9527 1F2B
 9528 1F2B 3B                   DEC     SP              ; adjust stack pointer to create room for two
 9529 1F2C                                              ; bytes.
 9530 1F2C E3                   EX      (SP),HL         ; statement to H, error address to base of
 9531 1F2D                                              ; new machine stack.
 9532 1F2D EB                   EX      DE,HL           ; statement to D,  BASIC line number to HL.
 9533 1F2E ED 73 3D 5C          LD      ($5C3D),SP      ; adjust ERR_SP to point to new stack pointer
 9534 1F32 C5                   PUSH    BC              ; now re-stack the address STMT-RET
 9535 1F33 C3 73 1E             JP      L1E73           ; to GO-TO-2 to update statement and line
 9536 1F36                                              ; system variables and exit indirectly to the
 9537 1F36                                              ; address just pushed on stack.
 9538 1F36
 9539 1F36              ; ---
 9540 1F36
 9541 1F36              ;; REPORT-7
 9542 1F36 D5           L1F36:  PUSH    DE              ; replace the end-marker.
 9543 1F37 E5                   PUSH    HL              ; now restore the error address
 9544 1F38                                              ; as will be required in a few clock cycles.
 9545 1F38
 9546 1F38 CF                   RST     08H             ; ERROR-1
 9547 1F39 06                   DEFB    $06             ; Error Report: RETURN without GOSUB
 9548 1F3A
 9549 1F3A              ; --------------------
 9550 1F3A              ; Handle PAUSE command
 9551 1F3A              ; --------------------
 9552 1F3A              ; The pause command takes as its parameter the number of interrupts
 9553 1F3A              ; for which to wait. PAUSE 50 pauses for about a second.
 9554 1F3A              ; PAUSE 0 pauses indefinitely.
 9555 1F3A              ; Both forms can be finished by pressing a key.
 9556 1F3A
 9557 1F3A              ;; PAUSE
 9558 1F3A CD 99 1E     L1F3A:  CALL    L1E99           ; routine FIND-INT2 puts value in BC
 9559 1F3D
 9560 1F3D              ;; PAUSE-1
 9561 1F3D 76           L1F3D:  HALT                    ; wait for interrupt.
 9562 1F3E 0B                   DEC     BC              ; decrease counter.
 9563 1F3F 78                   LD      A,B             ; test if
 9564 1F40 B1                   OR      C               ; result is zero.
 9565 1F41 28 0C                JR      Z,L1F4F         ; forward to PAUSE-END if so.
 9566 1F43
 9567 1F43 78                   LD      A,B             ; test if
 9568 1F44 A1                   AND     C               ; now $FFFF
 9569 1F45 3C                   INC     A               ; that is, initially zero.
 9570 1F46 20 01                JR      NZ,L1F49        ; skip forward to PAUSE-2 if not.
 9571 1F48
 9572 1F48 03                   INC     BC              ; restore counter to zero.
 9573 1F49
 9574 1F49              ;; PAUSE-2
 9575 1F49 FD CB 01 6E  L1F49:  BIT     5,(IY+$01)      ; test FLAGS - has a new key been pressed ?
 9576 1F4D 28 EE                JR      Z,L1F3D         ; back to PAUSE-1 if not.
 9577 1F4F
 9578 1F4F              ;; PAUSE-END
 9579 1F4F FD CB 01 AE  L1F4F:  RES     5,(IY+$01)      ; update FLAGS - signal no new key
 9580 1F53 C9                   RET                     ; and return.
 9581 1F54
 9582 1F54              ; -------------------
 9583 1F54              ; Check for BREAK key
 9584 1F54              ; -------------------
 9585 1F54              ; This routine is called from COPY-LINE, when interrupts are disabled,
 9586 1F54              ; to test if BREAK (SHIFT - SPACE) is being pressed.
 9587 1F54              ; It is also called at STMT-RET after every statement.
 9588 1F54
 9589 1F54              ;; BREAK-KEY
 9590 1F54 3E 7F        L1F54:  LD      A,$7F           ; Input address: $7FFE
 9591 1F56 DB FE                IN      A,($FE)         ; read lower right keys
 9592 1F58 1F                   RRA                     ; rotate bit 0 - SPACE
 9593 1F59 D8                   RET     C               ; return if not reset
 9594 1F5A
 9595 1F5A 3E FE                LD      A,$FE           ; Input address: $FEFE
 9596 1F5C DB FE                IN      A,($FE)         ; read lower left keys
 9597 1F5E 1F                   RRA                     ; rotate bit 0 - SHIFT
 9598 1F5F C9                   RET                     ; carry will be set if not pressed.
 9599 1F60                                              ; return with no carry if both keys
 9600 1F60                                              ; pressed.
 9601 1F60
 9602 1F60              ; ---------------------
 9603 1F60              ; Handle DEF FN command
 9604 1F60              ; ---------------------
 9605 1F60              ; e.g. DEF FN r$(a$,a) = a$(a TO )
 9606 1F60              ; this 'command' is ignored in runtime but has its syntax checked
 9607 1F60              ; during line-entry.
 9608 1F60
 9609 1F60              ;; DEF-FN
 9610 1F60 CD 30 25     L1F60:  CALL    L2530           ; routine SYNTAX-Z
 9611 1F63 28 05                JR      Z,L1F6A         ; forward to DEF-FN-1 if parsing
 9612 1F65
 9613 1F65 3E CE                LD      A,$CE           ; else load A with 'DEF FN' and
 9614 1F67 C3 39 1E             JP      L1E39           ; jump back to PASS-BY
 9615 1F6A
 9616 1F6A              ; ---
 9617 1F6A
 9618 1F6A              ; continue here if checking syntax.
 9619 1F6A
 9620 1F6A              ;; DEF-FN-1
 9621 1F6A FD CB 01 F6  L1F6A:  SET      6,(IY+$01)     ; set FLAGS  - Assume numeric result
 9622 1F6E CD 8D 2C             CALL    L2C8D           ; call routine ALPHA
 9623 1F71 30 16                JR      NC,L1F89        ; if not then to DEF-FN-4 to jump to
 9624 1F73                                              ; 'Nonsense in BASIC'
 9625 1F73
 9626 1F73
 9627 1F73 E7                   RST     20H             ; NEXT-CHAR
 9628 1F74 FE 24                CP      $24             ; is it '$' ?
 9629 1F76 20 05                JR      NZ,L1F7D        ; to DEF-FN-2 if not as numeric.
 9630 1F78
 9631 1F78 FD CB 01 B6          RES     6,(IY+$01)      ; set FLAGS  - Signal string result
 9632 1F7C
 9633 1F7C E7                   RST     20H             ; get NEXT-CHAR
 9634 1F7D
 9635 1F7D              ;; DEF-FN-2
 9636 1F7D FE 28        L1F7D:  CP      $28             ; is it '(' ?
 9637 1F7F 20 3C                JR      NZ,L1FBD        ; to DEF-FN-7 'Nonsense in BASIC'
 9638 1F81
 9639 1F81
 9640 1F81 E7                   RST     20H             ; NEXT-CHAR
 9641 1F82 FE 29                CP      $29             ; is it ')' ?
 9642 1F84 28 20                JR      Z,L1FA6         ; to DEF-FN-6 if null argument
 9643 1F86
 9644 1F86              ;; DEF-FN-3
 9645 1F86 CD 8D 2C     L1F86:  CALL    L2C8D           ; routine ALPHA checks that it is the expected
 9646 1F89                                              ; alphabetic character.
 9647 1F89
 9648 1F89              ;; DEF-FN-4
 9649 1F89 D2 8A 1C     L1F89:  JP      NC,L1C8A        ; to REPORT-C  if not
 9650 1F8C                                              ; 'Nonsense in BASIC'.
 9651 1F8C
 9652 1F8C EB                   EX      DE,HL           ; save pointer in DE
 9653 1F8D
 9654 1F8D E7                   RST     20H             ; NEXT-CHAR re-initializes HL from CH_ADD
 9655 1F8E                                              ; and advances.
 9656 1F8E FE 24                CP      $24             ; '$' ? is it a string argument.
 9657 1F90 20 02                JR      NZ,L1F94        ; forward to DEF-FN-5 if not.
 9658 1F92
 9659 1F92 EB                   EX      DE,HL           ; save pointer to '$' in DE
 9660 1F93
 9661 1F93 E7                   RST     20H             ; NEXT-CHAR re-initializes HL and advances
 9662 1F94
 9663 1F94              ;; DEF-FN-5
 9664 1F94 EB           L1F94:  EX      DE,HL           ; bring back pointer.
 9665 1F95 01 06 00             LD      BC,$0006        ; the function requires six hidden bytes for
 9666 1F98                                              ; each parameter passed.
 9667 1F98                                              ; The first byte will be $0E
 9668 1F98                                              ; then 5-byte numeric value
 9669 1F98                                              ; or 5-byte string pointer.
 9670 1F98
 9671 1F98 CD 55 16             CALL    L1655           ; routine MAKE-ROOM creates space in program
 9672 1F9B                                              ; area.
 9673 1F9B
 9674 1F9B 23                   INC     HL              ; adjust HL (set by LDDR)
 9675 1F9C 23                   INC     HL              ; to point to first location.
 9676 1F9D 36 0E                LD      (HL),$0E        ; insert the 'hidden' marker.
 9677 1F9F
 9678 1F9F              ; Note. these invisible storage locations hold nothing meaningful for the
 9679 1F9F              ; moment. They will be used every time the corresponding function is
 9680 1F9F              ; evaluated in runtime.
 9681 1F9F              ; Now consider the following character fetched earlier.
 9682 1F9F
 9683 1F9F FE 2C                CP      $2C             ; is it ',' ? (more than one parameter)
 9684 1FA1 20 03                JR      NZ,L1FA6        ; to DEF-FN-6 if not
 9685 1FA3
 9686 1FA3
 9687 1FA3 E7                   RST     20H             ; else NEXT-CHAR
 9688 1FA4 18 E0                JR      L1F86           ; and back to DEF-FN-3
 9689 1FA6
 9690 1FA6              ; ---
 9691 1FA6
 9692 1FA6              ;; DEF-FN-6
 9693 1FA6 FE 29        L1FA6:  CP      $29             ; should close with a ')'
 9694 1FA8 20 13                JR      NZ,L1FBD        ; to DEF-FN-7 if not
 9695 1FAA                                              ; 'Nonsense in BASIC'
 9696 1FAA
 9697 1FAA
 9698 1FAA E7                   RST     20H             ; get NEXT-CHAR
 9699 1FAB FE 3D                CP      $3D             ; is it '=' ?
 9700 1FAD 20 0E                JR      NZ,L1FBD        ; to DEF-FN-7 if not 'Nonsense...'
 9701 1FAF
 9702 1FAF
 9703 1FAF E7                   RST     20H             ; address NEXT-CHAR
 9704 1FB0 3A 3B 5C             LD      A,($5C3B)       ; get FLAGS which has been set above
 9705 1FB3 F5                   PUSH    AF              ; and preserve
 9706 1FB4
 9707 1FB4 CD FB 24             CALL    L24FB           ; routine SCANNING checks syntax of expression
 9708 1FB7                                              ; and also sets flags.
 9709 1FB7
 9710 1FB7 F1                   POP     AF              ; restore previous flags
 9711 1FB8 FD AE 01             XOR     (IY+$01)        ; xor with FLAGS - bit 6 should be same
 9712 1FBB                                              ; therefore will be reset.
 9713 1FBB E6 40                AND     $40             ; isolate bit 6.
 9714 1FBD
 9715 1FBD              ;; DEF-FN-7
 9716 1FBD C2 8A 1C     L1FBD:  JP      NZ,L1C8A        ; jump back to REPORT-C if the expected result
 9717 1FC0                                              ; is not the same type.
 9718 1FC0                                              ; 'Nonsense in BASIC'
 9719 1FC0
 9720 1FC0 CD EE 1B             CALL    L1BEE           ; routine CHECK-END will return early if
 9721 1FC3                                              ; at end of statement and move onto next
 9722 1FC3                                              ; else produce error report. >>>
 9723 1FC3
 9724 1FC3                                              ; There will be no return to here.
 9725 1FC3
 9726 1FC3              ; -------------------------------
 9727 1FC3              ; Returning early from subroutine
 9728 1FC3              ; -------------------------------
 9729 1FC3              ; All routines are capable of being run in two modes - syntax checking mode
 9730 1FC3              ; and runtime mode.  This routine is called often to allow a routine to return
 9731 1FC3              ; early if checking syntax.
 9732 1FC3
 9733 1FC3              ;; UNSTACK-Z
 9734 1FC3 CD 30 25     L1FC3:  CALL    L2530           ; routine SYNTAX-Z sets zero flag if syntax
 9735 1FC6                                              ; is being checked.
 9736 1FC6
 9737 1FC6 E1                   POP     HL              ; drop the return address.
 9738 1FC7 C8                   RET      Z              ; return to previous call in chain if checking
 9739 1FC8                                              ; syntax.
 9740 1FC8
 9741 1FC8 E9                   JP      (HL)            ; jump to return address as BASIC program is
 9742 1FC9                                              ; actually running.
 9743 1FC9
 9744 1FC9              ; ---------------------
 9745 1FC9              ; Handle LPRINT command
 9746 1FC9              ; ---------------------
 9747 1FC9              ; A simple form of 'PRINT #3' although it can output to 16 streams.
 9748 1FC9              ; Probably for compatibility with other BASICs particularly ZX81 BASIC.
 9749 1FC9              ; An extra UDG might have been better.
 9750 1FC9
 9751 1FC9              ;; LPRINT
 9752 1FC9 3E 03        L1FC9:  LD      A,$03           ; the printer channel
 9753 1FCB 18 02                JR      L1FCF           ; forward to PRINT-1
 9754 1FCD
 9755 1FCD              ; ---------------------
 9756 1FCD              ; Handle PRINT commands
 9757 1FCD              ; ---------------------
 9758 1FCD              ; The Spectrum's main stream output command.
 9759 1FCD              ; The default stream is stream 2 which is normally the upper screen
 9760 1FCD              ; of the computer. However the stream can be altered in range 0 - 15.
 9761 1FCD
 9762 1FCD              ;; PRINT
 9763 1FCD 3E 02        L1FCD:  LD      A,$02           ; the stream for the upper screen.
 9764 1FCF
 9765 1FCF              ; The LPRINT command joins here.
 9766 1FCF
 9767 1FCF              ;; PRINT-1
 9768 1FCF CD 30 25     L1FCF:  CALL    L2530           ; routine SYNTAX-Z checks if program running
 9769 1FD2 C4 01 16             CALL    NZ,L1601        ; routine CHAN-OPEN if so
 9770 1FD5 CD 4D 0D             CALL    L0D4D           ; routine TEMPS sets temporary colours.
 9771 1FD8 CD DF 1F             CALL    L1FDF           ; routine PRINT-2 - the actual item
 9772 1FDB CD EE 1B             CALL    L1BEE           ; routine CHECK-END gives error if not at end
 9773 1FDE                                              ; of statement
 9774 1FDE C9                   RET                     ; and return >>>
 9775 1FDF
 9776 1FDF              ; ------------------------------------
 9777 1FDF              ; this subroutine is called from above
 9778 1FDF              ; and also from INPUT.
 9779 1FDF
 9780 1FDF              ;; PRINT-2
 9781 1FDF DF           L1FDF:  RST     18H             ; GET-CHAR gets printable character
 9782 1FE0 CD 45 20             CALL    L2045           ; routine PR-END-Z checks if more printing
 9783 1FE3 28 0D                JR      Z,L1FF2         ; to PRINT-4 if not     e.g. just 'PRINT :'
 9784 1FE5
 9785 1FE5              ; This tight loop deals with combinations of positional controls and
 9786 1FE5              ; print items. An early return can be made from within the loop
 9787 1FE5              ; if the end of a print sequence is reached.
 9788 1FE5
 9789 1FE5              ;; PRINT-3
 9790 1FE5 CD 4E 20     L1FE5:  CALL    L204E           ; routine PR-POSN-1 returns zero if more
 9791 1FE8                                              ; but returns early at this point if
 9792 1FE8                                              ; at end of statement!
 9793 1FE8                                              ;
 9794 1FE8 28 FB                JR      Z,L1FE5         ; to PRINT-3 if consecutive positioners
 9795 1FEA
 9796 1FEA CD FC 1F             CALL    L1FFC           ; routine PR-ITEM-1 deals with strings etc.
 9797 1FED CD 4E 20             CALL    L204E           ; routine PR-POSN-1 for more position codes
 9798 1FF0 28 F3                JR      Z,L1FE5         ; loop back to PRINT-3 if so
 9799 1FF2
 9800 1FF2              ;; PRINT-4
 9801 1FF2 FE 29        L1FF2:  CP      $29             ; return now if this is ')' from input-item.
 9802 1FF4                                              ; (see INPUT.)
 9803 1FF4 C8                   RET     Z               ; or continue and print carriage return in
 9804 1FF5                                              ; runtime
 9805 1FF5
 9806 1FF5              ; ---------------------
 9807 1FF5              ; Print carriage return
 9808 1FF5              ; ---------------------
 9809 1FF5              ; This routine which continues from above prints a carriage return
 9810 1FF5              ; in run-time. It is also called once from PRINT-POSN.
 9811 1FF5
 9812 1FF5              ;; PRINT-CR
 9813 1FF5 CD C3 1F     L1FF5:  CALL    L1FC3           ; routine UNSTACK-Z
 9814 1FF8
 9815 1FF8 3E 0D                LD      A,$0D           ; prepare a carriage return
 9816 1FFA
 9817 1FFA D7                   RST     10H             ; PRINT-A
 9818 1FFB C9                   RET                     ; return
 9819 1FFC
 9820 1FFC
 9821 1FFC              ; -----------
 9822 1FFC              ; Print items
 9823 1FFC              ; -----------
 9824 1FFC              ; This routine deals with print items as in
 9825 1FFC              ; PRINT AT 10,0;"The value of A is ";a
 9826 1FFC              ; It returns once a single item has been dealt with as it is part
 9827 1FFC              ; of a tight loop that considers sequences of positional and print items
 9828 1FFC
 9829 1FFC              ;; PR-ITEM-1
 9830 1FFC DF           L1FFC:  RST     18H             ; GET-CHAR
 9831 1FFD FE AC                CP      $AC             ; is character 'AT' ?
 9832 1FFF 20 0D                JR      NZ,L200E        ; forward to PR-ITEM-2 if not.
 9833 2001
 9834 2001 CD 79 1C             CALL    L1C79           ; routine NEXT-2NUM  check for two comma
 9835 2004                                              ; separated numbers placing them on the
 9836 2004                                              ; calculator stack in runtime.
 9837 2004 CD C3 1F             CALL    L1FC3           ; routine UNSTACK-Z quits if checking syntax.
 9838 2007
 9839 2007 CD 07 23             CALL    L2307           ; routine STK-TO-BC get the numbers in B and C.
 9840 200A 3E 16                LD      A,$16           ; prepare the 'at' control.
 9841 200C 18 10                JR      L201E           ; forward to PR-AT-TAB to print the sequence.
 9842 200E
 9843 200E              ; ---
 9844 200E
 9845 200E              ;; PR-ITEM-2
 9846 200E FE AD        L200E:  CP      $AD             ; is character 'TAB' ?
 9847 2010 20 12                JR      NZ,L2024        ; to PR-ITEM-3 if not
 9848 2012
 9849 2012
 9850 2012 E7                   RST     20H             ; NEXT-CHAR to address next character
 9851 2013 CD 82 1C             CALL    L1C82           ; routine EXPT-1NUM
 9852 2016 CD C3 1F             CALL    L1FC3           ; routine UNSTACK-Z quits if checking syntax.
 9853 2019
 9854 2019 CD 99 1E             CALL    L1E99           ; routine FIND-INT2 puts integer in BC.
 9855 201C 3E 17                LD      A,$17           ; prepare the 'tab' control.
 9856 201E
 9857 201E              ;; PR-AT-TAB
 9858 201E D7           L201E:  RST     10H             ; PRINT-A outputs the control
 9859 201F
 9860 201F 79                   LD      A,C             ; first value to A
 9861 2020 D7                   RST     10H             ; PRINT-A outputs it.
 9862 2021
 9863 2021 78                   LD      A,B             ; second value
 9864 2022 D7                   RST     10H             ; PRINT-A
 9865 2023
 9866 2023 C9                   RET                     ; return - item finished >>>
 9867 2024
 9868 2024              ; ---
 9869 2024
 9870 2024              ; Now consider paper 2; #2; a$
 9871 2024
 9872 2024              ;; PR-ITEM-3
 9873 2024 CD F2 21     L2024:  CALL    L21F2           ; routine CO-TEMP-3 will print any colour
 9874 2027 D0                   RET     NC              ; items - return if success.
 9875 2028
 9876 2028 CD 70 20             CALL    L2070           ; routine STR-ALTER considers new stream
 9877 202B D0                   RET     NC              ; return if altered.
 9878 202C
 9879 202C CD FB 24             CALL    L24FB           ; routine SCANNING now to evaluate expression
 9880 202F CD C3 1F             CALL    L1FC3           ; routine UNSTACK-Z if not runtime.
 9881 2032
 9882 2032 FD CB 01 76          BIT     6,(IY+$01)      ; test FLAGS  - Numeric or string result ?
 9883 2036 CC F1 2B             CALL    Z,L2BF1         ; routine STK-FETCH if string.
 9884 2039                                              ; note no flags affected.
 9885 2039 C2 E3 2D             JP      NZ,L2DE3        ; to PRINT-FP to print if numeric >>>
 9886 203C
 9887 203C              ; It was a string expression - start in DE, length in BC
 9888 203C              ; Now enter a loop to print it
 9889 203C
 9890 203C              ;; PR-STRING
 9891 203C 78           L203C:  LD      A,B             ; this tests if the
 9892 203D B1                   OR      C               ; length is zero and sets flag accordingly.
 9893 203E 0B                   DEC     BC              ; this doesn't but decrements counter.
 9894 203F C8                   RET     Z               ; return if zero.
 9895 2040
 9896 2040 1A                   LD      A,(DE)          ; fetch character.
 9897 2041 13                   INC     DE              ; address next location.
 9898 2042
 9899 2042 D7                   RST     10H             ; PRINT-A.
 9900 2043
 9901 2043 18 F7                JR      L203C           ; loop back to PR-STRING.
 9902 2045
 9903 2045              ; ---------------
 9904 2045              ; End of printing
 9905 2045              ; ---------------
 9906 2045              ; This subroutine returns zero if no further printing is required
 9907 2045              ; in the current statement.
 9908 2045              ; The first terminator is found in  escaped input items only,
 9909 2045              ; the others in print_items.
 9910 2045
 9911 2045              ;; PR-END-Z
 9912 2045 FE 29        L2045:  CP      $29             ; is character a ')' ?
 9913 2047 C8                   RET     Z               ; return if so -        e.g. INPUT (p$); a$
 9914 2048
 9915 2048              ;; PR-ST-END
 9916 2048 FE 0D        L2048:  CP      $0D             ; is it a carriage return ?
 9917 204A C8                   RET     Z               ; return also -         e.g. PRINT a
 9918 204B
 9919 204B FE 3A                CP      $3A             ; is character a ':' ?
 9920 204D C9                   RET                     ; return - zero flag will be set if so.
 9921 204E                                              ;                       e.g. PRINT a :
 9922 204E
 9923 204E              ; --------------
 9924 204E              ; Print position
 9925 204E              ; --------------
 9926 204E              ; This routine considers a single positional character ';', ',', '''
 9927 204E
 9928 204E              ;; PR-POSN-1
 9929 204E DF           L204E:  RST     18H             ; GET-CHAR
 9930 204F FE 3B                CP      $3B             ; is it ';' ?
 9931 2051                                              ; i.e. print from last position.
 9932 2051 28 14                JR      Z,L2067         ; forward to PR-POSN-3 if so.
 9933 2053                                              ; i.e. do nothing.
 9934 2053
 9935 2053 FE 2C                CP      $2C             ; is it ',' ?
 9936 2055                                              ; i.e. print at next tabstop.
 9937 2055 20 0A                JR      NZ,L2061        ; forward to PR-POSN-2 if anything else.
 9938 2057
 9939 2057 CD 30 25             CALL    L2530           ; routine SYNTAX-Z
 9940 205A 28 0B                JR      Z,L2067         ; forward to PR-POSN-3 if checking syntax.
 9941 205C
 9942 205C 3E 06                LD      A,$06           ; prepare the 'comma' control character.
 9943 205E
 9944 205E D7                   RST     10H             ; PRINT-A  outputs to current channel in
 9945 205F                                              ; run-time.
 9946 205F
 9947 205F 18 06                JR      L2067           ; skip to PR-POSN-3.
 9948 2061
 9949 2061              ; ---
 9950 2061
 9951 2061              ; check for newline.
 9952 2061
 9953 2061              ;; PR-POSN-2
 9954 2061 FE 27        L2061:  CP      $27             ; is character a "'" ? (newline)
 9955 2063 C0                   RET     NZ              ; return if no match              >>>
 9956 2064
 9957 2064 CD F5 1F             CALL    L1FF5           ; routine PRINT-CR outputs a carriage return
 9958 2067                                              ; in runtime only.
 9959 2067
 9960 2067              ;; PR-POSN-3
 9961 2067 E7           L2067:  RST     20H             ; NEXT-CHAR to A.
 9962 2068 CD 45 20             CALL    L2045           ; routine PR-END-Z checks if at end.
 9963 206B 20 01                JR      NZ,L206E        ; to PR-POSN-4 if not.
 9964 206D
 9965 206D C1                   POP     BC              ; drop return address if at end.
 9966 206E
 9967 206E              ;; PR-POSN-4
 9968 206E BF           L206E:  CP      A               ; reset the zero flag.
 9969 206F C9                   RET                     ; and return to loop or quit.
 9970 2070
 9971 2070              ; ------------
 9972 2070              ; Alter stream
 9973 2070              ; ------------
 9974 2070              ; This routine is called from PRINT ITEMS above, and also LIST as in
 9975 2070              ; LIST #15
 9976 2070
 9977 2070              ;; STR-ALTER
 9978 2070 FE 23        L2070:  CP      $23             ; is character '#' ?
 9979 2072 37                   SCF                     ; set carry flag.
 9980 2073 C0                   RET     NZ              ; return if no match.
 9981 2074
 9982 2074
 9983 2074 E7                   RST      20H            ; NEXT-CHAR
 9984 2075 CD 82 1C             CALL    L1C82           ; routine EXPT-1NUM gets stream number
 9985 2078 A7                   AND     A               ; prepare to exit early with carry reset
 9986 2079 CD C3 1F             CALL    L1FC3           ; routine UNSTACK-Z exits early if parsing
 9987 207C CD 94 1E             CALL    L1E94           ; routine FIND-INT1 gets number off stack
 9988 207F FE 10                CP      $10             ; must be range 0 - 15 decimal.
 9989 2081 D2 0E 16             JP      NC,L160E        ; jump back to REPORT-Oa if not
 9990 2084                                              ; 'Invalid stream'.
 9991 2084
 9992 2084 CD 01 16             CALL    L1601           ; routine CHAN-OPEN
 9993 2087 A7                   AND     A               ; clear carry - signal item dealt with.
 9994 2088 C9                   RET                     ; return
 9995 2089
 9996 2089              ; -------------------
 9997 2089              ; THE 'INPUT' COMMAND
 9998 2089              ; -------------------
 9999 2089              ; This command is mysterious.
10000 2089              ;
10001 2089
10002 2089              ;; INPUT
10003 2089 CD 30 25     L2089:  CALL    L2530           ; routine SYNTAX-Z to check if in runtime.
10004 208C
10005 208C 28 08                JR      Z,L2096         ; forward to INPUT-1 if checking syntax.
10006 208E
10007 208E 3E 01                LD      A,$01           ; select channel 'K' the keyboard for input.
10008 2090 CD 01 16             CALL    L1601           ; routine CHAN-OPEN opens the channel and sets
10009 2093                                              ; bit 0 of TV_FLAG.
10010 2093
10011 2093              ;   Note. As a consequence of clearing the lower screen channel 0 is made
10012 2093              ;   the current channel so the above two instructions are superfluous.
10013 2093
10014 2093 CD 6E 0D             CALL    L0D6E           ; routine CLS-LOWER clears the lower screen
10015 2096                                              ; and sets DF_SZ to two and TV_FLAG to $01.
10016 2096
10017 2096              ;; INPUT-1
10018 2096 FD 36 02 01  L2096:  LD      (IY+$02),$01    ; update TV_FLAG - signal lower screen in use
10019 209A                                              ; ensuring that the correct set of system
10020 209A                                              ; variables are updated and that the border
10021 209A                                              ; colour is used.
10022 209A
10023 209A              ;   Note. The Complete Spectrum ROM Disassembly incorrectly names DF-SZ as the
10024 209A              ;   system variable that is updated above and if, as some have done, you make
10025 209A              ;   this unnecessary alteration then there will be two blank lines between the
10026 209A              ;   lower screen and the upper screen areas which will also scroll wrongly.
10027 209A
10028 209A CD C1 20             CALL    L20C1           ; routine IN-ITEM-1 to handle the input.
10029 209D
10030 209D CD EE 1B             CALL    L1BEE           ; routine CHECK-END will make an early exit
10031 20A0                                              ; if checking syntax. >>>
10032 20A0
10033 20A0              ;   Keyboard input has been made and it remains to adjust the upper
10034 20A0              ;   screen in case the lower two lines have been extended upwards.
10035 20A0
10036 20A0 ED 4B 88 5C          LD      BC,($5C88)      ; fetch S_POSN current line/column of
10037 20A4                                              ; the upper screen.
10038 20A4 3A 6B 5C             LD      A,($5C6B)       ; fetch DF_SZ the display file size of
10039 20A7                                              ; the lower screen.
10040 20A7 B8                   CP      B               ; test that lower screen does not overlap
10041 20A8 38 03                JR      C,L20AD         ; forward to INPUT-2 if not.
10042 20AA
10043 20AA              ; the two screens overlap so adjust upper screen.
10044 20AA
10045 20AA 0E 21                LD      C,$21           ; set column of upper screen to leftmost.
10046 20AC 47                   LD      B,A             ; and line to one above lower screen.
10047 20AD                                              ; continue forward to update upper screen
10048 20AD                                              ; print position.
10049 20AD
10050 20AD              ;; INPUT-2
10051 20AD ED 43 88 5C  L20AD:  LD      ($5C88),BC      ; set S_POSN update upper screen line/column.
10052 20B1 3E 19                LD      A,$19           ; subtract from twenty five
10053 20B3 90                   SUB     B               ; the new line number.
10054 20B4 32 8C 5C             LD      ($5C8C),A       ; and place result in SCR_CT - scroll count.
10055 20B7 FD CB 02 86          RES     0,(IY+$02)      ; update TV_FLAG - signal main screen in use.
10056 20BB
10057 20BB CD D9 0D             CALL    L0DD9           ; routine CL-SET sets the print position
10058 20BE                                              ; system variables for the upper screen.
10059 20BE
10060 20BE C3 6E 0D             JP      L0D6E           ; jump back to CLS-LOWER and make
10061 20C1                                              ; an indirect exit >>.
10062 20C1
10063 20C1              ; ---------------------
10064 20C1              ; INPUT ITEM subroutine
10065 20C1              ; ---------------------
10066 20C1              ;   This subroutine deals with the input items and print items.
10067 20C1              ;   from  the current input channel.
10068 20C1              ;   It is only called from the above INPUT routine but was obviously
10069 20C1              ;   once called from somewhere else in another context.
10070 20C1
10071 20C1              ;; IN-ITEM-1
10072 20C1 CD 4E 20     L20C1:  CALL    L204E           ; routine PR-POSN-1 deals with a single
10073 20C4                                              ; position item at each call.
10074 20C4 28 FB                JR      Z,L20C1         ; back to IN-ITEM-1 until no more in a
10075 20C6                                              ; sequence.
10076 20C6
10077 20C6 FE 28                CP      $28             ; is character '(' ?
10078 20C8 20 0E                JR      NZ,L20D8        ; forward to IN-ITEM-2 if not.
10079 20CA
10080 20CA              ;   any variables within braces will be treated as part, or all, of the prompt
10081 20CA              ;   instead of being used as destination variables.
10082 20CA
10083 20CA E7                   RST     20H             ; NEXT-CHAR
10084 20CB CD DF 1F             CALL    L1FDF           ; routine PRINT-2 to output the dynamic
10085 20CE                                              ; prompt.
10086 20CE
10087 20CE DF                   RST     18H             ; GET-CHAR
10088 20CF FE 29                CP      $29             ; is character a matching ')' ?
10089 20D1 C2 8A 1C             JP      NZ,L1C8A        ; jump back to REPORT-C if not.
10090 20D4                                              ; 'Nonsense in BASIC'.
10091 20D4
10092 20D4 E7                   RST     20H             ; NEXT-CHAR
10093 20D5 C3 B2 21             JP      L21B2           ; forward to IN-NEXT-2
10094 20D8
10095 20D8              ; ---
10096 20D8
10097 20D8              ;; IN-ITEM-2
10098 20D8 FE CA        L20D8:  CP      $CA             ; is the character the token 'LINE' ?
10099 20DA 20 11                JR      NZ,L20ED        ; forward to IN-ITEM-3 if not.
10100 20DC
10101 20DC E7                   RST     20H             ; NEXT-CHAR - variable must come next.
10102 20DD CD 1F 1C             CALL    L1C1F           ; routine CLASS-01 returns destination
10103 20E0                                              ; address of variable to be assigned.
10104 20E0                                              ; or generates an error if no variable
10105 20E0                                              ; at this position.
10106 20E0
10107 20E0 FD CB 37 FE          SET     7,(IY+$37)      ; update FLAGX  - signal handling INPUT LINE
10108 20E4 FD CB 01 76          BIT     6,(IY+$01)      ; test FLAGS  - numeric or string result ?
10109 20E8 C2 8A 1C             JP      NZ,L1C8A        ; jump back to REPORT-C if not string
10110 20EB                                              ; 'Nonsense in BASIC'.
10111 20EB
10112 20EB 18 0D                JR      L20FA           ; forward to IN-PROMPT to set up workspace.
10113 20ED
10114 20ED              ; ---
10115 20ED
10116 20ED              ;   the jump was here for other variables.
10117 20ED
10118 20ED              ;; IN-ITEM-3
10119 20ED CD 8D 2C     L20ED:  CALL     L2C8D          ; routine ALPHA checks if character is
10120 20F0                                              ; a suitable variable name.
10121 20F0 D2 AF 21             JP      NC,L21AF        ; forward to IN-NEXT-1 if not
10122 20F3
10123 20F3 CD 1F 1C             CALL    L1C1F           ; routine CLASS-01 returns destination
10124 20F6                                              ; address of variable to be assigned.
10125 20F6 FD CB 37 BE          RES     7,(IY+$37)      ; update FLAGX  - signal not INPUT LINE.
10126 20FA
10127 20FA              ;; IN-PROMPT
10128 20FA CD 30 25     L20FA:  CALL    L2530           ; routine SYNTAX-Z
10129 20FD CA B2 21             JP      Z,L21B2         ; forward to IN-NEXT-2 if checking syntax.
10130 2100
10131 2100 CD BF 16             CALL    L16BF           ; routine SET-WORK clears workspace.
10132 2103 21 71 5C             LD      HL,$5C71        ; point to system variable FLAGX
10133 2106 CB B6                RES     6,(HL)          ; signal string result.
10134 2108 CB EE                SET     5,(HL)          ; signal in Input Mode for editor.
10135 210A 01 01 00             LD      BC,$0001        ; initialize space required to one for
10136 210D                                              ; the carriage return.
10137 210D CB 7E                BIT     7,(HL)          ; test FLAGX - INPUT LINE in use ?
10138 210F 20 0B                JR      NZ,L211C        ; forward to IN-PR-2 if so as that is
10139 2111                                              ; all the space that is required.
10140 2111
10141 2111 3A 3B 5C             LD      A,($5C3B)       ; load accumulator from FLAGS
10142 2114 E6 40                AND     $40             ; mask to test BIT 6 of FLAGS and clear
10143 2116                                              ; the other bits in A.
10144 2116                                              ; numeric result expected ?
10145 2116 20 02                JR      NZ,L211A        ; forward to IN-PR-1 if so
10146 2118
10147 2118 0E 03                LD      C,$03           ; increase space to three bytes for the
10148 211A                                              ; pair of surrounding quotes.
10149 211A
10150 211A              ;; IN-PR-1
10151 211A B6           L211A:  OR      (HL)            ; if numeric result, set bit 6 of FLAGX.
10152 211B 77                   LD      (HL),A          ; and update system variable
10153 211C
10154 211C              ;; IN-PR-2
10155 211C F7           L211C:  RST     30H             ; BC-SPACES opens 1 or 3 bytes in workspace
10156 211D 36 0D                LD      (HL),$0D        ; insert carriage return at last new location.
10157 211F 79                   LD      A,C             ; fetch the length, one or three.
10158 2120 0F                   RRCA                    ; lose bit 0.
10159 2121 0F                   RRCA                    ; test if quotes required.
10160 2122 30 05                JR      NC,L2129        ; forward to IN-PR-3 if not.
10161 2124
10162 2124 3E 22                LD      A,$22           ; load the '"' character
10163 2126 12                   LD      (DE),A          ; place quote in first new location at DE.
10164 2127 2B                   DEC     HL              ; decrease HL - from carriage return.
10165 2128 77                   LD      (HL),A          ; and place a quote in second location.
10166 2129
10167 2129              ;; IN-PR-3
10168 2129 22 5B 5C     L2129:  LD      ($5C5B),HL      ; set keyboard cursor K_CUR to HL
10169 212C FD CB 37 7E          BIT     7,(IY+$37)      ; test FLAGX  - is this INPUT LINE ??
10170 2130 20 2C                JR      NZ,L215E        ; forward to IN-VAR-3 if so as input will
10171 2132                                              ; be accepted without checking its syntax.
10172 2132
10173 2132 2A 5D 5C             LD      HL,($5C5D)      ; fetch CH_ADD
10174 2135 E5                   PUSH    HL              ; and save on stack.
10175 2136 2A 3D 5C             LD      HL,($5C3D)      ; fetch ERR_SP
10176 2139 E5                   PUSH    HL              ; and save on stack
10177 213A
10178 213A              ;; IN-VAR-1
10179 213A 21 3A 21     L213A:  LD      HL,L213A        ; address: IN-VAR-1 - this address
10180 213D E5                   PUSH    HL              ; is saved on stack to handle errors.
10181 213E FD CB 30 66          BIT     4,(IY+$30)      ; test FLAGS2  - is K channel in use ?
10182 2142 28 04                JR      Z,L2148         ; forward to IN-VAR-2 if not using the
10183 2144                                              ; keyboard for input. (??)
10184 2144
10185 2144 ED 73 3D 5C          LD      ($5C3D),SP      ; set ERR_SP to point to IN-VAR-1 on stack.
10186 2148
10187 2148              ;; IN-VAR-2
10188 2148 2A 61 5C     L2148:  LD      HL,($5C61)      ; set HL to WORKSP - start of workspace.
10189 214B CD A7 11             CALL    L11A7           ; routine REMOVE-FP removes floating point
10190 214E                                              ; forms when looping in error condition.
10191 214E FD 36 00 FF          LD      (IY+$00),$FF    ; set ERR_NR to 'OK' cancelling the error.
10192 2152                                              ; but X_PTR causes flashing error marker
10193 2152                                              ; to be displayed at each call to the editor.
10194 2152 CD 2C 0F             CALL    L0F2C           ; routine EDITOR allows input to be entered
10195 2155                                              ; or corrected if this is second time around.
10196 2155
10197 2155              ; if we pass to next then there are no system errors
10198 2155
10199 2155 FD CB 01 BE          RES     7,(IY+$01)      ; update FLAGS  - signal checking syntax
10200 2159 CD B9 21             CALL    L21B9           ; routine IN-ASSIGN checks syntax using
10201 215C                                              ; the VAL-FET-2 and powerful SCANNING routines.
10202 215C                                              ; any syntax error and its back to IN-VAR-1.
10203 215C                                              ; but with the flashing error marker showing
10204 215C                                              ; where the error is.
10205 215C                                              ; Note. the syntax of string input has to be
10206 215C                                              ; checked as the user may have removed the
10207 215C                                              ; bounding quotes or escaped them as with
10208 215C                                              ; "hat" + "stand" for example.
10209 215C              ; proceed if syntax passed.
10210 215C
10211 215C 18 03                JR      L2161           ; jump forward to IN-VAR-4
10212 215E
10213 215E              ; ---
10214 215E
10215 215E              ; the jump was to here when using INPUT LINE.
10216 215E
10217 215E              ;; IN-VAR-3
10218 215E CD 2C 0F     L215E:  CALL    L0F2C           ; routine EDITOR is called for input
10219 2161
10220 2161              ; when ENTER received rejoin other route but with no syntax check.
10221 2161
10222 2161              ; INPUT and INPUT LINE converge here.
10223 2161
10224 2161              ;; IN-VAR-4
10225 2161 FD 36 22 00  L2161:  LD      (IY+$22),$00    ; set K_CUR_hi to a low value so that the cursor
10226 2165                                              ; no longer appears in the input line.
10227 2165
10228 2165 CD D6 21             CALL    L21D6           ; routine IN-CHAN-K tests if the keyboard
10229 2168                                              ; is being used for input.
10230 2168 20 0A                JR      NZ,L2174        ; forward to IN-VAR-5 if using another input
10231 216A                                              ; channel.
10232 216A
10233 216A              ; continue here if using the keyboard.
10234 216A
10235 216A CD 1D 11             CALL    L111D           ; routine ED-COPY overprints the edit line
10236 216D                                              ; to the lower screen. The only visible
10237 216D                                              ; affect is that the cursor disappears.
10238 216D                                              ; if you're inputting more than one item in
10239 216D                                              ; a statement then that becomes apparent.
10240 216D
10241 216D ED 4B 82 5C          LD      BC,($5C82)      ; fetch line and column from ECHO_E
10242 2171 CD D9 0D             CALL    L0DD9           ; routine CL-SET sets S-POSNL to those
10243 2174                                              ; values.
10244 2174
10245 2174              ; if using another input channel rejoin here.
10246 2174
10247 2174              ;; IN-VAR-5
10248 2174 21 71 5C     L2174:  LD      HL,$5C71        ; point HL to FLAGX
10249 2177 CB AE                RES     5,(HL)          ; signal not in input mode
10250 2179 CB 7E                BIT     7,(HL)          ; is this INPUT LINE ?
10251 217B CB BE                RES     7,(HL)          ; cancel the bit anyway.
10252 217D 20 1C                JR      NZ,L219B        ; forward to IN-VAR-6 if INPUT LINE.
10253 217F
10254 217F E1                   POP     HL              ; drop the looping address
10255 2180 E1                   POP     HL              ; drop the address of previous
10256 2181                                              ; error handler.
10257 2181 22 3D 5C             LD      ($5C3D),HL      ; set ERR_SP to point to it.
10258 2184 E1                   POP     HL              ; drop original CH_ADD which points to
10259 2185                                              ; INPUT command in BASIC line.
10260 2185 22 5F 5C             LD      ($5C5F),HL      ; save in X_PTR while input is assigned.
10261 2188 FD CB 01 FE          SET     7,(IY+$01)      ; update FLAGS - Signal running program
10262 218C CD B9 21             CALL    L21B9           ; routine IN-ASSIGN is called again
10263 218F                                              ; this time the variable will be assigned
10264 218F                                              ; the input value without error.
10265 218F                                              ; Note. the previous example now
10266 218F                                              ; becomes "hatstand"
10267 218F
10268 218F 2A 5F 5C             LD      HL,($5C5F)      ; fetch stored CH_ADD value from X_PTR.
10269 2192 FD 36 26 00          LD      (IY+$26),$00    ; set X_PTR_hi so that iy is no longer relevant.
10270 2196 22 5D 5C             LD      ($5C5D),HL      ; put restored value back in CH_ADD
10271 2199 18 17                JR      L21B2           ; forward to IN-NEXT-2 to see if anything
10272 219B                                              ; more in the INPUT list.
10273 219B
10274 219B              ; ---
10275 219B
10276 219B              ; the jump was to here with INPUT LINE only
10277 219B
10278 219B              ;; IN-VAR-6
10279 219B 2A 63 5C     L219B:  LD      HL,($5C63)      ; STKBOT points to the end of the input.
10280 219E ED 5B 61 5C          LD      DE,($5C61)      ; WORKSP points to the beginning.
10281 21A2 37                   SCF                     ; prepare for true subtraction.
10282 21A3 ED 52                SBC     HL,DE           ; subtract to get length
10283 21A5 44                   LD      B,H             ; transfer it to
10284 21A6 4D                   LD      C,L             ; the BC register pair.
10285 21A7 CD B2 2A             CALL    L2AB2           ; routine STK-STO-$ stores parameters on
10286 21AA                                              ; the calculator stack.
10287 21AA CD FF 2A             CALL    L2AFF           ; routine LET assigns it to destination.
10288 21AD 18 03                JR      L21B2           ; forward to IN-NEXT-2 as print items
10289 21AF                                              ; not allowed with INPUT LINE.
10290 21AF                                              ; Note. that "hat" + "stand" will, for
10291 21AF                                              ; example, be unchanged as also would
10292 21AF                                              ; 'PRINT "Iris was here"'.
10293 21AF
10294 21AF              ; ---
10295 21AF
10296 21AF              ; the jump was to here when ALPHA found more items while looking for
10297 21AF              ; a variable name.
10298 21AF
10299 21AF              ;; IN-NEXT-1
10300 21AF CD FC 1F     L21AF:  CALL    L1FFC           ; routine PR-ITEM-1 considers further items.
10301 21B2
10302 21B2              ;; IN-NEXT-2
10303 21B2 CD 4E 20     L21B2:  CALL    L204E           ; routine PR-POSN-1 handles a position item.
10304 21B5 CA C1 20             JP      Z,L20C1         ; jump back to IN-ITEM-1 if the zero flag
10305 21B8                                              ; indicates more items are present.
10306 21B8
10307 21B8 C9                   RET                     ; return.
10308 21B9
10309 21B9              ; ---------------------------
10310 21B9              ; INPUT ASSIGNMENT Subroutine
10311 21B9              ; ---------------------------
10312 21B9              ; This subroutine is called twice from the INPUT command when normal
10313 21B9              ; keyboard input is assigned. On the first occasion syntax is checked
10314 21B9              ; using SCANNING. The final call with the syntax flag reset is to make
10315 21B9              ; the assignment.
10316 21B9
10317 21B9              ;; IN-ASSIGN
10318 21B9 2A 61 5C     L21B9:  LD      HL,($5C61)      ; fetch WORKSP start of input
10319 21BC 22 5D 5C             LD      ($5C5D),HL      ; set CH_ADD to first character
10320 21BF
10321 21BF DF                   RST     18H             ; GET-CHAR ignoring leading white-space.
10322 21C0 FE E2                CP      $E2             ; is it 'STOP'
10323 21C2 28 0C                JR      Z,L21D0         ; forward to IN-STOP if so.
10324 21C4
10325 21C4 3A 71 5C             LD      A,($5C71)       ; load accumulator from FLAGX
10326 21C7 CD 59 1C             CALL    L1C59           ; routine VAL-FET-2 makes assignment
10327 21CA                                              ; or goes through the motions if checking
10328 21CA                                              ; syntax. SCANNING is used.
10329 21CA
10330 21CA DF                   RST     18H             ; GET-CHAR
10331 21CB FE 0D                CP      $0D             ; is it carriage return ?
10332 21CD C8                   RET     Z               ; return if so
10333 21CE                                              ; either syntax is OK
10334 21CE                                              ; or assignment has been made.
10335 21CE
10336 21CE              ; if another character was found then raise an error.
10337 21CE              ; User doesn't see report but the flashing error marker
10338 21CE              ; appears in the lower screen.
10339 21CE
10340 21CE              ;; REPORT-Cb
10341 21CE CF           L21CE:  RST     08H             ; ERROR-1
10342 21CF 0B                   DEFB    $0B             ; Error Report: Nonsense in BASIC
10343 21D0
10344 21D0              ;; IN-STOP
10345 21D0 CD 30 25     L21D0:  CALL    L2530           ; routine SYNTAX-Z (UNSTACK-Z?)
10346 21D3 C8                   RET     Z               ; return if checking syntax
10347 21D4                                              ; as user wouldn't see error report.
10348 21D4                                              ; but generate visible error report
10349 21D4                                              ; on second invocation.
10350 21D4
10351 21D4              ;; REPORT-H
10352 21D4 CF           L21D4:  RST     08H             ; ERROR-1
10353 21D5 10                   DEFB    $10             ; Error Report: STOP in INPUT
10354 21D6
10355 21D6              ; -----------------------------------
10356 21D6              ; THE 'TEST FOR CHANNEL K' SUBROUTINE
10357 21D6              ; -----------------------------------
10358 21D6              ;   This subroutine is called once from the keyboard INPUT command to check if
10359 21D6              ;   the input routine in use is the one for the keyboard.
10360 21D6
10361 21D6              ;; IN-CHAN-K
10362 21D6 2A 51 5C     L21D6:  LD      HL,($5C51)      ; fetch address of current channel CURCHL
10363 21D9 23                   INC     HL              ;
10364 21DA 23                   INC     HL              ; advance past
10365 21DB 23                   INC     HL              ; input and
10366 21DC 23                   INC     HL              ; output streams
10367 21DD 7E                   LD      A,(HL)          ; fetch the channel identifier.
10368 21DE FE 4B                CP      $4B             ; test for 'K'
10369 21E0 C9                   RET                     ; return with zero set if keyboard is use.
10370 21E1
10371 21E1              ; --------------------
10372 21E1              ; Colour Item Routines
10373 21E1              ; --------------------
10374 21E1              ;
10375 21E1              ; These routines have 3 entry points -
10376 21E1              ; 1) CO-TEMP-2 to handle a series of embedded Graphic colour items.
10377 21E1              ; 2) CO-TEMP-3 to handle a single embedded print colour item.
10378 21E1              ; 3) CO TEMP-4 to handle a colour command such as FLASH 1
10379 21E1              ;
10380 21E1              ; "Due to a bug, if you bring in a peripheral channel and later use a colour
10381 21E1              ;  statement, colour controls will be sent to it by mistake." - Steven Vickers
10382 21E1              ;  Pitman Pocket Guide, 1984.
10383 21E1              ;
10384 21E1              ; To be fair, this only applies if the last channel was other than 'K', 'S'
10385 21E1              ; or 'P', which are all that are supported by this ROM, but if that last
10386 21E1              ; channel was a microdrive file, network channel etc. then
10387 21E1              ; PAPER 6; CLS will not turn the screen yellow and
10388 21E1              ; CIRCLE INK 2; 128,88,50 will not draw a red circle.
10389 21E1              ;
10390 21E1              ; This bug does not apply to embedded PRINT items as it is quite permissible
10391 21E1              ; to mix stream altering commands and colour items.
10392 21E1              ; The fix therefore would be to ensure that CLASS-07 and CLASS-09 make
10393 21E1              ; channel 'S' the current channel when not checking syntax.
10394 21E1              ; -----------------------------------------------------------------
10395 21E1
10396 21E1              ;; CO-TEMP-1
10397 21E1 E7           L21E1:  RST     20H             ; NEXT-CHAR
10398 21E2
10399 21E2              ; -> Entry point from CLASS-09. Embedded Graphic colour items.
10400 21E2              ; e.g. PLOT INK 2; PAPER 8; 128,88
10401 21E2              ; Loops till all colour items output, finally addressing the coordinates.
10402 21E2
10403 21E2              ;; CO-TEMP-2
10404 21E2 CD F2 21     L21E2:  CALL    L21F2           ; routine CO-TEMP-3 to output colour control.
10405 21E5 D8                   RET     C               ; return if nothing more to output. ->
10406 21E6
10407 21E6
10408 21E6 DF                   RST     18H             ; GET-CHAR
10409 21E7 FE 2C                CP      $2C             ; is it ',' separator ?
10410 21E9 28 F6                JR      Z,L21E1         ; back if so to CO-TEMP-1
10411 21EB
10412 21EB FE 3B                CP      $3B             ; is it ';' separator ?
10413 21ED 28 F2                JR      Z,L21E1         ; back to CO-TEMP-1 for more.
10414 21EF
10415 21EF C3 8A 1C             JP      L1C8A           ; to REPORT-C (REPORT-Cb is within range)
10416 21F2                                              ; 'Nonsense in BASIC'
10417 21F2
10418 21F2              ; -------------------
10419 21F2              ; CO-TEMP-3
10420 21F2              ; -------------------
10421 21F2              ; -> this routine evaluates and outputs a colour control and parameter.
10422 21F2              ; It is called from above and also from PR-ITEM-3 to handle a single embedded
10423 21F2              ; print item e.g. PRINT PAPER 6; "Hi". In the latter case, the looping for
10424 21F2              ; multiple items is within the PR-ITEM routine.
10425 21F2              ; It is quite permissible to send these to any stream.
10426 21F2
10427 21F2              ;; CO-TEMP-3
10428 21F2 FE D9        L21F2:  CP      $D9             ; is it 'INK' ?
10429 21F4 D8                   RET     C               ; return if less.
10430 21F5
10431 21F5 FE DF                CP      $DF             ; compare with 'OUT'
10432 21F7 3F                   CCF                     ; Complement Carry Flag
10433 21F8 D8                   RET     C               ; return if greater than 'OVER', $DE.
10434 21F9
10435 21F9 F5                   PUSH    AF              ; save the colour token.
10436 21FA
10437 21FA E7                   RST     20H             ; address NEXT-CHAR
10438 21FB F1                   POP     AF              ; restore token and continue.
10439 21FC
10440 21FC              ; -> this entry point used by CLASS-07. e.g. the command PAPER 6.
10441 21FC
10442 21FC              ;; CO-TEMP-4
10443 21FC D6 C9        L21FC:  SUB     $C9             ; reduce to control character $10 (INK)
10444 21FE                                              ; thru $15 (OVER).
10445 21FE F5                   PUSH    AF              ; save control.
10446 21FF CD 82 1C             CALL    L1C82           ; routine EXPT-1NUM stacks addressed
10447 2202                                              ; parameter on calculator stack.
10448 2202 F1                   POP     AF              ; restore control.
10449 2203 A7                   AND     A               ; clear carry
10450 2204
10451 2204 CD C3 1F             CALL    L1FC3           ; routine UNSTACK-Z returns if checking syntax.
10452 2207
10453 2207 F5                   PUSH    AF              ; save again
10454 2208 CD 94 1E             CALL    L1E94           ; routine FIND-INT1 fetches parameter to A.
10455 220B 57                   LD      D,A             ; transfer now to D
10456 220C F1                   POP     AF              ; restore control.
10457 220D
10458 220D D7                   RST     10H             ; PRINT-A outputs the control to current
10459 220E                                              ; channel.
10460 220E 7A                   LD      A,D             ; transfer parameter to A.
10461 220F
10462 220F D7                   RST     10H             ; PRINT-A outputs parameter.
10463 2210 C9                   RET                     ; return. ->
10464 2211
10465 2211              ; -------------------------------------------------------------------------
10466 2211              ;
10467 2211              ;         {fl}{br}{   paper   }{  ink    }    The temporary colour attributes
10468 2211              ;          ___ ___ ___ ___ ___ ___ ___ ___    system variable.
10469 2211              ; ATTR_T  |   |   |   |   |   |   |   |   |
10470 2211              ;         |   |   |   |   |   |   |   |   |
10471 2211              ; 23695   |___|___|___|___|___|___|___|___|
10472 2211              ;           7   6   5   4   3   2   1   0
10473 2211              ;
10474 2211              ;
10475 2211              ;         {fl}{br}{   paper   }{  ink    }    The temporary mask used for
10476 2211              ;          ___ ___ ___ ___ ___ ___ ___ ___    transparent colours. Any bit
10477 2211              ; MASK_T  |   |   |   |   |   |   |   |   |   that is 1 shows that the
10478 2211              ;         |   |   |   |   |   |   |   |   |   corresponding attribute is
10479 2211              ; 23696   |___|___|___|___|___|___|___|___|   taken not from ATTR-T but from
10480 2211              ;           7   6   5   4   3   2   1   0     what is already on the screen.
10481 2211              ;
10482 2211              ;
10483 2211              ;         {paper9 }{ ink9 }{ inv1 }{ over1}   The print flags. Even bits are
10484 2211              ;          ___ ___ ___ ___ ___ ___ ___ ___    temporary flags. The odd bits
10485 2211              ; P_FLAG  |   |   |   |   |   |   |   |   |   are the permanent flags.
10486 2211              ;         | p | t | p | t | p | t | p | t |
10487 2211              ; 23697   |___|___|___|___|___|___|___|___|
10488 2211              ;           7   6   5   4   3   2   1   0
10489 2211              ;
10490 2211              ; -----------------------------------------------------------------------
10491 2211
10492 2211              ; ------------------------------------
10493 2211              ;  The colour system variable handler.
10494 2211              ; ------------------------------------
10495 2211              ; This is an exit branch from PO-1-OPER, PO-2-OPER
10496 2211              ; A holds control $10 (INK) to $15 (OVER)
10497 2211              ; D holds parameter 0-9 for ink/paper 0,1 or 8 for bright/flash,
10498 2211              ; 0 or 1 for over/inverse.
10499 2211
10500 2211              ;; CO-TEMP-5
10501 2211 D6 11        L2211:  SUB     $11             ; reduce range $FF-$04
10502 2213 CE 00                ADC     A,$00           ; add in carry if INK
10503 2215 28 1D                JR      Z,L2234         ; forward to CO-TEMP-7 with INK and PAPER.
10504 2217
10505 2217 D6 02                SUB     $02             ; reduce range $FF-$02
10506 2219 CE 00                ADC     A,$00           ; add carry if FLASH
10507 221B 28 56                JR      Z,L2273         ; forward to CO-TEMP-C with FLASH and BRIGHT.
10508 221D
10509 221D FE 01                CP      $01             ; is it 'INVERSE' ?
10510 221F 7A                   LD      A,D             ; fetch parameter for INVERSE/OVER
10511 2220 06 01                LD      B,$01           ; prepare OVER mask setting bit 0.
10512 2222 20 04                JR      NZ,L2228        ; forward to CO-TEMP-6 if OVER
10513 2224
10514 2224 07                   RLCA                    ; shift bit 0
10515 2225 07                   RLCA                    ; to bit 2
10516 2226 06 04                LD      B,$04           ; set bit 2 of mask for inverse.
10517 2228
10518 2228              ;; CO-TEMP-6
10519 2228 4F           L2228:  LD      C,A             ; save the A
10520 2229 7A                   LD      A,D             ; re-fetch parameter
10521 222A FE 02                CP      $02             ; is it less than 2
10522 222C 30 16                JR      NC,L2244        ; to REPORT-K if not 0 or 1.
10523 222E                                              ; 'Invalid colour'.
10524 222E
10525 222E 79                   LD      A,C             ; restore A
10526 222F 21 91 5C             LD      HL,$5C91        ; address system variable P_FLAG
10527 2232 18 38                JR      L226C           ; forward to exit via routine CO-CHANGE
10528 2234
10529 2234              ; ---
10530 2234
10531 2234              ; the branch was here with INK/PAPER and carry set for INK.
10532 2234
10533 2234              ;; CO-TEMP-7
10534 2234 7A           L2234:  LD      A,D             ; fetch parameter
10535 2235 06 07                LD      B,$07           ; set ink mask 00000111
10536 2237 38 05                JR      C,L223E         ; forward to CO-TEMP-8 with INK
10537 2239
10538 2239 07                   RLCA                    ; shift bits 0-2
10539 223A 07                   RLCA                    ; to
10540 223B 07                   RLCA                    ; bits 3-5
10541 223C 06 38                LD      B,$38           ; set paper mask 00111000
10542 223E
10543 223E              ; both paper and ink rejoin here
10544 223E
10545 223E              ;; CO-TEMP-8
10546 223E 4F           L223E:  LD      C,A             ; value to C
10547 223F 7A                   LD      A,D             ; fetch parameter
10548 2240 FE 0A                CP      $0A             ; is it less than 10d ?
10549 2242 38 02                JR      C,L2246         ; forward to CO-TEMP-9 if so.
10550 2244
10551 2244              ; ink 10 etc. is not allowed.
10552 2244
10553 2244              ;; REPORT-K
10554 2244 CF           L2244:  RST     08H             ; ERROR-1
10555 2245 13                   DEFB    $13             ; Error Report: Invalid colour
10556 2246
10557 2246              ;; CO-TEMP-9
10558 2246 21 8F 5C     L2246:  LD      HL,$5C8F        ; address system variable ATTR_T initially.
10559 2249 FE 08                CP      $08             ; compare with 8
10560 224B 38 0B                JR      C,L2258         ; forward to CO-TEMP-B with 0-7.
10561 224D
10562 224D 7E                   LD      A,(HL)          ; fetch temporary attribute as no change.
10563 224E 28 07                JR      Z,L2257         ; forward to CO-TEMP-A with INK/PAPER 8
10564 2250
10565 2250              ; it is either ink 9 or paper 9 (contrasting)
10566 2250
10567 2250 B0                   OR      B               ; or with mask to make white
10568 2251 2F                   CPL                     ; make black and change other to dark
10569 2252 E6 24                AND     $24             ; 00100100
10570 2254 28 01                JR      Z,L2257         ; forward to CO-TEMP-A if black and
10571 2256                                              ; originally light.
10572 2256
10573 2256 78                   LD      A,B             ; else just use the mask (white)
10574 2257
10575 2257              ;; CO-TEMP-A
10576 2257 4F           L2257:  LD      C,A             ; save A in C
10577 2258
10578 2258              ;; CO-TEMP-B
10579 2258 79           L2258:  LD      A,C             ; load colour to A
10580 2259 CD 6C 22             CALL    L226C           ; routine CO-CHANGE addressing ATTR-T
10581 225C
10582 225C 3E 07                LD      A,$07           ; put 7 in accumulator
10583 225E BA                   CP      D               ; compare with parameter
10584 225F 9F                   SBC     A,A             ; $00 if 0-7, $FF if 8
10585 2260 CD 6C 22             CALL    L226C           ; routine CO-CHANGE addressing MASK-T
10586 2263                                              ; mask returned in A.
10587 2263
10588 2263              ; now consider P-FLAG.
10589 2263
10590 2263 07                   RLCA                    ; 01110000 or 00001110
10591 2264 07                   RLCA                    ; 11100000 or 00011100
10592 2265 E6 50                AND     $50             ; 01000000 or 00010000  (AND 01010000)
10593 2267 47                   LD      B,A             ; transfer to mask
10594 2268 3E 08                LD      A,$08           ; load A with 8
10595 226A BA                   CP      D               ; compare with parameter
10596 226B 9F                   SBC     A,A             ; $FF if was 9,  $00 if 0-8
10597 226C                                              ; continue while addressing P-FLAG
10598 226C                                              ; setting bit 4 if ink 9
10599 226C                                              ; setting bit 6 if paper 9
10600 226C
10601 226C              ; -----------------------
10602 226C              ; Handle change of colour
10603 226C              ; -----------------------
10604 226C              ; This routine addresses a system variable ATTR_T, MASK_T or P-FLAG in HL.
10605 226C              ; colour value in A, mask in B.
10606 226C
10607 226C              ;; CO-CHANGE
10608 226C AE           L226C:  XOR     (HL)            ; impress bits specified
10609 226D A0                   AND     B               ; by mask
10610 226E AE                   XOR     (HL)            ; on system variable.
10611 226F 77                   LD      (HL),A          ; update system variable.
10612 2270 23                   INC     HL              ; address next location.
10613 2271 78                   LD      A,B             ; put current value of mask in A
10614 2272 C9                   RET                     ; return.
10615 2273
10616 2273              ; ---
10617 2273
10618 2273              ; the branch was here with flash and bright
10619 2273
10620 2273              ;; CO-TEMP-C
10621 2273 9F           L2273:  SBC     A,A             ; set zero flag for bright.
10622 2274 7A                   LD      A,D             ; fetch original parameter 0,1 or 8
10623 2275 0F                   RRCA                    ; rotate bit 0 to bit 7
10624 2276 06 80                LD      B,$80           ; mask for flash 10000000
10625 2278 20 03                JR      NZ,L227D        ; forward to CO-TEMP-D if flash
10626 227A
10627 227A 0F                   RRCA                    ; rotate bit 7 to bit 6
10628 227B 06 40                LD      B,$40           ; mask for bright 01000000
10629 227D
10630 227D              ;; CO-TEMP-D
10631 227D 4F           L227D:  LD      C,A             ; store value in C
10632 227E 7A                   LD      A,D             ; fetch parameter
10633 227F FE 08                CP      $08             ; compare with 8
10634 2281 28 04                JR      Z,L2287         ; forward to CO-TEMP-E if 8
10635 2283
10636 2283 FE 02                CP      $02             ; test if 0 or 1
10637 2285 30 BD                JR      NC,L2244        ; back to REPORT-K if not
10638 2287                                              ; 'Invalid colour'
10639 2287
10640 2287              ;; CO-TEMP-E
10641 2287 79           L2287:  LD      A,C             ; value to A
10642 2288 21 8F 5C             LD      HL,$5C8F        ; address ATTR_T
10643 228B CD 6C 22             CALL    L226C           ; routine CO-CHANGE addressing ATTR_T
10644 228E 79                   LD      A,C             ; fetch value
10645 228F 0F                   RRCA                    ; for flash8/bright8 complete
10646 2290 0F                   RRCA                    ; rotations to put set bit in
10647 2291 0F                   RRCA                    ; bit 7 (flash) bit 6 (bright)
10648 2292 18 D8                JR      L226C           ; back to CO-CHANGE addressing MASK_T
10649 2294                                              ; and indirect return.
10650 2294
10651 2294              ; ---------------------
10652 2294              ; Handle BORDER command
10653 2294              ; ---------------------
10654 2294              ; Command syntax example: BORDER 7
10655 2294              ; This command routine sets the border to one of the eight colours.
10656 2294              ; The colours used for the lower screen are based on this.
10657 2294
10658 2294              ;; BORDER
10659 2294 CD 94 1E     L2294:  CALL    L1E94           ; routine FIND-INT1
10660 2297 FE 08                CP      $08             ; must be in range 0 (black) to 7 (white)
10661 2299 30 A9                JR      NC,L2244        ; back to REPORT-K if not
10662 229B                                              ; 'Invalid colour'.
10663 229B
10664 229B D3 FE                OUT     ($FE),A         ; outputting to port effects an immediate
10665 229D                                              ; change.
10666 229D 07                   RLCA                    ; shift the colour to
10667 229E 07                   RLCA                    ; the paper bits setting the
10668 229F 07                   RLCA                    ; ink colour black.
10669 22A0 CB 6F                BIT     5,A             ; is the number light coloured ?
10670 22A2                                              ; i.e. in the range green to white.
10671 22A2 20 02                JR      NZ,L22A6        ; skip to BORDER-1 if so
10672 22A4
10673 22A4 EE 07                XOR     $07             ; make the ink white.
10674 22A6
10675 22A6              ;; BORDER-1
10676 22A6 32 48 5C     L22A6:  LD      ($5C48),A       ; update BORDCR with new paper/ink
10677 22A9 C9                   RET                     ; return.
10678 22AA
10679 22AA              ; -----------------
10680 22AA              ; Get pixel address
10681 22AA              ; -----------------
10682 22AA              ;
10683 22AA              ;
10684 22AA
10685 22AA              ;; PIXEL-ADD
10686 22AA 3E AF        L22AA:  LD      A,$AF           ; load with 175 decimal.
10687 22AC 90                   SUB     B               ; subtract the y value.
10688 22AD DA F9 24             JP      C,L24F9         ; jump forward to REPORT-Bc if greater.
10689 22B0                                              ; 'Integer out of range'
10690 22B0
10691 22B0              ; the high byte is derived from Y only.
10692 22B0              ; the first 3 bits are always 010
10693 22B0              ; the next 2 bits denote in which third of the screen the byte is.
10694 22B0              ; the last 3 bits denote in which of the 8 scan lines within a third
10695 22B0              ; the byte is located. There are 24 discrete values.
10696 22B0
10697 22B0
10698 22B0 47                   LD      B,A             ; the line number from top of screen to B.
10699 22B1 A7                   AND     A               ; clear carry (already clear)
10700 22B2 1F                   RRA                     ;                     0xxxxxxx
10701 22B3 37                   SCF                     ; set carry flag
10702 22B4 1F                   RRA                     ;                     10xxxxxx
10703 22B5 A7                   AND     A               ; clear carry flag
10704 22B6 1F                   RRA                     ;                     010xxxxx
10705 22B7
10706 22B7 A8                   XOR     B               ;
10707 22B8 E6 F8                AND     $F8             ; keep the top 5 bits 11111000
10708 22BA A8                   XOR     B               ;                     010xxbbb
10709 22BB 67                   LD      H,A             ; transfer high byte to H.
10710 22BC
10711 22BC              ; the low byte is derived from both X and Y.
10712 22BC
10713 22BC 79                   LD      A,C             ; the x value 0-255.
10714 22BD 07                   RLCA                    ;
10715 22BE 07                   RLCA                    ;
10716 22BF 07                   RLCA                    ;
10717 22C0 A8                   XOR     B               ; the y value
10718 22C1 E6 C7                AND     $C7             ; apply mask             11000111
10719 22C3 A8                   XOR     B               ; restore unmasked bits  xxyyyxxx
10720 22C4 07                   RLCA                    ; rotate to              xyyyxxxx
10721 22C5 07                   RLCA                    ; required position.     yyyxxxxx
10722 22C6 6F                   LD      L,A             ; low byte to L.
10723 22C7
10724 22C7              ; finally form the pixel position in A.
10725 22C7
10726 22C7 79                   LD      A,C             ; x value to A
10727 22C8 E6 07                AND     $07             ; mod 8
10728 22CA C9                   RET                     ; return
10729 22CB
10730 22CB              ; ----------------
10731 22CB              ; Point Subroutine
10732 22CB              ; ----------------
10733 22CB              ; The point subroutine is called from s-point via the scanning functions
10734 22CB              ; table.
10735 22CB
10736 22CB              ;; POINT-SUB
10737 22CB CD 07 23     L22CB:  CALL    L2307           ; routine STK-TO-BC
10738 22CE CD AA 22             CALL    L22AA           ; routine PIXEL-ADD finds address of pixel.
10739 22D1 47                   LD      B,A             ; pixel position to B, 0-7.
10740 22D2 04                   INC     B               ; increment to give rotation count 1-8.
10741 22D3 7E                   LD      A,(HL)          ; fetch byte from screen.
10742 22D4
10743 22D4              ;; POINT-LP
10744 22D4 07           L22D4:  RLCA                    ; rotate and loop back
10745 22D5 10 FD                DJNZ    L22D4           ; to POINT-LP until pixel at right.
10746 22D7
10747 22D7 E6 01                AND      $01            ; test to give zero or one.
10748 22D9 C3 28 2D             JP      L2D28           ; jump forward to STACK-A to save result.
10749 22DC
10750 22DC              ; -------------------
10751 22DC              ; Handle PLOT command
10752 22DC              ; -------------------
10753 22DC              ; Command Syntax example: PLOT 128,88
10754 22DC              ;
10755 22DC
10756 22DC              ;; PLOT
10757 22DC CD 07 23     L22DC:  CALL    L2307           ; routine STK-TO-BC
10758 22DF CD E5 22             CALL    L22E5           ; routine PLOT-SUB
10759 22E2 C3 4D 0D             JP      L0D4D           ; to TEMPS
10760 22E5
10761 22E5              ; -------------------
10762 22E5              ; The Plot subroutine
10763 22E5              ; -------------------
10764 22E5              ; A screen byte holds 8 pixels so it is necessary to rotate a mask
10765 22E5              ; into the correct position to leave the other 7 pixels unaffected.
10766 22E5              ; However all 64 pixels in the character cell take any embedded colour
10767 22E5              ; items.
10768 22E5              ; A pixel can be reset (inverse 1), toggled (over 1), or set ( with inverse
10769 22E5              ; and over switches off). With both switches on, the byte is simply put
10770 22E5              ; back on the screen though the colours may change.
10771 22E5
10772 22E5              ;; PLOT-SUB
10773 22E5 ED 43 7D 5C  L22E5:  LD      ($5C7D),BC      ; store new x/y values in COORDS
10774 22E9 CD AA 22             CALL    L22AA           ; routine PIXEL-ADD gets address in HL,
10775 22EC                                              ; count from left 0-7 in B.
10776 22EC 47                   LD      B,A             ; transfer count to B.
10777 22ED 04                   INC     B               ; increase 1-8.
10778 22EE 3E FE                LD      A,$FE           ; 11111110 in A.
10779 22F0
10780 22F0              ;; PLOT-LOOP
10781 22F0 0F           L22F0:  RRCA                    ; rotate mask.
10782 22F1 10 FD                DJNZ    L22F0           ; to PLOT-LOOP until B circular rotations.
10783 22F3
10784 22F3 47                   LD      B,A             ; load mask to B
10785 22F4 7E                   LD      A,(HL)          ; fetch screen byte to A
10786 22F5
10787 22F5 FD 4E 57             LD      C,(IY+$57)      ; P_FLAG to C
10788 22F8 CB 41                BIT     0,C             ; is it to be OVER 1 ?
10789 22FA 20 01                JR      NZ,L22FD        ; forward to PL-TST-IN if so.
10790 22FC
10791 22FC              ; was over 0
10792 22FC
10793 22FC A0                   AND     B               ; combine with mask to blank pixel.
10794 22FD
10795 22FD              ;; PL-TST-IN
10796 22FD CB 51        L22FD:  BIT     2,C             ; is it inverse 1 ?
10797 22FF 20 02                JR      NZ,L2303        ; to PLOT-END if so.
10798 2301
10799 2301 A8                   XOR     B               ; switch the pixel
10800 2302 2F                   CPL                     ; restore other 7 bits
10801 2303
10802 2303              ;; PLOT-END
10803 2303 77           L2303:  LD      (HL),A          ; load byte to the screen.
10804 2304 C3 DB 0B             JP      L0BDB           ; exit to PO-ATTR to set colours for cell.
10805 2307
10806 2307              ; ------------------------------
10807 2307              ; Put two numbers in BC register
10808 2307              ; ------------------------------
10809 2307              ;
10810 2307              ;
10811 2307
10812 2307              ;; STK-TO-BC
10813 2307 CD 14 23     L2307:  CALL    L2314           ; routine STK-TO-A
10814 230A 47                   LD      B,A             ;
10815 230B C5                   PUSH    BC              ;
10816 230C CD 14 23             CALL    L2314           ; routine STK-TO-A
10817 230F 59                   LD      E,C             ;
10818 2310 C1                   POP     BC              ;
10819 2311 51                   LD      D,C             ;
10820 2312 4F                   LD      C,A             ;
10821 2313 C9                   RET                     ;
10822 2314
10823 2314              ; -----------------------
10824 2314              ; Put stack in A register
10825 2314              ; -----------------------
10826 2314              ; This routine puts the last value on the calculator stack into the accumulator
10827 2314              ; deleting the last value.
10828 2314
10829 2314              ;; STK-TO-A
10830 2314 CD D5 2D     L2314:  CALL    L2DD5           ; routine FP-TO-A compresses last value into
10831 2317                                              ; accumulator. e.g. PI would become 3.
10832 2317                                              ; zero flag set if positive.
10833 2317 DA F9 24             JP      C,L24F9         ; jump forward to REPORT-Bc if >= 255.5.
10834 231A
10835 231A 0E 01                LD      C,$01           ; prepare a positive sign byte.
10836 231C C8                   RET     Z               ; return if FP-TO-BC indicated positive.
10837 231D
10838 231D 0E FF                LD      C,$FF           ; prepare negative sign byte and
10839 231F C9                   RET                     ; return.
10840 2320
10841 2320
10842 2320              ; --------------------
10843 2320              ; THE 'CIRCLE' COMMAND
10844 2320              ; --------------------
10845 2320              ;   "Goe not Thou about to Square eyther circle" -
10846 2320              ;   - John Donne, Cambridge educated theologian, 1624
10847 2320              ;
10848 2320              ;   The CIRCLE command draws a circle as a series of straight lines.
10849 2320              ;   In some ways it can be regarded as a polygon, but the first line is drawn
10850 2320              ;   as a tangent, taking the radius as its distance from the centre.
10851 2320              ;
10852 2320              ;   Both the CIRCLE algorithm and the ARC drawing algorithm make use of the
10853 2320              ;   'ROTATION FORMULA' (see later).  It is only necessary to work out where
10854 2320              ;   the first line will be drawn and how long it is and then the rotation
10855 2320              ;   formula takes over and calculates all other rotated points.
10856 2320              ;
10857 2320              ;   All Spectrum circles consist of two vertical lines at each side and two
10858 2320              ;   horizontal lines at the top and bottom. The number of lines is calculated
10859 2320              ;   from the radius of the circle and is always divisible by 4. For complete
10860 2320              ;   circles it will range from 4 for a square circle to 32 for a circle of
10861 2320              ;   radius 87. The Spectrum can attempt larger circles e.g. CIRCLE 0,14,255
10862 2320              ;   but these will error as they go off-screen after four lines are drawn.
10863 2320              ;   At the opposite end, CIRCLE 128,88,1.23 will draw a circle as a perfect 3x3
10864 2320              ;   square using 4 straight lines although very small circles are just drawn as
10865 2320              ;   a dot on the screen.
10866 2320              ;
10867 2320              ;   The first chord drawn is the vertical chord on the right of the circle.
10868 2320              ;   The starting point is at the base of this chord which is drawn upwards and
10869 2320              ;   the circle continues in an anti-clockwise direction. As noted earlier the
10870 2320              ;   x-coordinate of this point measured from the centre of the circle is the
10871 2320              ;   radius.
10872 2320              ;
10873 2320              ;   The CIRCLE command makes extensive use of the calculator and as part of
10874 2320              ;   process of drawing a large circle, free memory is checked 1315 times.
10875 2320              ;   When drawing a large arc, free memory is checked 928 times.
10876 2320              ;   A single call to 'sin' involves 63 memory checks and so values of sine
10877 2320              ;   and cosine are pre-calculated and held in the mem locations. As a
10878 2320              ;   clever trick 'cos' is derived from 'sin' using simple arithmetic operations
10879 2320              ;   instead of the more expensive 'cos' function.
10880 2320              ;
10881 2320              ;   Initially, the syntax has been partly checked using the class for the DRAW
10882 2320              ;   command which stacks the origin of the circle (X,Y).
10883 2320
10884 2320              ;; CIRCLE
10885 2320 DF           L2320:  RST     18H             ; GET-CHAR              x, y.
10886 2321 FE 2C                CP      $2C             ; Is character the required comma ?
10887 2323 C2 8A 1C             JP      NZ,L1C8A        ; Jump, if not, to REPORT-C
10888 2326                                              ; 'Nonsense in basic'
10889 2326
10890 2326 E7                   RST     20H             ; NEXT-CHAR advances the parsed character address.
10891 2327 CD 82 1C             CALL    L1C82           ; routine EXPT-1NUM stacks radius in runtime.
10892 232A CD EE 1B             CALL    L1BEE           ; routine CHECK-END will return here in runtime
10893 232D                                              ; if nothing follows the command.
10894 232D
10895 232D              ;   Now make the radius positive and ensure that it is in floating point form
10896 232D              ;   so that the exponent byte can be accessed for quick testing.
10897 232D
10898 232D EF                   RST     28H             ;; FP-CALC              x, y, r.
10899 232E 2A                   DEFB    $2A             ;;abs                   x, y, r.
10900 232F 3D                   DEFB    $3D             ;;re-stack              x, y, r.
10901 2330 38                   DEFB    $38             ;;end-calc              x, y, r.
10902 2331
10903 2331 7E                   LD      A,(HL)          ; Fetch first, floating-point, exponent byte.
10904 2332 FE 81                CP      $81             ; Compare to one.
10905 2334 30 05                JR      NC,L233B        ; Forward to C-R-GRE-1
10906 2336                                              ; if circle radius is greater than one.
10907 2336
10908 2336              ;    The circle is no larger than a single pixel so delete the radius from the
10909 2336              ;    calculator stack and plot a point at the centre.
10910 2336
10911 2336 EF                   RST     28H             ;; FP-CALC              x, y, r.
10912 2337 02                   DEFB    $02             ;;delete                x, y.
10913 2338 38                   DEFB    $38             ;;end-calc              x, y.
10914 2339
10915 2339 18 A1                JR      L22DC           ; back to PLOT routine to just plot x,y.
10916 233B
10917 233B              ; ---
10918 233B
10919 233B              ;   Continue when the circle's radius measures greater than one by forming
10920 233B              ;   the angle 2 * PI radians which is 360 degrees.
10921 233B
10922 233B              ;; C-R-GRE-1
10923 233B EF           L233B:  RST     28H             ;; FP-CALC      x, y, r
10924 233C A3                   DEFB    $A3             ;;stk-pi/2      x, y, r, pi/2.
10925 233D 38                   DEFB    $38             ;;end-calc      x, y, r, pi/2.
10926 233E
10927 233E              ;   Change the exponent of pi/2 from $81 to $83 giving 2*PI the central angle.
10928 233E              ;   This is quicker than multiplying by four.
10929 233E
10930 233E 36 83                LD      (HL),$83        ;               x, y, r, 2*PI.
10931 2340
10932 2340              ;   Now store this important constant in mem-5 and delete so that other
10933 2340              ;   parameters can be derived from it, by a routine shared with DRAW.
10934 2340
10935 2340 EF                   RST     28H             ;; FP-CALC      x, y, r, 2*PI.
10936 2341 C5                   DEFB    $C5             ;;st-mem-5      store 2*PI in mem-5
10937 2342 02                   DEFB    $02             ;;delete        x, y, r.
10938 2343 38                   DEFB    $38             ;;end-calc      x, y, r.
10939 2344
10940 2344              ;   The parameters derived from mem-5 (A) and from the radius are set up in
10941 2344              ;   four of the other mem locations by the CIRCLE DRAW PARAMETERS routine which
10942 2344              ;   also returns the number of straight lines in the B register.
10943 2344
10944 2344 CD 7D 24             CALL    L247D           ; routine CD-PRMS1
10945 2347
10946 2347                                              ; mem-0 ; A/No of lines (=a)            unused
10947 2347                                              ; mem-1 ; sin(a/2)  will be moving x    var
10948 2347                                              ; mem-2 ; -         will be moving y    var
10949 2347                                              ; mem-3 ; cos(a)                        const
10950 2347                                              ; mem-4 ; sin(a)                        const
10951 2347                                              ; mem-5 ; Angle of rotation (A) (2*PI)  const
10952 2347                                              ; B     ; Number of straight lines.
10953 2347
10954 2347 C5                   PUSH    BC              ; Preserve the number of lines in B.
10955 2348
10956 2348              ;   Next calculate the length of half a chord by multiplying the sine of half
10957 2348              ;   the central angle by the radius of the circle.
10958 2348
10959 2348 EF                   RST     28H             ;; FP-CALC      x, y, r.
10960 2349 31                   DEFB    $31             ;;duplicate     x, y, r, r.
10961 234A E1                   DEFB    $E1             ;;get-mem-1     x, y, r, r, sin(a/2).
10962 234B 04                   DEFB    $04             ;;multiply      x, y, r, half-chord.
10963 234C 38                   DEFB    $38             ;;end-calc      x, y, r, half-chord.
10964 234D
10965 234D 7E                   LD      A,(HL)          ; fetch exponent  of the half arc to A.
10966 234E FE 80                CP      $80             ; compare to a half pixel
10967 2350 30 08                JR      NC,L235A        ; forward, if greater than .5, to C-ARC-GE1
10968 2352
10969 2352              ;   If the first line is less than .5 then 4 'lines' would be drawn on the same
10970 2352              ;   spot so tidy the calculator stack and machine stack and plot the centre.
10971 2352
10972 2352 EF                   RST     28H             ;; FP-CALC      x, y, r, hc.
10973 2353 02                   DEFB    $02             ;;delete        x, y, r.
10974 2354 02                   DEFB    $02             ;;delete        x, y.
10975 2355 38                   DEFB    $38             ;;end-calc      x, y.
10976 2356
10977 2356 C1                   POP     BC              ; Balance machine stack by taking chord-count.
10978 2357
10979 2357 C3 DC 22             JP      L22DC           ; JUMP to PLOT
10980 235A
10981 235A              ; ---
10982 235A
10983 235A              ;   The arc is greater than 0.5 so the circle can be drawn.
10984 235A
10985 235A              ;; C-ARC-GE1
10986 235A EF           L235A:  RST     28H             ;; FP-CALC      x, y, r, hc.
10987 235B C2                   DEFB    $C2             ;;st-mem-2      x, y, r, half chord to mem-2.
10988 235C 01                   DEFB    $01             ;;exchange      x, y, hc, r.
10989 235D C0                   DEFB    $C0             ;;st-mem-0      x, y, hc, r.
10990 235E 02                   DEFB    $02             ;;delete        x, y, hc.
10991 235F
10992 235F              ;   Subtract the length of the half-chord from the absolute y coordinate to
10993 235F              ;   give the starting y coordinate sy.
10994 235F              ;   Note that for a circle this is also the end coordinate.
10995 235F
10996 235F 03                   DEFB    $03             ;;subtract      x, y-hc.  (The start y-coord)
10997 2360 01                   DEFB    $01             ;;exchange      sy, x.
10998 2361
10999 2361              ;   Next simply add the radius to the x coordinate to give a fuzzy x-coordinate.
11000 2361              ;   Strictly speaking, the radius should be multiplied by cos(a/2) first but
11001 2361              ;   doing it this way makes the circle slightly larger.
11002 2361
11003 2361 E0                   DEFB    $E0             ;;get-mem-0     sy, x, r.
11004 2362 0F                   DEFB    $0F             ;;addition      sy, x+r.  (The start x-coord)
11005 2363
11006 2363              ;   We now want three copies of this pair of values on the calculator stack.
11007 2363              ;   The first pair remain on the stack throughout the circle routine and are
11008 2363              ;   the end points. The next pair will be the moving absolute values of x and y
11009 2363              ;   that are updated after each line is drawn. The final pair will be loaded
11010 2363              ;   into the COORDS system variable so that the first vertical line starts at
11011 2363              ;   the right place.
11012 2363
11013 2363 C0                   DEFB    $C0             ;;st-mem-0      sy, sx.
11014 2364 01                   DEFB    $01             ;;exchange      sx, sy.
11015 2365 31                   DEFB    $31             ;;duplicate     sx, sy, sy.
11016 2366 E0                   DEFB    $E0             ;;get-mem-0     sx, sy, sy, sx.
11017 2367 01                   DEFB    $01             ;;exchange      sx, sy, sx, sy.
11018 2368 31                   DEFB    $31             ;;duplicate     sx, sy, sx, sy, sy.
11019 2369 E0                   DEFB    $E0             ;;get-mem-0     sx, sy, sx, sy, sy, sx.
11020 236A
11021 236A              ;   Locations mem-1 and mem-2 are the relative x and y values which are updated
11022 236A              ;   after each line is drawn. Since we are drawing a vertical line then the rx
11023 236A              ;   value in mem-1 is zero and the ry value in mem-2 is the full chord.
11024 236A
11025 236A A0                   DEFB    $A0             ;;stk-zero      sx, sy, sx, sy, sy, sx, 0.
11026 236B C1                   DEFB    $C1             ;;st-mem-1      sx, sy, sx, sy, sy, sx, 0.
11027 236C 02                   DEFB    $02             ;;delete        sx, sy, sx, sy, sy, sx.
11028 236D
11029 236D              ;   Although the three pairs of x/y values are the same for a circle, they
11030 236D              ;   will be labelled terminating, absolute and start coordinates.
11031 236D
11032 236D 38                   DEFB    $38             ;;end-calc      tx, ty, ax, ay, sy, sx.
11033 236E
11034 236E              ;   Use the exponent manipulating trick again to double the value of mem-2.
11035 236E
11036 236E FD 34 62             INC     (IY+$62)        ; Increment MEM-2-1st doubling half chord.
11037 2371
11038 2371              ;   Note. this first vertical chord is drawn at the radius so circles are
11039 2371              ;   slightly displaced to the right.
11040 2371              ;   It is only necessary to place the values (sx) and (sy) in the system
11041 2371              ;   variable COORDS to ensure that drawing commences at the correct pixel.
11042 2371              ;   Note. a couple of LD (COORDS),A instructions would have been quicker, and
11043 2371              ;   simpler, than using LD (COORDS),HL.
11044 2371
11045 2371 CD 94 1E             CALL    L1E94           ; routine FIND-INT1 fetches sx from stack to A.
11046 2374
11047 2374 6F                   LD      L,A             ; place X value in L.
11048 2375 E5                   PUSH    HL              ; save the holding register.
11049 2376
11050 2376 CD 94 1E             CALL    L1E94           ; routine FIND-INT1 fetches sy to A
11051 2379
11052 2379 E1                   POP     HL              ; restore the holding register.
11053 237A 67                   LD      H,A             ; and place y value in high byte.
11054 237B
11055 237B 22 7D 5C             LD      ($5C7D),HL      ; Update the COORDS system variable.
11056 237E                                              ;
11057 237E                                              ;               tx, ty, ax, ay.
11058 237E
11059 237E C1                   POP     BC              ; restore the chord count
11060 237F                                              ; values 4,8,12,16,20,24,28 or 32.
11061 237F
11062 237F C3 20 24             JP      L2420           ; forward to DRW-STEPS
11063 2382                                              ;               tx, ty, ax, ay.
11064 2382
11065 2382              ;   Note. the jump to DRW-STEPS is just to decrement B and jump into the
11066 2382              ;   middle of the arc-drawing loop. The arc count which includes the first
11067 2382              ;   vertical arc draws one less than the perceived number of arcs.
11068 2382              ;   The final arc offsets are obtained by subtracting the final COORDS value
11069 2382              ;   from the initial sx and sy values which are kept at the base of the
11070 2382              ;   calculator stack throughout the arc loop.
11071 2382              ;   This ensures that the final line finishes exactly at the starting pixel
11072 2382              ;   removing the possibility of any inaccuracy.
11073 2382              ;   Since the initial sx and sy values are not required until the final arc
11074 2382              ;   is drawn, they are not shown until then.
11075 2382              ;   As the calculator stack is quite busy, only the active parts are shown in
11076 2382              ;   each section.
11077 2382
11078 2382
11079 2382              ; ------------------
11080 2382              ; THE 'DRAW' COMMAND
11081 2382              ; ------------------
11082 2382              ;   The Spectrum's DRAW command is overloaded and can take two parameters sets.
11083 2382              ;
11084 2382              ;   With two parameters, it simply draws an approximation to a straight line
11085 2382              ;   at offset x,y using the LINE-DRAW routine.
11086 2382              ;
11087 2382              ;   With three parameters, an arc is drawn to the point at offset x,y turning
11088 2382              ;   through an angle, in radians, supplied by the third parameter.
11089 2382              ;   The arc will consist of 4 to 252 straight lines each one of which is drawn
11090 2382              ;   by calls to the DRAW-LINE routine.
11091 2382
11092 2382              ;; DRAW
11093 2382 DF           L2382:  RST     18H             ; GET-CHAR
11094 2383 FE 2C                CP      $2C             ; is it the comma character ?
11095 2385 28 06                JR      Z,L238D         ; forward, if so, to DR-3-PRMS
11096 2387
11097 2387              ;   There are two parameters e.g. DRAW 255,175
11098 2387
11099 2387 CD EE 1B             CALL    L1BEE           ; routine CHECK-END
11100 238A
11101 238A C3 77 24             JP      L2477           ; jump forward to LINE-DRAW
11102 238D
11103 238D              ; ---
11104 238D
11105 238D              ;    There are three parameters e.g. DRAW 255, 175, .5
11106 238D              ;    The first two are relative coordinates and the third is the angle of
11107 238D              ;    rotation in radians (A).
11108 238D
11109 238D              ;; DR-3-PRMS
11110 238D E7           L238D:  RST     20H             ; NEXT-CHAR skips over the 'comma'.
11111 238E
11112 238E CD 82 1C             CALL    L1C82           ; routine EXPT-1NUM stacks the rotation angle.
11113 2391
11114 2391 CD EE 1B             CALL    L1BEE           ; routine CHECK-END
11115 2394
11116 2394              ;   Now enter the calculator and store the complete rotation angle in mem-5
11117 2394
11118 2394 EF                   RST     28H             ;; FP-CALC      x, y, A.
11119 2395 C5                   DEFB    $C5             ;;st-mem-5      x, y, A.
11120 2396
11121 2396              ;   Test the angle for the special case of 360 degrees.
11122 2396
11123 2396 A2                   DEFB    $A2             ;;stk-half      x, y, A, 1/2.
11124 2397 04                   DEFB    $04             ;;multiply      x, y, A/2.
11125 2398 1F                   DEFB    $1F             ;;sin           x, y, sin(A/2).
11126 2399 31                   DEFB    $31             ;;duplicate     x, y, sin(A/2),sin(A/2)
11127 239A 30                   DEFB    $30             ;;not           x, y, sin(A/2), (0/1).
11128 239B 30                   DEFB    $30             ;;not           x, y, sin(A/2), (1/0).
11129 239C 00                   DEFB    $00             ;;jump-true     x, y, sin(A/2).
11130 239D
11131 239D 06                   DEFB    $06             ;;forward to L23A3, DR-SIN-NZ
11132 239E                                              ; if sin(r/2) is not zero.
11133 239E
11134 239E              ;   The third parameter is 2*PI (or a multiple of 2*PI) so a 360 degrees turn
11135 239E              ;   would just be a straight line.  Eliminating this case here prevents
11136 239E              ;   division by zero at later stage.
11137 239E
11138 239E 02                   DEFB    $02             ;;delete        x, y.
11139 239F 38                   DEFB    $38             ;;end-calc      x, y.
11140 23A0
11141 23A0 C3 77 24             JP      L2477           ; forward to LINE-DRAW
11142 23A3
11143 23A3              ; ---
11144 23A3
11145 23A3              ;   An arc can be drawn.
11146 23A3
11147 23A3              ;; DR-SIN-NZ
11148 23A3 C0           L23A3:  DEFB    $C0             ;;st-mem-0      x, y, sin(A/2).   store mem-0
11149 23A4 02                   DEFB    $02             ;;delete        x, y.
11150 23A5
11151 23A5              ;   The next step calculates (roughly) the diameter of the circle of which the
11152 23A5              ;   arc will form part.  This value does not have to be too accurate as it is
11153 23A5              ;   only used to evaluate the number of straight lines and then discarded.
11154 23A5              ;   After all for a circle, the radius is used. Consequently, a circle of
11155 23A5              ;   radius 50 will have 24 straight lines but an arc of radius 50 will have 20
11156 23A5              ;   straight lines - when drawn in any direction.
11157 23A5              ;   So that simple arithmetic can be used, the length of the chord can be
11158 23A5              ;   calculated as X+Y rather than by Pythagoras Theorem and the sine of the
11159 23A5              ;   nearest angle within reach is used.
11160 23A5
11161 23A5 C1                   DEFB    $C1             ;;st-mem-1      x, y.             store mem-1
11162 23A6 02                   DEFB    $02             ;;delete        x.
11163 23A7
11164 23A7 31                   DEFB    $31             ;;duplicate     x, x.
11165 23A8 2A                   DEFB    $2A             ;;abs           x, x (+ve).
11166 23A9 E1                   DEFB    $E1             ;;get-mem-1     x, X, y.
11167 23AA 01                   DEFB    $01             ;;exchange      x, y, X.
11168 23AB E1                   DEFB    $E1             ;;get-mem-1     x, y, X, y.
11169 23AC 2A                   DEFB    $2A             ;;abs           x, y, X, Y (+ve).
11170 23AD 0F                   DEFB    $0F             ;;addition      x, y, X+Y.
11171 23AE E0                   DEFB    $E0             ;;get-mem-0     x, y, X+Y, sin(A/2).
11172 23AF 05                   DEFB    $05             ;;division      x, y, X+Y/sin(A/2).
11173 23B0 2A                   DEFB    $2A             ;;abs           x, y, X+Y/sin(A/2) = D.
11174 23B1
11175 23B1              ;    Bring back sin(A/2) from mem-0 which will shortly get trashed.
11176 23B1              ;    Then bring D to the top of the stack again.
11177 23B1
11178 23B1 E0                   DEFB    $E0             ;;get-mem-0     x, y, D, sin(A/2).
11179 23B2 01                   DEFB    $01             ;;exchange      x, y, sin(A/2), D.
11180 23B3
11181 23B3              ;   Note. that since the value at the top of the stack has arisen as a result
11182 23B3              ;   of division then it can no longer be in integer form and the next re-stack
11183 23B3              ;   is unnecessary. Only the Sinclair ZX80 had integer division.
11184 23B3
11185 23B3 3D                   DEFB    $3D             ;;re-stack      (unnecessary)
11186 23B4
11187 23B4 38                   DEFB    $38             ;;end-calc      x, y, sin(A/2), D.
11188 23B5
11189 23B5              ;   The next test avoids drawing 4 straight lines when the start and end pixels
11190 23B5              ;   are adjacent (or the same) but is probably best dispensed with.
11191 23B5
11192 23B5 7E                   LD      A,(HL)          ; fetch exponent byte of D.
11193 23B6 FE 81                CP      $81             ; compare to 1
11194 23B8 30 07                JR      NC,L23C1        ; forward, if > 1,  to DR-PRMS
11195 23BA
11196 23BA              ;   else delete the top two stack values and draw a simple straight line.
11197 23BA
11198 23BA EF                   RST     28H             ;; FP-CALC
11199 23BB 02                   DEFB    $02             ;;delete
11200 23BC 02                   DEFB    $02             ;;delete
11201 23BD 38                   DEFB    $38             ;;end-calc      x, y.
11202 23BE
11203 23BE C3 77 24             JP      L2477           ; to LINE-DRAW
11204 23C1
11205 23C1              ; ---
11206 23C1
11207 23C1              ;   The ARC will consist of multiple straight lines so call the CIRCLE-DRAW
11208 23C1              ;   PARAMETERS ROUTINE to pre-calculate sine values from the angle (in mem-5)
11209 23C1              ;   and determine also the number of straight lines from that value and the
11210 23C1              ;   'diameter' which is at the top of the calculator stack.
11211 23C1
11212 23C1              ;; DR-PRMS
11213 23C1 CD 7D 24     L23C1:  CALL    L247D           ; routine CD-PRMS1
11214 23C4
11215 23C4                                              ; mem-0 ; (A)/No. of lines (=a) (step angle)
11216 23C4                                              ; mem-1 ; sin(a/2)
11217 23C4                                              ; mem-2 ; -
11218 23C4                                              ; mem-3 ; cos(a)                        const
11219 23C4                                              ; mem-4 ; sin(a)                        const
11220 23C4                                              ; mem-5 ; Angle of rotation (A)         in
11221 23C4                                              ; B     ; Count of straight lines - max 252.
11222 23C4
11223 23C4 C5                   PUSH    BC              ; Save the line count on the machine stack.
11224 23C5
11225 23C5              ;   Remove the now redundant diameter value D.
11226 23C5
11227 23C5 EF                   RST     28H             ;; FP-CALC      x, y, sin(A/2), D.
11228 23C6 02                   DEFB    $02             ;;delete        x, y, sin(A/2).
11229 23C7
11230 23C7              ;   Dividing the sine of the step angle by the sine of the total angle gives
11231 23C7              ;   the length of the initial chord on a unary circle. This factor f is used
11232 23C7              ;   to scale the coordinates of the first line which still points in the
11233 23C7              ;   direction of the end point and may be larger.
11234 23C7
11235 23C7 E1                   DEFB    $E1             ;;get-mem-1     x, y, sin(A/2), sin(a/2)
11236 23C8 01                   DEFB    $01             ;;exchange      x, y, sin(a/2), sin(A/2)
11237 23C9 05                   DEFB    $05             ;;division      x, y, sin(a/2)/sin(A/2)
11238 23CA C1                   DEFB    $C1             ;;st-mem-1      x, y. f.
11239 23CB 02                   DEFB    $02             ;;delete        x, y.
11240 23CC
11241 23CC              ;   With the factor stored, scale the x coordinate first.
11242 23CC
11243 23CC 01                   DEFB    $01             ;;exchange      y, x.
11244 23CD 31                   DEFB    $31             ;;duplicate     y, x, x.
11245 23CE E1                   DEFB    $E1             ;;get-mem-1     y, x, x, f.
11246 23CF 04                   DEFB    $04             ;;multiply      y, x, x*f    (=xx)
11247 23D0 C2                   DEFB    $C2             ;;st-mem-2      y, x, xx.
11248 23D1 02                   DEFB    $02             ;;delete        y. x.
11249 23D2
11250 23D2              ;   Now scale the y coordinate.
11251 23D2
11252 23D2 01                   DEFB    $01             ;;exchange      x, y.
11253 23D3 31                   DEFB    $31             ;;duplicate     x, y, y.
11254 23D4 E1                   DEFB    $E1             ;;get-mem-1     x, y, y, f
11255 23D5 04                   DEFB    $04             ;;multiply      x, y, y*f    (=yy)
11256 23D6
11257 23D6              ;   Note. 'sin' and 'cos' trash locations mem-0 to mem-2 so fetch mem-2 to the
11258 23D6              ;   calculator stack for safe keeping.
11259 23D6
11260 23D6 E2                   DEFB    $E2             ;;get-mem-2     x, y, yy, xx.
11261 23D7
11262 23D7              ;   Once we get the coordinates of the first straight line then the 'ROTATION
11263 23D7              ;   FORMULA' used in the arc loop will take care of all other points, but we
11264 23D7              ;   now use a variation of that formula to rotate the first arc through (A-a)/2
11265 23D7              ;   radians.
11266 23D7              ;
11267 23D7              ;       xRotated = y * sin(angle) + x * cos(angle)
11268 23D7              ;       yRotated = y * cos(angle) - x * sin(angle)
11269 23D7              ;
11270 23D7
11271 23D7 E5                   DEFB    $E5             ;;get-mem-5     x, y, yy, xx, A.
11272 23D8 E0                   DEFB    $E0             ;;get-mem-0     x, y, yy, xx, A, a.
11273 23D9 03                   DEFB    $03             ;;subtract      x, y, yy, xx, A-a.
11274 23DA A2                   DEFB    $A2             ;;stk-half      x, y, yy, xx, A-a, 1/2.
11275 23DB 04                   DEFB    $04             ;;multiply      x, y, yy, xx, (A-a)/2. (=angle)
11276 23DC 31                   DEFB    $31             ;;duplicate     x, y, yy, xx, angle, angle.
11277 23DD 1F                   DEFB    $1F             ;;sin           x, y, yy, xx, angle, sin(angle)
11278 23DE C5                   DEFB    $C5             ;;st-mem-5      x, y, yy, xx, angle, sin(angle)
11279 23DF 02                   DEFB    $02             ;;delete        x, y, yy, xx, angle
11280 23E0
11281 23E0 20                   DEFB    $20             ;;cos           x, y, yy, xx, cos(angle).
11282 23E1
11283 23E1              ;   Note. mem-0, mem-1 and mem-2 can be used again now...
11284 23E1
11285 23E1 C0                   DEFB    $C0             ;;st-mem-0      x, y, yy, xx, cos(angle).
11286 23E2 02                   DEFB    $02             ;;delete        x, y, yy, xx.
11287 23E3
11288 23E3 C2                   DEFB    $C2             ;;st-mem-2      x, y, yy, xx.
11289 23E4 02                   DEFB    $02             ;;delete        x, y, yy.
11290 23E5
11291 23E5 C1                   DEFB    $C1             ;;st-mem-1      x, y, yy.
11292 23E6 E5                   DEFB    $E5             ;;get-mem-5     x, y, yy, sin(angle)
11293 23E7 04                   DEFB    $04             ;;multiply      x, y, yy*sin(angle).
11294 23E8 E0                   DEFB    $E0             ;;get-mem-0     x, y, yy*sin(angle), cos(angle)
11295 23E9 E2                   DEFB    $E2             ;;get-mem-2     x, y, yy*sin(angle), cos(angle), xx.
11296 23EA 04                   DEFB    $04             ;;multiply      x, y, yy*sin(angle), xx*cos(angle).
11297 23EB 0F                   DEFB    $0F             ;;addition      x, y, xRotated.
11298 23EC E1                   DEFB    $E1             ;;get-mem-1     x, y, xRotated, yy.
11299 23ED 01                   DEFB    $01             ;;exchange      x, y, yy, xRotated.
11300 23EE C1                   DEFB    $C1             ;;st-mem-1      x, y, yy, xRotated.
11301 23EF 02                   DEFB    $02             ;;delete        x, y, yy.
11302 23F0
11303 23F0 E0                   DEFB    $E0             ;;get-mem-0     x, y, yy, cos(angle).
11304 23F1 04                   DEFB    $04             ;;multiply      x, y, yy*cos(angle).
11305 23F2 E2                   DEFB    $E2             ;;get-mem-2     x, y, yy*cos(angle), xx.
11306 23F3 E5                   DEFB    $E5             ;;get-mem-5     x, y, yy*cos(angle), xx, sin(angle).
11307 23F4 04                   DEFB    $04             ;;multiply      x, y, yy*cos(angle), xx*sin(angle).
11308 23F5 03                   DEFB    $03             ;;subtract      x, y, yRotated.
11309 23F6 C2                   DEFB    $C2             ;;st-mem-2      x, y, yRotated.
11310 23F7
11311 23F7              ;   Now the initial x and y coordinates are made positive and summed to see
11312 23F7              ;   if they measure up to anything significant.
11313 23F7
11314 23F7 2A                   DEFB    $2A             ;;abs           x, y, yRotated'.
11315 23F8 E1                   DEFB    $E1             ;;get-mem-1     x, y, yRotated', xRotated.
11316 23F9 2A                   DEFB    $2A             ;;abs           x, y, yRotated', xRotated'.
11317 23FA 0F                   DEFB    $0F             ;;addition      x, y, yRotated+xRotated.
11318 23FB 02                   DEFB    $02             ;;delete        x, y.
11319 23FC
11320 23FC 38                   DEFB    $38             ;;end-calc      x, y.
11321 23FD
11322 23FD              ;   Although the test value has been deleted it is still above the calculator
11323 23FD              ;   stack in memory and conveniently DE which points to the first free byte
11324 23FD              ;   addresses the exponent of the test value.
11325 23FD
11326 23FD 1A                   LD      A,(DE)          ; Fetch exponent of the length indicator.
11327 23FE FE 81                CP      $81             ; Compare to that for 1
11328 2400
11329 2400 C1                   POP     BC              ; Balance the machine stack
11330 2401
11331 2401 DA 77 24             JP      C,L2477         ; forward, if the coordinates of first line
11332 2404                                              ; don't add up to more than 1, to LINE-DRAW
11333 2404
11334 2404              ;   Continue when the arc will have a discernable shape.
11335 2404
11336 2404 C5                   PUSH    BC              ; Restore line counter to the machine stack.
11337 2405
11338 2405              ;   The parameters of the DRAW command were relative and they are now converted
11339 2405              ;   to absolute coordinates by adding to the coordinates of the last point
11340 2405              ;   plotted. The first two values on the stack are the terminal tx and ty
11341 2405              ;   coordinates.  The x-coordinate is converted first but first the last point
11342 2405              ;   plotted is saved as it will initialize the moving ax, value.
11343 2405
11344 2405 EF                   RST     28H             ;; FP-CALC      x, y.
11345 2406 01                   DEFB    $01             ;;exchange      y, x.
11346 2407 38                   DEFB    $38             ;;end-calc      y, x.
11347 2408
11348 2408 3A 7D 5C             LD      A,($5C7D)       ; Fetch System Variable COORDS-x
11349 240B CD 28 2D             CALL    L2D28           ; routine STACK-A
11350 240E
11351 240E EF                   RST     28H             ;; FP-CALC      y, x, last-x.
11352 240F
11353 240F              ;   Store the last point plotted to initialize the moving ax value.
11354 240F
11355 240F C0                   DEFB    $C0             ;;st-mem-0      y, x, last-x.
11356 2410 0F                   DEFB    $0F             ;;addition      y, absolute x.
11357 2411 01                   DEFB    $01             ;;exchange      tx, y.
11358 2412 38                   DEFB    $38             ;;end-calc      tx, y.
11359 2413
11360 2413 3A 7E 5C             LD      A,($5C7E)       ; Fetch System Variable COORDS-y
11361 2416 CD 28 2D             CALL    L2D28           ; routine STACK-A
11362 2419
11363 2419 EF                   RST     28H             ;; FP-CALC      tx, y, last-y.
11364 241A
11365 241A              ;   Store the last point plotted to initialize the moving ay value.
11366 241A
11367 241A C5                   DEFB    $C5             ;;st-mem-5      tx, y, last-y.
11368 241B 0F                   DEFB    $0F             ;;addition      tx, ty.
11369 241C
11370 241C              ;   Fetch the moving ax and ay to the calculator stack.
11371 241C
11372 241C E0                   DEFB    $E0             ;;get-mem-0     tx, ty, ax.
11373 241D E5                   DEFB    $E5             ;;get-mem-5     tx, ty, ax, ay.
11374 241E 38                   DEFB    $38             ;;end-calc      tx, ty, ax, ay.
11375 241F
11376 241F C1                   POP     BC              ; Restore the straight line count.
11377 2420
11378 2420              ; -----------------------------------
11379 2420              ; THE 'CIRCLE/DRAW CONVERGENCE POINT'
11380 2420              ; -----------------------------------
11381 2420              ;   The CIRCLE and ARC-DRAW commands converge here.
11382 2420              ;
11383 2420              ;   Note. for both the CIRCLE and ARC commands the minimum initial line count
11384 2420              ;   is 4 (as set up by the CD_PARAMS routine) and so the zero flag will never
11385 2420              ;   be set and the loop is always entered.  The first test is superfluous and
11386 2420              ;   the jump will always be made to ARC-START.
11387 2420
11388 2420              ;; DRW-STEPS
11389 2420 05           L2420:  DEC     B               ; decrement the arc count (4,8,12,16...).
11390 2421
11391 2421 28 3C                JR      Z,L245F         ; forward, if zero (not possible), to ARC-END
11392 2423
11393 2423 18 14                JR      L2439           ; forward to ARC-START
11394 2425
11395 2425              ; --------------
11396 2425              ; THE 'ARC LOOP'
11397 2425              ; --------------
11398 2425              ;
11399 2425              ;   The arc drawing loop will draw up to 31 straight lines for a circle and up
11400 2425              ;   251 straight lines for an arc between two points. In both cases the final
11401 2425              ;   closing straight line is drawn at ARC_END, but it otherwise loops back to
11402 2425              ;   here to calculate the next coordinate using the ROTATION FORMULA where (a)
11403 2425              ;   is the previously calculated, constant CENTRAL ANGLE of the arcs.
11404 2425              ;
11405 2425              ;       Xrotated = x * cos(a) - y * sin(a)
11406 2425              ;       Yrotated = x * sin(a) + y * cos(a)
11407 2425              ;
11408 2425              ;   The values cos(a) and sin(a) are pre-calculated and held in mem-3 and mem-4
11409 2425              ;   for the duration of the routine.
11410 2425              ;   Memory location mem-1 holds the last relative x value (rx) and mem-2 holds
11411 2425              ;   the last relative y value (ry) used by DRAW.
11412 2425              ;
11413 2425              ;   Note. that this is a very clever twist on what is after all a very clever,
11414 2425              ;   well-used formula.  Normally the rotation formula is used with the x and y
11415 2425              ;   coordinates from the centre of the circle (or arc) and a supplied angle to
11416 2425              ;   produce two new x and y coordinates in an anticlockwise direction on the
11417 2425              ;   circumference of the circle.
11418 2425              ;   What is being used here, instead, is the relative X and Y parameters from
11419 2425              ;   the last point plotted that are required to get to the current point and
11420 2425              ;   the formula returns the next relative coordinates to use.
11421 2425
11422 2425              ;; ARC-LOOP
11423 2425 EF           L2425:  RST     28H             ;; FP-CALC
11424 2426 E1                   DEFB    $E1             ;;get-mem-1     rx.
11425 2427 31                   DEFB    $31             ;;duplicate     rx, rx.
11426 2428 E3                   DEFB    $E3             ;;get-mem-3     cos(a)
11427 2429 04                   DEFB    $04             ;;multiply      rx, rx*cos(a).
11428 242A E2                   DEFB    $E2             ;;get-mem-2     rx, rx*cos(a), ry.
11429 242B E4                   DEFB    $E4             ;;get-mem-4     rx, rx*cos(a), ry, sin(a).
11430 242C 04                   DEFB    $04             ;;multiply      rx, rx*cos(a), ry*sin(a).
11431 242D 03                   DEFB    $03             ;;subtract      rx, rx*cos(a) - ry*sin(a)
11432 242E C1                   DEFB    $C1             ;;st-mem-1      rx, new relative x rotated.
11433 242F 02                   DEFB    $02             ;;delete        rx.
11434 2430
11435 2430 E4                   DEFB    $E4             ;;get-mem-4     rx, sin(a).
11436 2431 04                   DEFB    $04             ;;multiply      rx*sin(a)
11437 2432 E2                   DEFB    $E2             ;;get-mem-2     rx*sin(a), ry.
11438 2433 E3                   DEFB    $E3             ;;get-mem-3     rx*sin(a), ry, cos(a).
11439 2434 04                   DEFB    $04             ;;multiply      rx*sin(a), ry*cos(a).
11440 2435 0F                   DEFB    $0F             ;;addition      rx*sin(a) + ry*cos(a).
11441 2436 C2                   DEFB    $C2             ;;st-mem-2      new relative y rotated.
11442 2437 02                   DEFB    $02             ;;delete        .
11443 2438 38                   DEFB    $38             ;;end-calc      .
11444 2439
11445 2439              ;   Note. the calculator stack actually holds   tx, ty, ax, ay
11446 2439              ;   and the last absolute values of x and y
11447 2439              ;   are now brought into play.
11448 2439              ;
11449 2439              ;   Magically, the two new rotated coordinates rx and ry are all that we would
11450 2439              ;   require to draw a circle or arc - on paper!
11451 2439              ;   The Spectrum DRAW routine draws to the rounded x and y coordinate and so
11452 2439              ;   repetitions of values like 3.49 would mean that the fractional parts
11453 2439              ;   would be lost until eventually the draw coordinates might differ from the
11454 2439              ;   floating point values used above by several pixels.
11455 2439              ;   For this reason the accurate offsets calculated above are added to the
11456 2439              ;   accurate, absolute coordinates maintained in ax and ay and these new
11457 2439              ;   coordinates have the integer coordinates of the last plot position
11458 2439              ;   ( from System Variable COORDS ) subtracted from them to give the relative
11459 2439              ;   coordinates required by the DRAW routine.
11460 2439
11461 2439              ;   The mid entry point.
11462 2439
11463 2439              ;; ARC-START
11464 2439 C5           L2439:  PUSH    BC              ; Preserve the arc counter on the machine stack.
11465 243A
11466 243A              ;   Store the absolute ay in temporary variable mem-0 for the moment.
11467 243A
11468 243A EF                   RST     28H             ;; FP-CALC      ax, ay.
11469 243B C0                   DEFB    $C0             ;;st-mem-0      ax, ay.
11470 243C 02                   DEFB    $02             ;;delete        ax.
11471 243D
11472 243D              ;   Now add the fractional relative x coordinate to the fractional absolute
11473 243D              ;   x coordinate to obtain a new fractional x-coordinate.
11474 243D
11475 243D E1                   DEFB    $E1             ;;get-mem-1     ax, xr.
11476 243E 0F                   DEFB    $0F             ;;addition      ax+xr (= new ax).
11477 243F 31                   DEFB    $31             ;;duplicate     ax, ax.
11478 2440 38                   DEFB    $38             ;;end-calc      ax, ax.
11479 2441
11480 2441 3A 7D 5C             LD      A,($5C7D)       ; COORDS-x      last x    (integer ix 0-255)
11481 2444 CD 28 2D             CALL    L2D28           ; routine STACK-A
11482 2447
11483 2447 EF                   RST     28H             ;; FP-CALC      ax, ax, ix.
11484 2448 03                   DEFB    $03             ;;subtract      ax, ax-ix  = relative DRAW Dx.
11485 2449
11486 2449              ;   Having calculated the x value for DRAW do the same for the y value.
11487 2449
11488 2449 E0                   DEFB    $E0             ;;get-mem-0     ax, Dx, ay.
11489 244A E2                   DEFB    $E2             ;;get-mem-2     ax, Dx, ay, ry.
11490 244B 0F                   DEFB    $0F             ;;addition      ax, Dx, ay+ry (= new ay).
11491 244C C0                   DEFB    $C0             ;;st-mem-0      ax, Dx, ay.
11492 244D 01                   DEFB    $01             ;;exchange      ax, ay, Dx,
11493 244E E0                   DEFB    $E0             ;;get-mem-0     ax, ay, Dx, ay.
11494 244F 38                   DEFB    $38             ;;end-calc      ax, ay, Dx, ay.
11495 2450
11496 2450 3A 7E 5C             LD      A,($5C7E)       ; COORDS-y      last y (integer iy 0-175)
11497 2453 CD 28 2D             CALL    L2D28           ; routine STACK-A
11498 2456
11499 2456 EF                   RST     28H             ;; FP-CALC      ax, ay, Dx, ay, iy.
11500 2457 03                   DEFB    $03             ;;subtract      ax, ay, Dx, ay-iy ( = Dy).
11501 2458 38                   DEFB    $38             ;;end-calc      ax, ay, Dx, Dy.
11502 2459
11503 2459 CD B7 24             CALL    L24B7           ; Routine DRAW-LINE draws (Dx,Dy) relative to
11504 245C                                              ; the last pixel plotted leaving absolute x
11505 245C                                              ; and y on the calculator stack.
11506 245C                                              ;               ax, ay.
11507 245C
11508 245C C1                   POP     BC              ; Restore the arc counter from the machine stack.
11509 245D
11510 245D 10 C6                DJNZ    L2425           ; Decrement and loop while > 0 to ARC-LOOP
11511 245F
11512 245F              ; -------------
11513 245F              ; THE 'ARC END'
11514 245F              ; -------------
11515 245F
11516 245F              ;   To recap the full calculator stack is       tx, ty, ax, ay.
11517 245F
11518 245F              ;   Just as one would do if drawing the curve on paper, the final line would
11519 245F              ;   be drawn by joining the last point plotted to the initial start point
11520 245F              ;   in the case of a CIRCLE or to the calculated end point in the case of
11521 245F              ;   an ARC.
11522 245F              ;   The moving absolute values of x and y are no longer required and they
11523 245F              ;   can be deleted to expose the closing coordinates.
11524 245F
11525 245F              ;; ARC-END
11526 245F EF           L245F:  RST     28H             ;; FP-CALC      tx, ty, ax, ay.
11527 2460 02                   DEFB    $02             ;;delete        tx, ty, ax.
11528 2461 02                   DEFB    $02             ;;delete        tx, ty.
11529 2462 01                   DEFB    $01             ;;exchange      ty, tx.
11530 2463 38                   DEFB    $38             ;;end-calc      ty, tx.
11531 2464
11532 2464              ;   First calculate the relative x coordinate to the end-point.
11533 2464
11534 2464 3A 7D 5C             LD      A,($5C7D)       ; COORDS-x
11535 2467 CD 28 2D             CALL    L2D28           ; routine STACK-A
11536 246A
11537 246A EF                   RST     28H             ;; FP-CALC      ty, tx, coords_x.
11538 246B 03                   DEFB    $03             ;;subtract      ty, rx.
11539 246C
11540 246C              ;   Next calculate the relative y coordinate to the end-point.
11541 246C
11542 246C 01                   DEFB    $01             ;;exchange      rx, ty.
11543 246D 38                   DEFB    $38             ;;end-calc      rx, ty.
11544 246E
11545 246E 3A 7E 5C             LD      A,($5C7E)       ; COORDS-y
11546 2471 CD 28 2D             CALL    L2D28           ; routine STACK-A
11547 2474
11548 2474 EF                   RST     28H             ;; FP-CALC      rx, ty, coords_y
11549 2475 03                   DEFB    $03             ;;subtract      rx, ry.
11550 2476 38                   DEFB    $38             ;;end-calc      rx, ry.
11551 2477
11552 2477              ;   Finally draw the last straight line.
11553 2477
11554 2477              ;; LINE-DRAW
11555 2477 CD B7 24     L2477:  CALL    L24B7           ; routine DRAW-LINE draws to the relative
11556 247A                                              ; coordinates (rx, ry).
11557 247A
11558 247A C3 4D 0D             JP      L0D4D           ; jump back and exit via TEMPS          >>>
11559 247D
11560 247D
11561 247D              ; --------------------------------------------
11562 247D              ; THE 'INITIAL CIRCLE/DRAW PARAMETERS' ROUTINE
11563 247D              ; --------------------------------------------
11564 247D              ;   Begin by calculating the number of chords which will be returned in B.
11565 247D              ;   A rule of thumb is employed that uses a value z which for a circle is the
11566 247D              ;   radius and for an arc is the diameter with, as it happens, a pinch more if
11567 247D              ;   the arc is on a slope.
11568 247D              ;
11569 247D              ;   NUMBER OF STRAIGHT LINES = ANGLE OF ROTATION * SQUARE ROOT ( Z ) / 2
11570 247D
11571 247D              ;; CD-PRMS1
11572 247D EF           L247D:  RST     28H             ;; FP-CALC      z.
11573 247E 31                   DEFB    $31             ;;duplicate     z, z.
11574 247F 28                   DEFB    $28             ;;sqr           z, sqr(z).
11575 2480 34                   DEFB    $34             ;;stk-data      z, sqr(z), 2.
11576 2481 32                   DEFB    $32             ;;Exponent: $82, Bytes: 1
11577 2482 00                   DEFB    $00             ;;(+00,+00,+00)
11578 2483 01                   DEFB    $01             ;;exchange      z, 2, sqr(z).
11579 2484 05                   DEFB    $05             ;;division      z, 2/sqr(z).
11580 2485 E5                   DEFB    $E5             ;;get-mem-5     z, 2/sqr(z), ANGLE.
11581 2486 01                   DEFB    $01             ;;exchange      z, ANGLE, 2/sqr (z)
11582 2487 05                   DEFB    $05             ;;division      z, ANGLE*sqr(z)/2 (= No. of lines)
11583 2488 2A                   DEFB    $2A             ;;abs           (for arc only)
11584 2489 38                   DEFB    $38             ;;end-calc      z, number of lines.
11585 248A
11586 248A              ;    As an example for a circle of radius 87 the number of lines will be 29.
11587 248A
11588 248A CD D5 2D             CALL    L2DD5           ; routine FP-TO-A
11589 248D
11590 248D              ;    The value is compressed into A register, no carry with valid circle.
11591 248D
11592 248D 38 06                JR      C,L2495         ; forward, if over 256, to USE-252
11593 248F
11594 248F              ;    now make a multiple of 4 e.g. 29 becomes 28
11595 248F
11596 248F E6 FC                AND     $FC             ; AND 252
11597 2491
11598 2491              ;    Adding 4 could set carry for arc, for the circle example, 28 becomes 32.
11599 2491
11600 2491 C6 04                ADD     A,$04           ; adding 4 could set carry if result is 256.
11601 2493
11602 2493 30 02                JR      NC,L2497        ; forward if less than 256 to DRAW-SAVE
11603 2495
11604 2495              ;    For an arc, a limit of 252 is imposed.
11605 2495
11606 2495              ;; USE-252
11607 2495 3E FC        L2495:  LD      A,$FC           ; Use a value of 252 (for arc).
11608 2497
11609 2497
11610 2497              ;   For both arcs and circles, constants derived from the central angle are
11611 2497              ;   stored in the 'mem' locations.  Some are not relevant for the circle.
11612 2497
11613 2497              ;; DRAW-SAVE
11614 2497 F5           L2497:  PUSH    AF              ; Save the line count (A) on the machine stack.
11615 2498
11616 2498 CD 28 2D             CALL    L2D28           ; Routine STACK-A stacks the modified count(A).
11617 249B
11618 249B EF                   RST     28H             ;; FP-CALC      z, A.
11619 249C E5                   DEFB    $E5             ;;get-mem-5     z, A, ANGLE.
11620 249D 01                   DEFB    $01             ;;exchange      z, ANGLE, A.
11621 249E 05                   DEFB    $05             ;;division      z, ANGLE/A. (Angle/count = a)
11622 249F 31                   DEFB    $31             ;;duplicate     z, a, a.
11623 24A0
11624 24A0              ;  Note. that cos (a) could be formed here directly using 'cos' and stored in
11625 24A0              ;  mem-3 but that would spoil a good story and be slightly slower, as also
11626 24A0              ;  would using square roots to form cos (a) from sin (a).
11627 24A0
11628 24A0 1F                   DEFB    $1F             ;;sin           z, a, sin(a)
11629 24A1 C4                   DEFB    $C4             ;;st-mem-4      z, a, sin(a)
11630 24A2 02                   DEFB    $02             ;;delete        z, a.
11631 24A3 31                   DEFB    $31             ;;duplicate     z, a, a.
11632 24A4 A2                   DEFB    $A2             ;;stk-half      z, a, a, 1/2.
11633 24A5 04                   DEFB    $04             ;;multiply      z, a, a/2.
11634 24A6 1F                   DEFB    $1F             ;;sin           z, a, sin(a/2).
11635 24A7
11636 24A7              ;   Note. after second sin, mem-0 and mem-1 become free.
11637 24A7
11638 24A7 C1                   DEFB    $C1             ;;st-mem-1      z, a, sin(a/2).
11639 24A8 01                   DEFB    $01             ;;exchange      z, sin(a/2), a.
11640 24A9 C0                   DEFB    $C0             ;;st-mem-0      z, sin(a/2), a.  (for arc only)
11641 24AA
11642 24AA              ;   Now form cos(a) from sin(a/2) using the 'DOUBLE ANGLE FORMULA'.
11643 24AA
11644 24AA 02                   DEFB    $02             ;;delete        z, sin(a/2).
11645 24AB 31                   DEFB    $31             ;;duplicate     z, sin(a/2), sin(a/2).
11646 24AC 04                   DEFB    $04             ;;multiply      z, sin(a/2)*sin(a/2).
11647 24AD 31                   DEFB    $31             ;;duplicate     z, sin(a/2)*sin(a/2),
11648 24AE                                              ;;                           sin(a/2)*sin(a/2).
11649 24AE 0F                   DEFB    $0F             ;;addition      z, 2*sin(a/2)*sin(a/2).
11650 24AF A1                   DEFB    $A1             ;;stk-one       z, 2*sin(a/2)*sin(a/2), 1.
11651 24B0 03                   DEFB    $03             ;;subtract      z, 2*sin(a/2)*sin(a/2)-1.
11652 24B1
11653 24B1 1B                   DEFB    $1B             ;;negate        z, 1-2*sin(a/2)*sin(a/2).
11654 24B2
11655 24B2 C3                   DEFB    $C3             ;;st-mem-3      z, cos(a).
11656 24B3 02                   DEFB    $02             ;;delete        z.
11657 24B4 38                   DEFB    $38             ;;end-calc      z.
11658 24B5
11659 24B5              ;   The radius/diameter is left on the calculator stack.
11660 24B5
11661 24B5 C1                   POP     BC              ; Restore the line count to the B register.
11662 24B6
11663 24B6 C9                   RET                     ; Return.
11664 24B7
11665 24B7              ; --------------------------
11666 24B7              ; THE 'DOUBLE ANGLE FORMULA'
11667 24B7              ; --------------------------
11668 24B7              ;   This formula forms cos(a) from sin(a/2) using simple arithmetic.
11669 24B7              ;
11670 24B7              ;   THE GEOMETRIC PROOF OF FORMULA   cos (a) = 1 - 2 * sin(a/2) * sin(a/2)
11671 24B7              ;
11672 24B7              ;
11673 24B7              ;                                            A
11674 24B7              ;
11675 24B7              ;                                         . /|\
11676 24B7              ;                                     .    / | \
11677 24B7              ;                                  .      /  |  \
11678 24B7              ;                               .        /   |a/2\
11679 24B7              ;                            .          /    |    \
11680 24B7              ;                         .          1 /     |     \
11681 24B7              ;                      .              /      |      \
11682 24B7              ;                   .                /       |       \
11683 24B7              ;                .                  /        |        \
11684 24B7              ;             .  a/2             D / a      E|-+       \
11685 24B7              ;          B ---------------------/----------+-+--------\ C
11686 24B7              ;            <-         1       -><-       1           ->
11687 24B7              ;
11688 24B7              ;   cos a = 1 - 2 * sin(a/2) * sin(a/2)
11689 24B7              ;
11690 24B7              ;   The figure shows a right triangle that inscribes a circle of radius 1 with
11691 24B7              ;   centre, or origin, D.  Line BC is the diameter of length 2 and A is a point
11692 24B7              ;   on the circle. The periphery angle BAC is therefore a right angle by the
11693 24B7              ;   Rule of Thales.
11694 24B7              ;   Line AC is a chord touching two points on the circle and the angle at the
11695 24B7              ;   centre is (a).
11696 24B7              ;   Since the vertex of the largest triangle B touches the circle, the
11697 24B7              ;   inscribed angle (a/2) is half the central angle (a).
11698 24B7              ;   The cosine of (a) is the length DE as the hypotenuse is of length 1.
11699 24B7              ;   This can also be expressed as 1-length CE.  Examining the triangle at the
11700 24B7              ;   right, the top angle is also (a/2) as angle BAE and EBA add to give a right
11701 24B7              ;   angle as do BAE and EAC.
11702 24B7              ;   So cos (a) = 1 - AC * sin(a/2)
11703 24B7              ;   Looking at the largest triangle, side AC can be expressed as
11704 24B7              ;   AC = 2 * sin(a/2)   and so combining these we get
11705 24B7              ;   cos (a) = 1 - 2 * sin(a/2) * sin(a/2).
11706 24B7              ;
11707 24B7              ;   "I will be sufficiently rewarded if when telling it to others, you will
11708 24B7              ;    not claim the discovery as your own, but will say it is mine."
11709 24B7              ;   - Thales, 640 - 546 B.C.
11710 24B7              ;
11711 24B7              ; --------------------------
11712 24B7              ; THE 'LINE DRAWING' ROUTINE
11713 24B7              ; --------------------------
11714 24B7              ;
11715 24B7              ;
11716 24B7
11717 24B7              ;; DRAW-LINE
11718 24B7 CD 07 23     L24B7:  CALL    L2307           ; routine STK-TO-BC
11719 24BA 79                   LD      A,C             ;
11720 24BB B8                   CP      B               ;
11721 24BC 30 06                JR      NC,L24C4        ; to DL-X-GE-Y
11722 24BE
11723 24BE 69                   LD      L,C             ;
11724 24BF D5                   PUSH    DE              ;
11725 24C0 AF                   XOR     A               ;
11726 24C1 5F                   LD      E,A             ;
11727 24C2 18 07                JR      L24CB           ; to DL-LARGER
11728 24C4
11729 24C4              ; ---
11730 24C4
11731 24C4              ;; DL-X-GE-Y
11732 24C4 B1           L24C4:  OR      C               ;
11733 24C5 C8                   RET     Z               ;
11734 24C6
11735 24C6 68                   LD      L,B             ;
11736 24C7 41                   LD      B,C             ;
11737 24C8 D5                   PUSH    DE              ;
11738 24C9 16 00                LD      D,$00           ;
11739 24CB
11740 24CB              ;; DL-LARGER
11741 24CB 60           L24CB:  LD      H,B             ;
11742 24CC 78                   LD      A,B             ;
11743 24CD 1F                   RRA                     ;
11744 24CE
11745 24CE              ;; D-L-LOOP
11746 24CE 85           L24CE:  ADD     A,L             ;
11747 24CF 38 03                JR      C,L24D4         ; to D-L-DIAG
11748 24D1
11749 24D1 BC                   CP      H               ;
11750 24D2 38 07                JR      C,L24DB         ; to D-L-HR-VT
11751 24D4
11752 24D4              ;; D-L-DIAG
11753 24D4 94           L24D4:  SUB     H               ;
11754 24D5 4F                   LD      C,A             ;
11755 24D6 D9                   EXX                     ;
11756 24D7 C1                   POP     BC              ;
11757 24D8 C5                   PUSH    BC              ;
11758 24D9 18 04                JR      L24DF           ; to D-L-STEP
11759 24DB
11760 24DB              ; ---
11761 24DB
11762 24DB              ;; D-L-HR-VT
11763 24DB 4F           L24DB:  LD      C,A             ;
11764 24DC D5                   PUSH    DE              ;
11765 24DD D9                   EXX                     ;
11766 24DE C1                   POP     BC              ;
11767 24DF
11768 24DF              ;; D-L-STEP
11769 24DF 2A 7D 5C     L24DF:  LD      HL,($5C7D)      ; COORDS
11770 24E2 78                   LD      A,B             ;
11771 24E3 84                   ADD     A,H             ;
11772 24E4 47                   LD      B,A             ;
11773 24E5 79                   LD      A,C             ;
11774 24E6 3C                   INC     A               ;
11775 24E7 85                   ADD     A,L             ;
11776 24E8 38 0D                JR      C,L24F7         ; to D-L-RANGE
11777 24EA
11778 24EA 28 0D                JR      Z,L24F9         ; to REPORT-Bc
11779 24EC
11780 24EC              ;; D-L-PLOT
11781 24EC 3D           L24EC:  DEC     A               ;
11782 24ED 4F                   LD      C,A             ;
11783 24EE CD E5 22             CALL    L22E5           ; routine PLOT-SUB
11784 24F1 D9                   EXX                     ;
11785 24F2 79                   LD      A,C             ;
11786 24F3 10 D9                DJNZ    L24CE           ; to D-L-LOOP
11787 24F5
11788 24F5 D1                   POP     DE              ;
11789 24F6 C9                   RET                     ;
11790 24F7
11791 24F7              ; ---
11792 24F7
11793 24F7              ;; D-L-RANGE
11794 24F7 28 F3        L24F7:  JR      Z,L24EC         ; to D-L-PLOT
11795 24F9
11796 24F9
11797 24F9              ;; REPORT-Bc
11798 24F9 CF           L24F9:  RST     08H             ; ERROR-1
11799 24FA 0A                   DEFB    $0A             ; Error Report: Integer out of range
11800 24FB
11801 24FB
11802 24FB
11803 24FB              ;***********************************
11804 24FB              ;** Part 8. EXPRESSION EVALUATION **
11805 24FB              ;***********************************
11806 24FB              ;
11807 24FB              ; It is a this stage of the ROM that the Spectrum ceases altogether to be
11808 24FB              ; just a colourful novelty. One remarkable feature is that in all previous
11809 24FB              ; commands when the Spectrum is expecting a number or a string then an
11810 24FB              ; expression of the same type can be substituted ad infinitum.
11811 24FB              ; This is the routine that evaluates that expression.
11812 24FB              ; This is what causes 2 + 2 to give the answer 4.
11813 24FB              ; That is quite easy to understand. However you don't have to make it much
11814 24FB              ; more complex to start a remarkable juggling act.
11815 24FB              ; e.g. PRINT 2 * (VAL "2+2" + TAN 3)
11816 24FB              ; In fact, provided there is enough free RAM, the Spectrum can evaluate
11817 24FB              ; an expression of unlimited complexity.
11818 24FB              ; Apart from a couple of minor glitches, which you can now correct, the
11819 24FB              ; system is remarkably robust.
11820 24FB
11821 24FB
11822 24FB              ; ---------------------------------
11823 24FB              ; Scan expression or sub-expression
11824 24FB              ; ---------------------------------
11825 24FB              ;
11826 24FB              ;
11827 24FB
11828 24FB              ;; SCANNING
11829 24FB DF           L24FB:  RST     18H             ; GET-CHAR
11830 24FC 06 00                LD      B,$00           ; priority marker zero is pushed on stack
11831 24FE                                              ; to signify end of expression when it is
11832 24FE                                              ; popped off again.
11833 24FE C5                   PUSH    BC              ; put in on stack.
11834 24FF                                              ; and proceed to consider the first character
11835 24FF                                              ; of the expression.
11836 24FF
11837 24FF              ;; S-LOOP-1
11838 24FF 4F           L24FF:  LD      C,A             ; store the character while a look up is done.
11839 2500 21 96 25             LD      HL,L2596        ; Address: scan-func
11840 2503 CD DC 16             CALL    L16DC           ; routine INDEXER is called to see if it is
11841 2506                                              ; part of a limited range '+', '(', 'ATTR' etc.
11842 2506
11843 2506 79                   LD      A,C             ; fetch the character back
11844 2507 D2 84 26             JP      NC,L2684        ; jump forward to S-ALPHNUM if not in primary
11845 250A                                              ; operators and functions to consider in the
11846 250A                                              ; first instance a digit or a variable and
11847 250A                                              ; then anything else.                >>>
11848 250A
11849 250A 06 00                LD      B,$00           ; but here if it was found in table so
11850 250C 4E                   LD      C,(HL)          ; fetch offset from table and make B zero.
11851 250D 09                   ADD     HL,BC           ; add the offset to position found
11852 250E E9                   JP      (HL)            ; and jump to the routine e.g. S-BIN
11853 250F                                              ; making an indirect exit from there.
11854 250F
11855 250F              ; -------------------------------------------------------------------------
11856 250F              ; The four service subroutines for routines in the scanning function table
11857 250F              ; -------------------------------------------------------------------------
11858 250F
11859 250F              ; PRINT """Hooray!"" he cried."
11860 250F
11861 250F              ;; S-QUOTE-S
11862 250F CD 74 00     L250F:  CALL    L0074           ; routine CH-ADD+1 points to next character
11863 2512                                              ; and fetches that character.
11864 2512 03                   INC     BC              ; increase length counter.
11865 2513 FE 0D                CP      $0D             ; is it carriage return ?
11866 2515                                              ; inside a quote.
11867 2515 CA 8A 1C             JP      Z,L1C8A         ; jump back to REPORT-C if so.
11868 2518                                              ; 'Nonsense in BASIC'.
11869 2518
11870 2518 FE 22                CP      $22             ; is it a quote '"' ?
11871 251A 20 F3                JR      NZ,L250F        ; back to S-QUOTE-S if not for more.
11872 251C
11873 251C CD 74 00             CALL    L0074           ; routine CH-ADD+1
11874 251F FE 22                CP      $22             ; compare with possible adjacent quote
11875 2521 C9                   RET                     ; return. with zero set if two together.
11876 2522
11877 2522              ; ---
11878 2522
11879 2522              ; This subroutine is used to get two coordinate expressions for the three
11880 2522              ; functions SCREEN$, ATTR and POINT that have two fixed parameters and
11881 2522              ; therefore require surrounding braces.
11882 2522
11883 2522              ;; S-2-COORD
11884 2522 E7           L2522:  RST     20H             ; NEXT-CHAR
11885 2523 FE 28                CP      $28             ; is it the opening '(' ?
11886 2525 20 06                JR      NZ,L252D        ; forward to S-RPORT-C if not
11887 2527                                              ; 'Nonsense in BASIC'.
11888 2527
11889 2527 CD 79 1C             CALL    L1C79           ; routine NEXT-2NUM gets two comma-separated
11890 252A                                              ; numeric expressions. Note. this could cause
11891 252A                                              ; many more recursive calls to SCANNING but
11892 252A                                              ; the parent function will be evaluated fully
11893 252A                                              ; before rejoining the main juggling act.
11894 252A
11895 252A DF                   RST     18H             ; GET-CHAR
11896 252B FE 29                CP      $29             ; is it the closing ')' ?
11897 252D
11898 252D              ;; S-RPORT-C
11899 252D C2 8A 1C     L252D:  JP      NZ,L1C8A        ; jump back to REPORT-C if not.
11900 2530                                              ; 'Nonsense in BASIC'.
11901 2530
11902 2530              ; ------------
11903 2530              ; Check syntax
11904 2530              ; ------------
11905 2530              ; This routine is called on a number of occasions to check if syntax is being
11906 2530              ; checked or if the program is being run. To test the flag inline would use
11907 2530              ; four bytes of code, but a call instruction only uses 3 bytes of code.
11908 2530
11909 2530              ;; SYNTAX-Z
11910 2530 FD CB 01 7E  L2530:  BIT     7,(IY+$01)      ; test FLAGS  - checking syntax only ?
11911 2534 C9                   RET                     ; return.
11912 2535
11913 2535              ; ----------------
11914 2535              ; Scanning SCREEN$
11915 2535              ; ----------------
11916 2535              ; This function returns the code of a bit-mapped character at screen
11917 2535              ; position at line C, column B. It is unable to detect the mosaic characters
11918 2535              ; which are not bit-mapped but detects the ASCII 32 - 127 range.
11919 2535              ; The bit-mapped UDGs are ignored which is curious as it requires only a
11920 2535              ; few extra bytes of code. As usual, anything to do with CHARS is weird.
11921 2535              ; If no match is found a null string is returned.
11922 2535              ; No actual check on ranges is performed - that's up to the BASIC programmer.
11923 2535              ; No real harm can come from SCREEN$(255,255) although the BASIC manual
11924 2535              ; says that invalid values will be trapped.
11925 2535              ; Interestingly, in the Pitman pocket guide, 1984, Vickers says that the
11926 2535              ; range checking will be performed.
11927 2535
11928 2535              ;; S-SCRN$-S
11929 2535 CD 07 23     L2535:  CALL    L2307           ; routine STK-TO-BC.
11930 2538 2A 36 5C             LD      HL,($5C36)      ; fetch address of CHARS.
11931 253B 11 00 01             LD      DE,$0100        ; fetch offset to chr$ 32
11932 253E 19                   ADD     HL,DE           ; and find start of bitmaps.
11933 253F                                              ; Note. not inc h. ??
11934 253F 79                   LD      A,C             ; transfer line to A.
11935 2540 0F                   RRCA                    ; multiply
11936 2541 0F                   RRCA                    ; by
11937 2542 0F                   RRCA                    ; thirty-two.
11938 2543 E6 E0                AND     $E0             ; and with 11100000
11939 2545 A8                   XOR     B               ; combine with column $00 - $1F
11940 2546 5F                   LD      E,A             ; to give the low byte of top line
11941 2547 79                   LD      A,C             ; column to A range 00000000 to 00011111
11942 2548 E6 18                AND     $18             ; and with 00011000
11943 254A EE 40                XOR     $40             ; xor with 01000000 (high byte screen start)
11944 254C 57                   LD      D,A             ; register DE now holds start address of cell.
11945 254D 06 60                LD      B,$60           ; there are 96 characters in ASCII set.
11946 254F
11947 254F              ;; S-SCRN-LP
11948 254F C5           L254F:  PUSH    BC              ; save count
11949 2550 D5                   PUSH    DE              ; save screen start address
11950 2551 E5                   PUSH    HL              ; save bitmap start
11951 2552 1A                   LD      A,(DE)          ; first byte of screen to A
11952 2553 AE                   XOR     (HL)            ; xor with corresponding character byte
11953 2554 28 04                JR      Z,L255A         ; forward to S-SC-MTCH if they match
11954 2556                                              ; if inverse result would be $FF
11955 2556                                              ; if any other then mismatch
11956 2556
11957 2556 3C                   INC     A               ; set to $00 if inverse
11958 2557 20 1A                JR      NZ,L2573        ; forward to S-SCR-NXT if a mismatch
11959 2559
11960 2559 3D                   DEC     A               ; restore $FF
11961 255A
11962 255A              ; a match has been found so seven more to test.
11963 255A
11964 255A              ;; S-SC-MTCH
11965 255A 4F           L255A:  LD      C,A             ; load C with inverse mask $00 or $FF
11966 255B 06 07                LD      B,$07           ; count seven more bytes
11967 255D
11968 255D              ;; S-SC-ROWS
11969 255D 14           L255D:  INC     D               ; increment screen address.
11970 255E 23                   INC     HL              ; increment bitmap address.
11971 255F 1A                   LD      A,(DE)          ; byte to A
11972 2560 AE                   XOR     (HL)            ; will give $00 or $FF (inverse)
11973 2561 A9                   XOR     C               ; xor with inverse mask
11974 2562 20 0F                JR      NZ,L2573        ; forward to S-SCR-NXT if no match.
11975 2564
11976 2564 10 F7                DJNZ    L255D           ; back to S-SC-ROWS until all eight matched.
11977 2566
11978 2566              ; continue if a match of all eight bytes was found
11979 2566
11980 2566 C1                   POP     BC              ; discard the
11981 2567 C1                   POP     BC              ; saved
11982 2568 C1                   POP     BC              ; pointers
11983 2569 3E 80                LD      A,$80           ; the endpoint of character set
11984 256B 90                   SUB     B               ; subtract the counter
11985 256C                                              ; to give the code 32-127
11986 256C 01 01 00             LD      BC,$0001        ; make one space in workspace.
11987 256F
11988 256F F7                   RST     30H             ; BC-SPACES creates the space sliding
11989 2570                                              ; the calculator stack upwards.
11990 2570 12                   LD      (DE),A          ; start is addressed by DE, so insert code
11991 2571 18 0A                JR      L257D           ; forward to S-SCR-STO
11992 2573
11993 2573              ; ---
11994 2573
11995 2573              ; the jump was here if no match and more bitmaps to test.
11996 2573
11997 2573              ;; S-SCR-NXT
11998 2573 E1           L2573:  POP     HL              ; restore the last bitmap start
11999 2574 11 08 00             LD      DE,$0008        ; and prepare to add 8.
12000 2577 19                   ADD     HL,DE           ; now addresses next character bitmap.
12001 2578 D1                   POP     DE              ; restore screen address
12002 2579 C1                   POP     BC              ; and character counter in B
12003 257A 10 D3                DJNZ    L254F           ; back to S-SCRN-LP if more characters.
12004 257C
12005 257C 48                   LD      C,B             ; B is now zero, so BC now zero.
12006 257D
12007 257D              ;; S-SCR-STO
12008 257D C3 B2 2A     L257D:  JP      L2AB2           ; to STK-STO-$ to store the string in
12009 2580                                              ; workspace or a string with zero length.
12010 2580                                              ; (value of DE doesn't matter in last case)
12011 2580
12012 2580              ; Note. this exit seems correct but the general-purpose routine S-STRING
12013 2580              ; that calls this one will also stack any of its string results so this
12014 2580              ; leads to a double storing of the result in this case.
12015 2580              ; The instruction at L257D should just be a RET.
12016 2580              ; credit Stephen Kelly and others, 1982.
12017 2580
12018 2580              ; -------------
12019 2580              ; Scanning ATTR
12020 2580              ; -------------
12021 2580              ; This function subroutine returns the attributes of a screen location -
12022 2580              ; a numeric result.
12023 2580              ; Again it's up to the BASIC programmer to supply valid values of line/column.
12024 2580
12025 2580              ;; S-ATTR-S
12026 2580 CD 07 23     L2580:  CALL    L2307           ; routine STK-TO-BC fetches line to C,
12027 2583                                              ; and column to B.
12028 2583 79                   LD      A,C             ; line to A $00 - $17   (max 00010111)
12029 2584 0F                   RRCA                    ; rotate
12030 2585 0F                   RRCA                    ; bits
12031 2586 0F                   RRCA                    ; left.
12032 2587 4F                   LD      C,A             ; store in C as an intermediate value.
12033 2588
12034 2588 E6 E0                AND     $E0             ; pick up bits 11100000 ( was 00011100 )
12035 258A A8                   XOR     B               ; combine with column $00 - $1F
12036 258B 6F                   LD      L,A             ; low byte now correct.
12037 258C
12038 258C 79                   LD      A,C             ; bring back intermediate result from C
12039 258D E6 03                AND     $03             ; mask to give correct third of
12040 258F                                              ; screen $00 - $02
12041 258F EE 58                XOR     $58             ; combine with base address.
12042 2591 67                   LD      H,A             ; high byte correct.
12043 2592 7E                   LD      A,(HL)          ; pick up the colour attribute.
12044 2593 C3 28 2D             JP      L2D28           ; forward to STACK-A to store result
12045 2596                                              ; and make an indirect exit.
12046 2596
12047 2596              ; -----------------------
12048 2596              ; Scanning function table
12049 2596              ; -----------------------
12050 2596              ; This table is used by INDEXER routine to find the offsets to
12051 2596              ; four operators and eight functions. e.g. $A8 is the token 'FN'.
12052 2596              ; This table is used in the first instance for the first character of an
12053 2596              ; expression or by a recursive call to SCANNING for the first character of
12054 2596              ; any sub-expression. It eliminates functions that have no argument or
12055 2596              ; functions that can have more than one argument and therefore require
12056 2596              ; braces. By eliminating and dealing with these now it can later take a
12057 2596              ; simplistic approach to all other functions and assume that they have
12058 2596              ; one argument.
12059 2596              ; Similarly by eliminating BIN and '.' now it is later able to assume that
12060 2596              ; all numbers begin with a digit and that the presence of a number or
12061 2596              ; variable can be detected by a call to ALPHANUM.
12062 2596              ; By default all expressions are positive and the spurious '+' is eliminated
12063 2596              ; now as in print +2. This should not be confused with the operator '+'.
12064 2596              ; Note. this does allow a degree of nonsense to be accepted as in
12065 2596              ; PRINT +"3 is the greatest.".
12066 2596              ; An acquired programming skill is the ability to include brackets where
12067 2596              ; they are not necessary.
12068 2596              ; A bracket at the start of a sub-expression may be spurious or necessary
12069 2596              ; to denote that the contained expression is to be evaluated as an entity.
12070 2596              ; In either case this is dealt with by recursive calls to SCANNING.
12071 2596              ; An expression that begins with a quote requires special treatment.
12072 2596
12073 2596              ;; scan-func
12074 2596 22 1C        L2596:  DEFB    $22, L25B3-$-1  ; $1C offset to S-QUOTE
12075 2598 28 4F                DEFB    '(', L25E8-$-1  ; $4F offset to S-BRACKET
12076 259A 2E F2                DEFB    '.', L268D-$-1  ; $F2 offset to S-DECIMAL
12077 259C 2B 12                DEFB    '+', L25AF-$-1  ; $12 offset to S-U-PLUS
12078 259E
12079 259E A8 56                DEFB    $A8, L25F5-$-1  ; $56 offset to S-FN
12080 25A0 A5 57                DEFB    $A5, L25F8-$-1  ; $57 offset to S-RND
12081 25A2 A7 84                DEFB    $A7, L2627-$-1  ; $84 offset to S-PI
12082 25A4 A6 8F                DEFB    $A6, L2634-$-1  ; $8F offset to S-INKEY$
12083 25A6 C4 E6                DEFB    $C4, L268D-$-1  ; $E6 offset to S-BIN
12084 25A8 AA BF                DEFB    $AA, L2668-$-1  ; $BF offset to S-SCREEN$
12085 25AA AB C7                DEFB    $AB, L2672-$-1  ; $C7 offset to S-ATTR
12086 25AC A9 CE                DEFB    $A9, L267B-$-1  ; $CE offset to S-POINT
12087 25AE
12088 25AE 00                   DEFB    $00             ; zero end marker
12089 25AF
12090 25AF              ; --------------------------
12091 25AF              ; Scanning function routines
12092 25AF              ; --------------------------
12093 25AF              ; These are the 11 subroutines accessed by the above table.
12094 25AF              ; S-BIN and S-DECIMAL are the same
12095 25AF              ; The 1-byte offset limits their location to within 255 bytes of their
12096 25AF              ; entry in the table.
12097 25AF
12098 25AF              ; ->
12099 25AF              ;; S-U-PLUS
12100 25AF E7           L25AF:  RST     20H             ; NEXT-CHAR just ignore
12101 25B0 C3 FF 24             JP      L24FF           ; to S-LOOP-1
12102 25B3
12103 25B3              ; ---
12104 25B3
12105 25B3              ; ->
12106 25B3              ;; S-QUOTE
12107 25B3 DF           L25B3:  RST     18H             ; GET-CHAR
12108 25B4 23                   INC     HL              ; address next character (first in quotes)
12109 25B5 E5                   PUSH    HL              ; save start of quoted text.
12110 25B6 01 00 00             LD      BC,$0000        ; initialize length of string to zero.
12111 25B9 CD 0F 25             CALL    L250F           ; routine S-QUOTE-S
12112 25BC 20 1B                JR      NZ,L25D9        ; forward to S-Q-PRMS if
12113 25BE
12114 25BE              ;; S-Q-AGAIN
12115 25BE CD 0F 25     L25BE:  CALL    L250F           ; routine S-QUOTE-S copies string until a
12116 25C1                                              ; quote is encountered
12117 25C1 28 FB                JR      Z,L25BE         ; back to S-Q-AGAIN if two quotes WERE
12118 25C3                                              ; together.
12119 25C3
12120 25C3              ; but if just an isolated quote then that terminates the string.
12121 25C3
12122 25C3 CD 30 25             CALL    L2530           ; routine SYNTAX-Z
12123 25C6 28 11                JR      Z,L25D9         ; forward to S-Q-PRMS if checking syntax.
12124 25C8
12125 25C8
12126 25C8 F7                   RST     30H             ; BC-SPACES creates the space for true
12127 25C9                                              ; copy of string in workspace.
12128 25C9 E1                   POP     HL              ; re-fetch start of quoted text.
12129 25CA D5                   PUSH    DE              ; save start in workspace.
12130 25CB
12131 25CB              ;; S-Q-COPY
12132 25CB 7E           L25CB:  LD      A,(HL)          ; fetch a character from source.
12133 25CC 23                   INC     HL              ; advance source address.
12134 25CD 12                   LD      (DE),A          ; place in destination.
12135 25CE 13                   INC     DE              ; advance destination address.
12136 25CF FE 22                CP      $22             ; was it a '"' just copied ?
12137 25D1 20 F8                JR      NZ,L25CB        ; back to S-Q-COPY to copy more if not
12138 25D3
12139 25D3 7E                   LD      A,(HL)          ; fetch adjacent character from source.
12140 25D4 23                   INC     HL              ; advance source address.
12141 25D5 FE 22                CP      $22             ; is this '"' ? - i.e. two quotes together ?
12142 25D7 28 F2                JR      Z,L25CB         ; to S-Q-COPY if so including just one of the
12143 25D9                                              ; pair of quotes.
12144 25D9
12145 25D9              ; proceed when terminating quote encountered.
12146 25D9
12147 25D9              ;; S-Q-PRMS
12148 25D9 0B           L25D9:  DEC     BC              ; decrease count by 1.
12149 25DA D1                   POP     DE              ; restore start of string in workspace.
12150 25DB
12151 25DB              ;; S-STRING
12152 25DB 21 3B 5C     L25DB:  LD      HL,$5C3B        ; Address FLAGS system variable.
12153 25DE CB B6                RES     6,(HL)          ; signal string result.
12154 25E0 CB 7E                BIT     7,(HL)          ; is syntax being checked.
12155 25E2 C4 B2 2A             CALL    NZ,L2AB2        ; routine STK-STO-$ is called in runtime.
12156 25E5 C3 12 27             JP      L2712           ; jump forward to S-CONT-2          ===>
12157 25E8
12158 25E8              ; ---
12159 25E8
12160 25E8              ; ->
12161 25E8              ;; S-BRACKET
12162 25E8 E7           L25E8:  RST     20H             ; NEXT-CHAR
12163 25E9 CD FB 24             CALL    L24FB           ; routine SCANNING is called recursively.
12164 25EC FE 29                CP      $29             ; is it the closing ')' ?
12165 25EE C2 8A 1C             JP      NZ,L1C8A        ; jump back to REPORT-C if not
12166 25F1                                              ; 'Nonsense in BASIC'
12167 25F1
12168 25F1 E7                   RST     20H             ; NEXT-CHAR
12169 25F2 C3 12 27             JP      L2712           ; jump forward to S-CONT-2          ===>
12170 25F5
12171 25F5              ; ---
12172 25F5
12173 25F5              ; ->
12174 25F5              ;; S-FN
12175 25F5 C3 BD 27     L25F5:  JP      L27BD           ; jump forward to S-FN-SBRN.
12176 25F8
12177 25F8              ; --------------------------------------------------------------------
12178 25F8              ;
12179 25F8              ;   RANDOM THEORY from the ZX81 manual by Steven Vickers
12180 25F8              ;
12181 25F8              ;   (same algorithm as the ZX Spectrum).
12182 25F8              ;
12183 25F8              ;   Chapter 5. Exercise 6. (For mathematicians only.)
12184 25F8              ;
12185 25F8              ;   Let p be a [large] prime, & let a be a primitive root modulo p.
12186 25F8              ;   Then if b_i is the residue of a^i modulo p (1<=b_i<p-1), the
12187 25F8              ;   sequence
12188 25F8              ;
12189 25F8              ;                           (b_i-1)/(p-1)
12190 25F8              ;
12191 25F8              ;   is a cyclical sequence of p-1 distinct numbers in the range 0 to 1
12192 25F8              ;   (excluding 1). By choosing a suitably, these can be made to look
12193 25F8              ;   fairly random.
12194 25F8              ;
12195 25F8              ;     65537 is a Mersenne prime 2^16-1. Note.
12196 25F8              ;
12197 25F8              ;   Use this, & Gauss' law of quadratic reciprocity, to show that 75
12198 25F8              ;   is a primitive root modulo 65537.
12199 25F8              ;
12200 25F8              ;     The ZX81 uses p=65537 & a=75, & stores some b_i-1 in memory.
12201 25F8              ;   The function RND involves replacing b_i-1 in memory by b_(i+1)-1,
12202 25F8              ;   & yielding the result (b_(i+1)-1)/(p-1). RAND n (with 1<=n<=65535)
12203 25F8              ;   makes b_i equal to n+1.
12204 25F8              ;
12205 25F8              ; --------------------------------------------------------------------
12206 25F8              ;
12207 25F8              ; Steven Vickers writing in comp.sys.sinclair on 20-DEC-1993
12208 25F8              ;
12209 25F8              ;   Note. (Of course, 65537 is 2^16 + 1, not -1.)
12210 25F8              ;
12211 25F8              ;   Consider arithmetic modulo a prime p. There are p residue classes, and the
12212 25F8              ;   non-zero ones are all invertible. Hence under multiplication they form a
12213 25F8              ;   group (Fp*, say) of order p-1; moreover (and not so obvious) Fp* is cyclic.
12214 25F8              ;   Its generators are the "primitive roots". The "quadratic residues modulo p"
12215 25F8              ;   are the squares in Fp*, and the "Legendre symbol" (d/p) is defined (when p
12216 25F8              ;   does not divide d) as +1 or -1, according as d is or is not a quadratic
12217 25F8              ;   residue mod p.
12218 25F8              ;
12219 25F8              ;   In the case when p = 65537, we can show that d is a primitive root if and
12220 25F8              ;   only if it's not a quadratic residue. For let w be a primitive root, d
12221 25F8              ;   congruent to w^r (mod p). If d is not primitive, then its order is a proper
12222 25F8              ;   factor of 65536: hence w^{32768*r} = 1 (mod p), so 65536 divides 32768*r,
12223 25F8              ;   and hence r is even and d is a square (mod p). Conversely, the squares in
12224 25F8              ;   Fp* form a subgroup of (Fp*)^2 of index 2, and so cannot be generators.
12225 25F8              ;
12226 25F8              ;   Hence to check whether 75 is primitive mod 65537, we want to calculate that
12227 25F8              ;   (75/65537) = -1. There is a multiplicative formula (ab/p) = (a/p)(b/p) (mod
12228 25F8              ;   p), so (75/65537) = (5/65537)^2 * (3/65537) = (3/65537). Now the law of
12229 25F8              ;   quadratic reciprocity says that if p and q are distinct odd primes, then
12230 25F8              ;
12231 25F8              ;    (p/q)(q/p) = (-1)^{(p-1)(q-1)/4}
12232 25F8              ;
12233 25F8              ;   Hence (3/65537) = (65537/3) * (-1)^{65536*2/4} = (65537/3)
12234 25F8              ;            = (2/3)  (because 65537 = 2 mod 3)
12235 25F8              ;            = -1
12236 25F8              ;
12237 25F8              ;   (I referred to Pierre Samuel's "Algebraic Theory of Numbers".)
12238 25F8              ;
12239 25F8              ; ->
12240 25F8
12241 25F8              ;; S-RND
12242 25F8 CD 30 25     L25F8:  CALL    L2530           ; routine SYNTAX-Z
12243 25FB 28 28                JR      Z,L2625         ; forward to S-RND-END if checking syntax.
12244 25FD
12245 25FD ED 4B 76 5C          LD      BC,($5C76)      ; fetch system variable SEED
12246 2601 CD 2B 2D             CALL    L2D2B           ; routine STACK-BC places on calculator stack
12247 2604
12248 2604 EF                   RST     28H             ;; FP-CALC           ;s.
12249 2605 A1                   DEFB    $A1             ;;stk-one            ;s,1.
12250 2606 0F                   DEFB    $0F             ;;addition           ;s+1.
12251 2607 34                   DEFB    $34             ;;stk-data           ;
12252 2608 37                   DEFB    $37             ;;Exponent: $87,
12253 2609                                              ;;Bytes: 1
12254 2609 16                   DEFB    $16             ;;(+00,+00,+00)      ;s+1,75.
12255 260A 04                   DEFB    $04             ;;multiply           ;(s+1)*75 = v
12256 260B 34                   DEFB    $34             ;;stk-data           ;v.
12257 260C 80                   DEFB    $80             ;;Bytes: 3
12258 260D 41                   DEFB    $41             ;;Exponent $91
12259 260E 00 00 80             DEFB    $00,$00,$80     ;;(+00)              ;v,65537.
12260 2611 32                   DEFB    $32             ;;n-mod-m            ;remainder, result.
12261 2612 02                   DEFB    $02             ;;delete             ;remainder.
12262 2613 A1                   DEFB    $A1             ;;stk-one            ;remainder, 1.
12263 2614 03                   DEFB    $03             ;;subtract           ;remainder - 1. = rnd
12264 2615 31                   DEFB    $31             ;;duplicate          ;rnd,rnd.
12265 2616 38                   DEFB    $38             ;;end-calc
12266 2617
12267 2617 CD A2 2D             CALL    L2DA2           ; routine FP-TO-BC
12268 261A ED 43 76 5C          LD      ($5C76),BC      ; store in SEED for next starting point.
12269 261E 7E                   LD      A,(HL)          ; fetch exponent
12270 261F A7                   AND     A               ; is it zero ?
12271 2620 28 03                JR      Z,L2625         ; forward if so to S-RND-END
12272 2622
12273 2622 D6 10                SUB     $10             ; reduce exponent by 2^16
12274 2624 77                   LD      (HL),A          ; place back
12275 2625
12276 2625              ;; S-RND-END
12277 2625 18 09        L2625:  JR      L2630           ; forward to S-PI-END
12278 2627
12279 2627              ; ---
12280 2627
12281 2627              ; the number PI 3.14159...
12282 2627
12283 2627              ; ->
12284 2627              ;; S-PI
12285 2627 CD 30 25     L2627:  CALL    L2530           ; routine SYNTAX-Z
12286 262A 28 04                JR      Z,L2630         ; to S-PI-END if checking syntax.
12287 262C
12288 262C EF                   RST     28H             ;; FP-CALC
12289 262D A3                   DEFB    $A3             ;;stk-pi/2                          pi/2.
12290 262E 38                   DEFB    $38             ;;end-calc
12291 262F
12292 262F 34                   INC     (HL)            ; increment the exponent leaving pi
12293 2630                                              ; on the calculator stack.
12294 2630
12295 2630              ;; S-PI-END
12296 2630 E7           L2630:  RST     20H             ; NEXT-CHAR
12297 2631 C3 C3 26             JP      L26C3           ; jump forward to S-NUMERIC
12298 2634
12299 2634              ; ---
12300 2634
12301 2634              ; ->
12302 2634              ;; S-INKEY$
12303 2634 01 5A 10     L2634:  LD      BC,$105A        ; priority $10, operation code $1A ('read-in')
12304 2637                                              ; +$40 for string result, numeric operand.
12305 2637                                              ; set this up now in case we need to use the
12306 2637                                              ; calculator.
12307 2637 E7                   RST     20H             ; NEXT-CHAR
12308 2638 FE 23                CP      $23             ; '#' ?
12309 263A CA 0D 27             JP      Z,L270D         ; to S-PUSH-PO if so to use the calculator
12310 263D                                              ; single operation
12311 263D                                              ; to read from network/RS232 etc. .
12312 263D
12313 263D              ; else read a key from the keyboard.
12314 263D
12315 263D 21 3B 5C             LD      HL,$5C3B        ; fetch FLAGS
12316 2640 CB B6                RES     6,(HL)          ; signal string result.
12317 2642 CB 7E                BIT     7,(HL)          ; checking syntax ?
12318 2644 28 1F                JR      Z,L2665         ; forward to S-INK$-EN if so
12319 2646
12320 2646 CD 8E 02             CALL    L028E           ; routine KEY-SCAN key in E, shift in D.
12321 2649 0E 00                LD      C,$00           ; the length of an empty string
12322 264B 20 13                JR      NZ,L2660        ; to S-IK$-STK to store empty string if
12323 264D                                              ; no key returned.
12324 264D
12325 264D CD 1E 03             CALL    L031E           ; routine K-TEST get main code in A
12326 2650 30 0E                JR      NC,L2660        ; to S-IK$-STK to stack null string if
12327 2652                                              ; invalid
12328 2652
12329 2652 15                   DEC     D               ; D is expected to be FLAGS so set bit 3 $FF
12330 2653                                              ; 'L' Mode so no keywords.
12331 2653 5F                   LD      E,A             ; main key to A
12332 2654                                              ; C is MODE 0 'KLC' from above still.
12333 2654 CD 33 03             CALL    L0333           ; routine K-DECODE
12334 2657 F5                   PUSH    AF              ; save the code
12335 2658 01 01 00             LD      BC,$0001        ; make room for one character
12336 265B
12337 265B F7                   RST     30H             ; BC-SPACES
12338 265C F1                   POP     AF              ; bring the code back
12339 265D 12                   LD      (DE),A          ; put the key in workspace
12340 265E 0E 01                LD      C,$01           ; set C length to one
12341 2660
12342 2660              ;; S-IK$-STK
12343 2660 06 00        L2660:  LD      B,$00           ; set high byte of length to zero
12344 2662 CD B2 2A             CALL    L2AB2           ; routine STK-STO-$
12345 2665
12346 2665              ;; S-INK$-EN
12347 2665 C3 12 27     L2665:  JP      L2712           ; to S-CONT-2            ===>
12348 2668
12349 2668              ; ---
12350 2668
12351 2668              ; ->
12352 2668              ;; S-SCREEN$
12353 2668 CD 22 25     L2668:  CALL    L2522           ; routine S-2-COORD
12354 266B C4 35 25             CALL    NZ,L2535        ; routine S-SCRN$-S
12355 266E
12356 266E E7                   RST     20H             ; NEXT-CHAR
12357 266F C3 DB 25             JP      L25DB           ; forward to S-STRING to stack result
12358 2672
12359 2672              ; ---
12360 2672
12361 2672              ; ->
12362 2672              ;; S-ATTR
12363 2672 CD 22 25     L2672:  CALL    L2522           ; routine S-2-COORD
12364 2675 C4 80 25             CALL    NZ,L2580        ; routine S-ATTR-S
12365 2678
12366 2678 E7                   RST     20H             ; NEXT-CHAR
12367 2679 18 48                JR      L26C3           ; forward to S-NUMERIC
12368 267B
12369 267B              ; ---
12370 267B
12371 267B              ; ->
12372 267B              ;; S-POINT
12373 267B CD 22 25     L267B:  CALL    L2522           ; routine S-2-COORD
12374 267E C4 CB 22             CALL    NZ,L22CB        ; routine POINT-SUB
12375 2681
12376 2681 E7                   RST     20H             ; NEXT-CHAR
12377 2682 18 3F                JR      L26C3           ; forward to S-NUMERIC
12378 2684
12379 2684              ; -----------------------------
12380 2684
12381 2684              ; ==> The branch was here if not in table.
12382 2684
12383 2684              ;; S-ALPHNUM
12384 2684 CD 88 2C     L2684:  CALL    L2C88           ; routine ALPHANUM checks if variable or
12385 2687                                              ; a digit.
12386 2687 30 56                JR      NC,L26DF        ; forward to S-NEGATE if not to consider
12387 2689                                              ; a '-' character then functions.
12388 2689
12389 2689 FE 41                CP      $41             ; compare 'A'
12390 268B 30 3C                JR      NC,L26C9        ; forward to S-LETTER if alpha       ->
12391 268D                                              ; else must have been numeric so continue
12392 268D                                              ; into that routine.
12393 268D
12394 268D              ; This important routine is called during runtime and from LINE-SCAN
12395 268D              ; when a BASIC line is checked for syntax. It is this routine that
12396 268D              ; inserts, during syntax checking, the invisible floating point numbers
12397 268D              ; after the numeric expression. During runtime it just picks these
12398 268D              ; numbers up. It also handles BIN format numbers.
12399 268D
12400 268D              ; ->
12401 268D              ;; S-BIN
12402 268D              ;; S-DECIMAL
12403 268D CD 30 25     L268D:  CALL    L2530           ; routine SYNTAX-Z
12404 2690 20 23                JR      NZ,L26B5        ; to S-STK-DEC in runtime
12405 2692
12406 2692              ; this route is taken when checking syntax.
12407 2692
12408 2692 CD 9B 2C             CALL    L2C9B           ; routine DEC-TO-FP to evaluate number
12409 2695
12410 2695 DF                   RST     18H             ; GET-CHAR to fetch HL
12411 2696 01 06 00             LD      BC,$0006        ; six locations required
12412 2699 CD 55 16             CALL    L1655           ; routine MAKE-ROOM
12413 269C 23                   INC     HL              ; to first new location
12414 269D 36 0E                LD      (HL),$0E        ; insert number marker
12415 269F 23                   INC     HL              ; address next
12416 26A0 EB                   EX      DE,HL           ; make DE destination.
12417 26A1 2A 65 5C             LD      HL,($5C65)      ; STKEND points to end of stack.
12418 26A4 0E 05                LD      C,$05           ; result is five locations lower
12419 26A6 A7                   AND     A               ; prepare for true subtraction
12420 26A7 ED 42                SBC     HL,BC           ; point to start of value.
12421 26A9 22 65 5C             LD      ($5C65),HL      ; update STKEND as we are taking number.
12422 26AC ED B0                LDIR                    ; Copy five bytes to program location
12423 26AE EB                   EX      DE,HL           ; transfer pointer to HL
12424 26AF 2B                   DEC     HL              ; adjust
12425 26B0 CD 77 00             CALL    L0077           ; routine TEMP-PTR1 sets CH-ADD
12426 26B3 18 0E                JR      L26C3           ; to S-NUMERIC to record nature of result
12427 26B5
12428 26B5              ; ---
12429 26B5
12430 26B5              ; branch here in runtime.
12431 26B5
12432 26B5              ;; S-STK-DEC
12433 26B5 DF           L26B5:  RST     18H             ; GET-CHAR positions HL at digit.
12434 26B6
12435 26B6              ;; S-SD-SKIP
12436 26B6 23           L26B6:  INC     HL              ; advance pointer
12437 26B7 7E                   LD      A,(HL)          ; until we find
12438 26B8 FE 0E                CP      $0E             ; chr 14d - the number indicator
12439 26BA 20 FA                JR      NZ,L26B6        ; to S-SD-SKIP until a match
12440 26BC                                              ; it has to be here.
12441 26BC
12442 26BC 23                   INC     HL              ; point to first byte of number
12443 26BD CD B4 33             CALL    L33B4           ; routine STACK-NUM stacks it
12444 26C0 22 5D 5C             LD      ($5C5D),HL      ; update system variable CH_ADD
12445 26C3
12446 26C3              ;; S-NUMERIC
12447 26C3 FD CB 01 F6  L26C3:  SET     6,(IY+$01)      ; update FLAGS  - Signal numeric result
12448 26C7 18 14                JR      L26DD           ; forward to S-CONT-1               ===>
12449 26C9                                              ; actually S-CONT-2 is destination but why
12450 26C9                                              ; waste a byte on a jump when a JR will do.
12451 26C9                                              ; Actually a JR L2712 can be used. Rats.
12452 26C9
12453 26C9              ; end of functions accessed from scanning functions table.
12454 26C9
12455 26C9              ; --------------------------
12456 26C9              ; Scanning variable routines
12457 26C9              ; --------------------------
12458 26C9              ;
12459 26C9              ;
12460 26C9
12461 26C9              ;; S-LETTER
12462 26C9 CD B2 28     L26C9:  CALL    L28B2           ; routine LOOK-VARS
12463 26CC
12464 26CC DA 2E 1C             JP      C,L1C2E         ; jump back to REPORT-2 if variable not found
12465 26CF                                              ; 'Variable not found'
12466 26CF                                              ; but a variable is always 'found' if syntax
12467 26CF                                              ; is being checked.
12468 26CF
12469 26CF CC 96 29             CALL    Z,L2996         ; routine STK-VAR considers a subscript/slice
12470 26D2 3A 3B 5C             LD      A,($5C3B)       ; fetch FLAGS value
12471 26D5 FE C0                CP      $C0             ; compare 11000000
12472 26D7 38 04                JR      C,L26DD         ; step forward to S-CONT-1 if string  ===>
12473 26D9
12474 26D9 23                   INC     HL              ; advance pointer
12475 26DA CD B4 33             CALL    L33B4           ; routine STACK-NUM
12476 26DD
12477 26DD              ;; S-CONT-1
12478 26DD 18 33        L26DD:  JR      L2712           ; forward to S-CONT-2                 ===>
12479 26DF
12480 26DF              ; ----------------------------------------
12481 26DF              ; -> the scanning branch was here if not alphanumeric.
12482 26DF              ; All the remaining functions will be evaluated by a single call to the
12483 26DF              ; calculator. The correct priority for the operation has to be placed in
12484 26DF              ; the B register and the operation code, calculator literal in the C register.
12485 26DF              ; the operation code has bit 7 set if result is numeric and bit 6 is
12486 26DF              ; set if operand is numeric. so
12487 26DF              ; $C0 = numeric result, numeric operand.            e.g. 'sin'
12488 26DF              ; $80 = numeric result, string operand.             e.g. 'code'
12489 26DF              ; $40 = string result, numeric operand.             e.g. 'str$'
12490 26DF              ; $00 = string result, string operand.              e.g. 'val$'
12491 26DF
12492 26DF              ;; S-NEGATE
12493 26DF 01 DB 09     L26DF:  LD      BC,$09DB        ; prepare priority 09, operation code $C0 +
12494 26E2                                              ; 'negate' ($1B) - bits 6 and 7 set for numeric
12495 26E2                                              ; result and numeric operand.
12496 26E2
12497 26E2 FE 2D                CP      $2D             ; is it '-' ?
12498 26E4 28 27                JR      Z,L270D         ; forward if so to S-PUSH-PO
12499 26E6
12500 26E6 01 18 10             LD      BC,$1018        ; prepare priority $10, operation code 'val$' -
12501 26E9                                              ; bits 6 and 7 reset for string result and
12502 26E9                                              ; string operand.
12503 26E9
12504 26E9 FE AE                CP      $AE             ; is it 'VAL$' ?
12505 26EB 28 20                JR      Z,L270D         ; forward if so to S-PUSH-PO
12506 26ED
12507 26ED D6 AF                SUB     $AF             ; subtract token 'CODE' value to reduce
12508 26EF                                              ; functions 'CODE' to 'NOT' although the
12509 26EF                                              ; upper range is, as yet, unchecked.
12510 26EF                                              ; valid range would be $00 - $14.
12511 26EF
12512 26EF DA 8A 1C             JP      C,L1C8A         ; jump back to REPORT-C with anything else
12513 26F2                                              ; 'Nonsense in BASIC'
12514 26F2
12515 26F2 01 F0 04             LD      BC,$04F0        ; prepare priority $04, operation $C0 +
12516 26F5                                              ; 'not' ($30)
12517 26F5
12518 26F5 FE 14                CP      $14             ; is it 'NOT'
12519 26F7 28 14                JR      Z,L270D         ; forward to S-PUSH-PO if so
12520 26F9
12521 26F9 D2 8A 1C             JP      NC,L1C8A        ; to REPORT-C if higher
12522 26FC                                              ; 'Nonsense in BASIC'
12523 26FC
12524 26FC 06 10                LD      B,$10           ; priority $10 for all the rest
12525 26FE C6 DC                ADD     A,$DC           ; make range $DC - $EF
12526 2700                                              ; $C0 + 'code'($1C) thru 'chr$' ($2F)
12527 2700
12528 2700 4F                   LD      C,A             ; transfer 'function' to C
12529 2701 FE DF                CP      $DF             ; is it 'sin' ?
12530 2703 30 02                JR      NC,L2707        ; forward to S-NO-TO-$  with 'sin' through
12531 2705                                              ; 'chr$' as operand is numeric.
12532 2705
12533 2705              ; all the rest 'cos' through 'chr$' give a numeric result except 'str$'
12534 2705              ; and 'chr$'.
12535 2705
12536 2705 CB B1                RES     6,C             ; signal string operand for 'code', 'val' and
12537 2707                                              ; 'len'.
12538 2707
12539 2707              ;; S-NO-TO-$
12540 2707 FE EE        L2707:  CP      $EE             ; compare 'str$'
12541 2709 38 02                JR      C,L270D         ; forward to S-PUSH-PO if lower as result
12542 270B                                              ; is numeric.
12543 270B
12544 270B CB B9                RES     7,C             ; reset bit 7 of op code for 'str$', 'chr$'
12545 270D                                              ; as result is string.
12546 270D
12547 270D              ; >> This is where they were all headed for.
12548 270D
12549 270D              ;; S-PUSH-PO
12550 270D C5           L270D:  PUSH    BC              ; push the priority and calculator operation
12551 270E                                              ; code.
12552 270E
12553 270E E7                   RST     20H             ; NEXT-CHAR
12554 270F C3 FF 24             JP      L24FF           ; jump back to S-LOOP-1 to go round the loop
12555 2712                                              ; again with the next character.
12556 2712
12557 2712              ; --------------------------------
12558 2712
12559 2712              ; ===>  there were many branches forward to here
12560 2712
12561 2712              ;   An important step after the evaluation of an expression is to test for
12562 2712              ;   a string expression and allow it to be sliced.  If a numeric expression is
12563 2712              ;   followed by a '(' then the numeric expression is complete.
12564 2712              ;   Since a string slice can itself be sliced then loop repeatedly
12565 2712              ;   e.g. (STR$ PI) (3 TO) (TO 2)    or "nonsense" (4 TO )
12566 2712
12567 2712              ;; S-CONT-2
12568 2712 DF           L2712:  RST     18H             ; GET-CHAR
12569 2713
12570 2713              ;; S-CONT-3
12571 2713 FE 28        L2713:  CP      $28             ; is it '(' ?
12572 2715 20 0C                JR      NZ,L2723        ; forward, if not, to S-OPERTR
12573 2717
12574 2717 FD CB 01 76          BIT     6,(IY+$01)      ; test FLAGS - numeric or string result ?
12575 271B 20 17                JR      NZ,L2734        ; forward, if numeric, to S-LOOP
12576 271D
12577 271D              ;   if a string expression preceded the '(' then slice it.
12578 271D
12579 271D CD 52 2A             CALL    L2A52           ; routine SLICING
12580 2720
12581 2720 E7                   RST     20H             ; NEXT-CHAR
12582 2721 18 F0                JR      L2713           ; loop back to S-CONT-3
12583 2723
12584 2723              ; ---------------------------
12585 2723
12586 2723              ;   the branch was here when possibility of a '(' has been excluded.
12587 2723
12588 2723              ;; S-OPERTR
12589 2723 06 00        L2723:  LD      B,$00           ; prepare to add
12590 2725 4F                   LD      C,A             ; possible operator to C
12591 2726 21 95 27             LD      HL,L2795        ; Address: $2795 - tbl-of-ops
12592 2729 CD DC 16             CALL    L16DC           ; routine INDEXER
12593 272C 30 06                JR      NC,L2734        ; forward to S-LOOP if not in table
12594 272E
12595 272E              ;   but if found in table the priority has to be looked up.
12596 272E
12597 272E 4E                   LD      C,(HL)          ; operation code to C ( B is still zero )
12598 272F 21 ED 26             LD      HL,L27B0 - $C3  ; $26ED is base of table
12599 2732 09                   ADD     HL,BC           ; index into table.
12600 2733 46                   LD      B,(HL)          ; priority to B.
12601 2734
12602 2734              ; ------------------
12603 2734              ; Scanning main loop
12604 2734              ; ------------------
12605 2734              ; the juggling act
12606 2734
12607 2734              ;; S-LOOP
12608 2734 D1           L2734:  POP     DE              ; fetch last priority and operation
12609 2735 7A                   LD      A,D             ; priority to A
12610 2736 B8                   CP      B               ; compare with this one
12611 2737 38 3A                JR      C,L2773         ; forward to S-TIGHTER to execute the
12612 2739                                              ; last operation before this one as it has
12613 2739                                              ; higher priority.
12614 2739
12615 2739              ; the last priority was greater or equal this one.
12616 2739
12617 2739 A7                   AND     A               ; if it is zero then so is this
12618 273A CA 18 00             JP      Z,L0018         ; jump to exit via get-char pointing at
12619 273D                                              ; next character.
12620 273D                                              ; This may be the character after the
12621 273D                                              ; expression or, if exiting a recursive call,
12622 273D                                              ; the next part of the expression to be
12623 273D                                              ; evaluated.
12624 273D
12625 273D C5                   PUSH    BC              ; save current priority/operation
12626 273E                                              ; as it has lower precedence than the one
12627 273E                                              ; now in DE.
12628 273E
12629 273E              ; the 'USR' function is special in that it is overloaded to give two types
12630 273E              ; of result.
12631 273E
12632 273E 21 3B 5C             LD      HL,$5C3B        ; address FLAGS
12633 2741 7B                   LD      A,E             ; new operation to A register
12634 2742 FE ED                CP      $ED             ; is it $C0 + 'usr-no' ($2D)  ?
12635 2744 20 06                JR      NZ,L274C        ; forward to S-STK-LST if not
12636 2746
12637 2746 CB 76                BIT     6,(HL)          ; string result expected ?
12638 2748                                              ; (from the lower priority operand we've
12639 2748                                              ; just pushed on stack )
12640 2748 20 02                JR      NZ,L274C        ; forward to S-STK-LST if numeric
12641 274A                                              ; as operand bits match.
12642 274A
12643 274A 1E 99                LD      E,$99           ; reset bit 6 and substitute $19 'usr-$'
12644 274C                                              ; for string operand.
12645 274C
12646 274C              ;; S-STK-LST
12647 274C D5           L274C:  PUSH    DE              ; now stack this priority/operation
12648 274D CD 30 25             CALL    L2530           ; routine SYNTAX-Z
12649 2750 28 09                JR      Z,L275B         ; forward to S-SYNTEST if checking syntax.
12650 2752
12651 2752 7B                   LD      A,E             ; fetch the operation code
12652 2753 E6 3F                AND     $3F             ; mask off the result/operand bits to leave
12653 2755                                              ; a calculator literal.
12654 2755 47                   LD      B,A             ; transfer to B register
12655 2756
12656 2756              ; now use the calculator to perform the single operation - operand is on
12657 2756              ; the calculator stack.
12658 2756              ; Note. although the calculator is performing a single operation most
12659 2756              ; functions e.g. TAN are written using other functions and literals and
12660 2756              ; these in turn are written using further strings of calculator literals so
12661 2756              ; another level of magical recursion joins the juggling act for a while
12662 2756              ; as the calculator too is calling itself.
12663 2756
12664 2756 EF                   RST     28H             ;; FP-CALC
12665 2757 3B                   DEFB    $3B             ;;fp-calc-2
12666 2758 38           L2758:  DEFB    $38             ;;end-calc
12667 2759
12668 2759 18 09                JR      L2764           ; forward to S-RUNTEST
12669 275B
12670 275B              ; ---
12671 275B
12672 275B              ; the branch was here if checking syntax only.
12673 275B
12674 275B              ;; S-SYNTEST
12675 275B 7B           L275B:  LD      A,E             ; fetch the operation code to accumulator
12676 275C FD AE 01             XOR     (IY+$01)        ; compare with bits of FLAGS
12677 275F E6 40                AND     $40             ; bit 6 will be zero now if operand
12678 2761                                              ; matched expected result.
12679 2761
12680 2761              ;; S-RPORT-C2
12681 2761 C2 8A 1C     L2761:  JP      NZ,L1C8A        ; to REPORT-C if mismatch
12682 2764                                              ; 'Nonsense in BASIC'
12683 2764                                              ; else continue to set flags for next
12684 2764
12685 2764              ; the branch is to here in runtime after a successful operation.
12686 2764
12687 2764              ;; S-RUNTEST
12688 2764 D1           L2764:  POP     DE              ; fetch the last operation from stack
12689 2765 21 3B 5C             LD      HL,$5C3B        ; address FLAGS
12690 2768 CB F6                SET     6,(HL)          ; set default to numeric result in FLAGS
12691 276A CB 7B                BIT     7,E             ; test the operational result
12692 276C 20 02                JR      NZ,L2770        ; forward to S-LOOPEND if numeric
12693 276E
12694 276E CB B6                RES     6,(HL)          ; reset bit 6 of FLAGS to show string result.
12695 2770
12696 2770              ;; S-LOOPEND
12697 2770 C1           L2770:  POP     BC              ; fetch the previous priority/operation
12698 2771 18 C1                JR      L2734           ; back to S-LOOP to perform these
12699 2773
12700 2773              ; ---
12701 2773
12702 2773              ; the branch was here when a stacked priority/operator had higher priority
12703 2773              ; than the current one.
12704 2773
12705 2773              ;; S-TIGHTER
12706 2773 D5           L2773:  PUSH    DE              ; save high priority op on stack again
12707 2774 79                   LD      A,C             ; fetch lower priority operation code
12708 2775 FD CB 01 76          BIT     6,(IY+$01)      ; test FLAGS - Numeric or string result ?
12709 2779 20 15                JR      NZ,L2790        ; forward to S-NEXT if numeric result
12710 277B
12711 277B              ; if this is lower priority yet has string then must be a comparison.
12712 277B              ; Since these can only be evaluated in context and were defaulted to
12713 277B              ; numeric in operator look up they must be changed to string equivalents.
12714 277B
12715 277B E6 3F                AND     $3F             ; mask to give true calculator literal
12716 277D C6 08                ADD     A,$08           ; augment numeric literals to string
12717 277F                                              ; equivalents.
12718 277F                                              ; 'no-&-no'  => 'str-&-no'
12719 277F                                              ; 'no-l-eql' => 'str-l-eql'
12720 277F                                              ; 'no-gr-eq' => 'str-gr-eq'
12721 277F                                              ; 'nos-neql' => 'strs-neql'
12722 277F                                              ; 'no-grtr'  => 'str-grtr'
12723 277F                                              ; 'no-less'  => 'str-less'
12724 277F                                              ; 'nos-eql'  => 'strs-eql'
12725 277F                                              ; 'addition' => 'strs-add'
12726 277F 4F                   LD      C,A             ; put modified comparison operator back
12727 2780 FE 10                CP      $10             ; is it now 'str-&-no' ?
12728 2782 20 04                JR      NZ,L2788        ; forward to S-NOT-AND  if not.
12729 2784
12730 2784 CB F1                SET     6,C             ; set numeric operand bit
12731 2786 18 08                JR      L2790           ; forward to S-NEXT
12732 2788
12733 2788              ; ---
12734 2788
12735 2788              ;; S-NOT-AND
12736 2788 38 D7        L2788:  JR      C,L2761         ; back to S-RPORT-C2 if less
12737 278A                                              ; 'Nonsense in BASIC'.
12738 278A                                              ; e.g. a$ * b$
12739 278A
12740 278A FE 17                CP      $17             ; is it 'strs-add' ?
12741 278C 28 02                JR      Z,L2790         ; forward to S-NEXT if so
12742 278E                                              ; (bit 6 and 7 are reset)
12743 278E
12744 278E CB F9                SET     7,C             ; set numeric (Boolean) result for all others
12745 2790
12746 2790              ;; S-NEXT
12747 2790 C5           L2790:  PUSH    BC              ; now save this priority/operation on stack
12748 2791
12749 2791 E7                   RST     20H             ; NEXT-CHAR
12750 2792 C3 FF 24             JP      L24FF           ; jump back to S-LOOP-1
12751 2795
12752 2795              ; ------------------
12753 2795              ; Table of operators
12754 2795              ; ------------------
12755 2795              ; This table is used to look up the calculator literals associated with
12756 2795              ; the operator character. The thirteen calculator operations $03 - $0F
12757 2795              ; have bits 6 and 7 set to signify a numeric result.
12758 2795              ; Some of these codes and bits may be altered later if the context suggests
12759 2795              ; a string comparison or operation.
12760 2795              ; that is '+', '=', '>', '<', '<=', '>=' or '<>'.
12761 2795
12762 2795              ;; tbl-of-ops
12763 2795 2B CF        L2795:  DEFB    '+', $CF        ;        $C0 + 'addition'
12764 2797 2D C3                DEFB    '-', $C3        ;        $C0 + 'subtract'
12765 2799 2A C4                DEFB    '*', $C4        ;        $C0 + 'multiply'
12766 279B 2F C5                DEFB    '/', $C5        ;        $C0 + 'division'
12767 279D 5E C6                DEFB    '^', $C6        ;        $C0 + 'to-power'
12768 279F 3D CE                DEFB    '=', $CE        ;        $C0 + 'nos-eql'
12769 27A1 3E CC                DEFB    '>', $CC        ;        $C0 + 'no-grtr'
12770 27A3 3C CD                DEFB    '<', $CD        ;        $C0 + 'no-less'
12771 27A5
12772 27A5 C7 C9                DEFB    $C7, $C9        ; '<='   $C0 + 'no-l-eql'
12773 27A7 C8 CA                DEFB    $C8, $CA        ; '>='   $C0 + 'no-gr-eql'
12774 27A9 C9 CB                DEFB    $C9, $CB        ; '<>'   $C0 + 'nos-neql'
12775 27AB C5 C7                DEFB    $C5, $C7        ; 'OR'   $C0 + 'or'
12776 27AD C6 C8                DEFB    $C6, $C8        ; 'AND'  $C0 + 'no-&-no'
12777 27AF
12778 27AF 00                   DEFB    $00             ; zero end-marker.
12779 27B0
12780 27B0
12781 27B0              ; -------------------
12782 27B0              ; Table of priorities
12783 27B0              ; -------------------
12784 27B0              ; This table is indexed with the operation code obtained from the above
12785 27B0              ; table $C3 - $CF to obtain the priority for the respective operation.
12786 27B0
12787 27B0              ;; tbl-priors
12788 27B0 06           L27B0:  DEFB    $06             ; '-'   opcode $C3
12789 27B1 08                   DEFB    $08             ; '*'   opcode $C4
12790 27B2 08                   DEFB    $08             ; '/'   opcode $C5
12791 27B3 0A                   DEFB    $0A             ; '^'   opcode $C6
12792 27B4 02                   DEFB    $02             ; 'OR'  opcode $C7
12793 27B5 03                   DEFB    $03             ; 'AND' opcode $C8
12794 27B6 05                   DEFB    $05             ; '<='  opcode $C9
12795 27B7 05                   DEFB    $05             ; '>='  opcode $CA
12796 27B8 05                   DEFB    $05             ; '<>'  opcode $CB
12797 27B9 05                   DEFB    $05             ; '>'   opcode $CC
12798 27BA 05                   DEFB    $05             ; '<'   opcode $CD
12799 27BB 05                   DEFB    $05             ; '='   opcode $CE
12800 27BC 06                   DEFB    $06             ; '+'   opcode $CF
12801 27BD
12802 27BD              ; ----------------------
12803 27BD              ; Scanning function (FN)
12804 27BD              ; ----------------------
12805 27BD              ; This routine deals with user-defined functions.
12806 27BD              ; The definition can be anywhere in the program area but these are best
12807 27BD              ; placed near the start of the program as we shall see.
12808 27BD              ; The evaluation process is quite complex as the Spectrum has to parse two
12809 27BD              ; statements at the same time. Syntax of both has been checked previously
12810 27BD              ; and hidden locations have been created immediately after each argument
12811 27BD              ; of the DEF FN statement. Each of the arguments of the FN function is
12812 27BD              ; evaluated by SCANNING and placed in the hidden locations. Then the
12813 27BD              ; expression to the right of the DEF FN '=' is evaluated by SCANNING and for
12814 27BD              ; any variables encountered, a search is made in the DEF FN variable list
12815 27BD              ; in the program area before searching in the normal variables area.
12816 27BD              ;
12817 27BD              ; Recursion is not allowed: i.e. the definition of a function should not use
12818 27BD              ; the same function, either directly or indirectly ( through another function).
12819 27BD              ; You'll normally get error 4, ('Out of memory'), although sometimes the system
12820 27BD              ; will crash. - Vickers, Pitman 1984.
12821 27BD              ;
12822 27BD              ; As the definition is just an expression, there would seem to be no means
12823 27BD              ; of breaking out of such recursion.
12824 27BD              ; However, by the clever use of string expressions and VAL, such recursion is
12825 27BD              ; possible.
12826 27BD              ; e.g. DEF FN a(n) = VAL "n+FN a(n-1)+0" ((n<1) * 10 + 1 TO )
12827 27BD              ; will evaluate the full 11-character expression for all values where n is
12828 27BD              ; greater than zero but just the 11th character, "0", when n drops to zero
12829 27BD              ; thereby ending the recursion producing the correct result.
12830 27BD              ; Recursive string functions are possible using VAL$ instead of VAL and the
12831 27BD              ; null string as the final addend.
12832 27BD              ; - from a turn of the century newsgroup discussion initiated by Mike Wynne.
12833 27BD
12834 27BD              ;; S-FN-SBRN
12835 27BD CD 30 25     L27BD:  CALL    L2530           ; routine SYNTAX-Z
12836 27C0 20 35                JR      NZ,L27F7        ; forward to SF-RUN in runtime
12837 27C2
12838 27C2
12839 27C2 E7                   RST     20H             ; NEXT-CHAR
12840 27C3 CD 8D 2C             CALL    L2C8D           ; routine ALPHA check for letters A-Z a-z
12841 27C6 D2 8A 1C             JP      NC,L1C8A        ; jump back to REPORT-C if not
12842 27C9                                              ; 'Nonsense in BASIC'
12843 27C9
12844 27C9
12845 27C9 E7                   RST     20H             ; NEXT-CHAR
12846 27CA FE 24                CP      $24             ; is it '$' ?
12847 27CC F5                   PUSH    AF              ; save character and flags
12848 27CD 20 01                JR      NZ,L27D0        ; forward to SF-BRKT-1 with numeric function
12849 27CF
12850 27CF
12851 27CF E7                   RST     20H             ; NEXT-CHAR
12852 27D0
12853 27D0              ;; SF-BRKT-1
12854 27D0 FE 28        L27D0:  CP      $28             ; is '(' ?
12855 27D2 20 12                JR      NZ,L27E6        ; forward to SF-RPRT-C if not
12856 27D4                                              ; 'Nonsense in BASIC'
12857 27D4
12858 27D4
12859 27D4 E7                   RST     20H             ; NEXT-CHAR
12860 27D5 FE 29                CP      $29             ; is it ')' ?
12861 27D7 28 10                JR      Z,L27E9         ; forward to SF-FLAG-6 if no arguments.
12862 27D9
12863 27D9              ;; SF-ARGMTS
12864 27D9 CD FB 24     L27D9:  CALL    L24FB           ; routine SCANNING checks each argument
12865 27DC                                              ; which may be an expression.
12866 27DC
12867 27DC DF                   RST     18H             ; GET-CHAR
12868 27DD FE 2C                CP      $2C             ; is it a ',' ?
12869 27DF 20 03                JR      NZ,L27E4        ; forward if not to SF-BRKT-2 to test bracket
12870 27E1
12871 27E1
12872 27E1 E7                   RST     20H             ; NEXT-CHAR if a comma was found
12873 27E2 18 F5                JR      L27D9           ; back to SF-ARGMTS to parse all arguments.
12874 27E4
12875 27E4              ; ---
12876 27E4
12877 27E4              ;; SF-BRKT-2
12878 27E4 FE 29        L27E4:  CP      $29             ; is character the closing ')' ?
12879 27E6
12880 27E6              ;; SF-RPRT-C
12881 27E6 C2 8A 1C     L27E6:  JP      NZ,L1C8A        ; jump to REPORT-C
12882 27E9                                              ; 'Nonsense in BASIC'
12883 27E9
12884 27E9              ; at this point any optional arguments have had their syntax checked.
12885 27E9
12886 27E9              ;; SF-FLAG-6
12887 27E9 E7           L27E9:  RST     20H             ; NEXT-CHAR
12888 27EA 21 3B 5C             LD      HL,$5C3B        ; address system variable FLAGS
12889 27ED CB B6                RES     6,(HL)          ; signal string result
12890 27EF F1                   POP     AF              ; restore test against '$'.
12891 27F0 28 02                JR      Z,L27F4         ; forward to SF-SYN-EN if string function.
12892 27F2
12893 27F2 CB F6                SET     6,(HL)          ; signal numeric result
12894 27F4
12895 27F4              ;; SF-SYN-EN
12896 27F4 C3 12 27     L27F4:  JP      L2712           ; jump back to S-CONT-2 to continue scanning.
12897 27F7
12898 27F7              ; ---
12899 27F7
12900 27F7              ; the branch was here in runtime.
12901 27F7
12902 27F7              ;; SF-RUN
12903 27F7 E7           L27F7:  RST     20H             ; NEXT-CHAR fetches name
12904 27F8 E6 DF                AND     $DF             ; AND 11101111 - reset bit 5 - upper-case.
12905 27FA 47                   LD      B,A             ; save in B
12906 27FB
12907 27FB E7                   RST     20H             ; NEXT-CHAR
12908 27FC D6 24                SUB     $24             ; subtract '$'
12909 27FE 4F                   LD      C,A             ; save result in C
12910 27FF 20 01                JR      NZ,L2802        ; forward if not '$' to SF-ARGMT1
12911 2801
12912 2801 E7                   RST     20H             ; NEXT-CHAR advances to bracket
12913 2802
12914 2802              ;; SF-ARGMT1
12915 2802 E7           L2802:  RST     20H             ; NEXT-CHAR advances to start of argument
12916 2803 E5                   PUSH    HL              ; save address
12917 2804 2A 53 5C             LD      HL,($5C53)      ; fetch start of program area from PROG
12918 2807 2B                   DEC     HL              ; the search starting point is the previous
12919 2808                                              ; location.
12920 2808
12921 2808              ;; SF-FND-DF
12922 2808 11 CE 00     L2808:  LD      DE,$00CE        ; search is for token 'DEF FN' in E,
12923 280B                                              ; statement count in D.
12924 280B C5                   PUSH    BC              ; save C the string test, and B the letter.
12925 280C CD 86 1D             CALL    L1D86           ; routine LOOK-PROG will search for token.
12926 280F C1                   POP     BC              ; restore BC.
12927 2810 30 02                JR      NC,L2814        ; forward to SF-CP-DEF if a match was found.
12928 2812
12929 2812
12930 2812              ;; REPORT-P
12931 2812 CF           L2812:  RST     08H             ; ERROR-1
12932 2813 18                   DEFB    $18             ; Error Report: FN without DEF
12933 2814
12934 2814              ;; SF-CP-DEF
12935 2814 E5           L2814:  PUSH    HL              ; save address of DEF FN
12936 2815 CD AB 28             CALL    L28AB           ; routine FN-SKPOVR skips over white-space etc.
12937 2818                                              ; without disturbing CH-ADD.
12938 2818 E6 DF                AND     $DF             ; make fetched character upper-case.
12939 281A B8                   CP      B               ; compare with FN name
12940 281B 20 08                JR      NZ,L2825        ; forward to SF-NOT-FD if no match.
12941 281D
12942 281D              ; the letters match so test the type.
12943 281D
12944 281D CD AB 28             CALL    L28AB           ; routine FN-SKPOVR skips white-space
12945 2820 D6 24                SUB     $24             ; subtract '$' from fetched character
12946 2822 B9                   CP      C               ; compare with saved result of same operation
12947 2823                                              ; on FN name.
12948 2823 28 0C                JR      Z,L2831         ; forward to SF-VALUES with a match.
12949 2825
12950 2825              ; the letters matched but one was string and the other numeric.
12951 2825
12952 2825              ;; SF-NOT-FD
12953 2825 E1           L2825:  POP     HL              ; restore search point.
12954 2826 2B                   DEC     HL              ; make location before
12955 2827 11 00 02             LD      DE,$0200        ; the search is to be for the end of the
12956 282A                                              ; current definition - 2 statements forward.
12957 282A C5                   PUSH    BC              ; save the letter/type
12958 282B CD 8B 19             CALL    L198B           ; routine EACH-STMT steps past rejected
12959 282E                                              ; definition.
12960 282E C1                   POP     BC              ; restore letter/type
12961 282F 18 D7                JR      L2808           ; back to SF-FND-DF to continue search
12962 2831
12963 2831              ; ---
12964 2831
12965 2831              ; Success!
12966 2831              ; the branch was here with matching letter and numeric/string type.
12967 2831
12968 2831              ;; SF-VALUES
12969 2831 A7           L2831:  AND     A               ; test A ( will be zero if string '$' - '$' )
12970 2832
12971 2832 CC AB 28             CALL    Z,L28AB         ; routine FN-SKPOVR advances HL past '$'.
12972 2835
12973 2835 D1                   POP     DE              ; discard pointer to 'DEF FN'.
12974 2836 D1                   POP     DE              ; restore pointer to first FN argument.
12975 2837 ED 53 5D 5C          LD      ($5C5D),DE      ; save in CH_ADD
12976 283B
12977 283B CD AB 28             CALL    L28AB           ; routine FN-SKPOVR advances HL past '('
12978 283E E5                   PUSH    HL              ; save start address in DEF FN  ***
12979 283F FE 29                CP      $29             ; is character a ')' ?
12980 2841 28 42                JR      Z,L2885         ; forward to SF-R-BR-2 if no arguments.
12981 2843
12982 2843              ;; SF-ARG-LP
12983 2843 23           L2843:  INC     HL              ; point to next character.
12984 2844 7E                   LD      A,(HL)          ; fetch it.
12985 2845 FE 0E                CP      $0E             ; is it the number marker
12986 2847 16 40                LD      D,$40           ; signal numeric in D.
12987 2849 28 07                JR      Z,L2852         ; forward to SF-ARG-VL if numeric.
12988 284B
12989 284B 2B                   DEC     HL              ; back to letter
12990 284C CD AB 28             CALL    L28AB           ; routine FN-SKPOVR skips any white-space
12991 284F 23                   INC     HL              ; advance past the expected '$' to
12992 2850                                              ; the 'hidden' marker.
12993 2850 16 00                LD      D,$00           ; signal string.
12994 2852
12995 2852              ;; SF-ARG-VL
12996 2852 23           L2852:  INC     HL              ; now address first of 5-byte location.
12997 2853 E5                   PUSH    HL              ; save address in DEF FN statement
12998 2854 D5                   PUSH    DE              ; save D - result type
12999 2855
13000 2855 CD FB 24             CALL    L24FB           ; routine SCANNING evaluates expression in
13001 2858                                              ; the FN statement setting FLAGS and leaving
13002 2858                                              ; result as last value on calculator stack.
13003 2858
13004 2858 F1                   POP     AF              ; restore saved result type to A
13005 2859
13006 2859 FD AE 01             XOR     (IY+$01)        ; xor with FLAGS
13007 285C E6 40                AND     $40             ; and with 01000000 to test bit 6
13008 285E 20 2B                JR      NZ,L288B        ; forward to REPORT-Q if type mismatch.
13009 2860                                              ; 'Parameter error'
13010 2860
13011 2860 E1                   POP     HL              ; pop the start address in DEF FN statement
13012 2861 EB                   EX      DE,HL           ; transfer to DE ?? pop straight into de ?
13013 2862
13014 2862 2A 65 5C             LD      HL,($5C65)      ; set HL to STKEND location after value
13015 2865 01 05 00             LD      BC,$0005        ; five bytes to move
13016 2868 ED 42                SBC     HL,BC           ; decrease HL by 5 to point to start.
13017 286A 22 65 5C             LD      ($5C65),HL      ; set STKEND 'removing' value from stack.
13018 286D
13019 286D ED B0                LDIR                    ; copy value into DEF FN statement
13020 286F EB                   EX      DE,HL           ; set HL to location after value in DEF FN
13021 2870 2B                   DEC     HL              ; step back one
13022 2871 CD AB 28             CALL    L28AB           ; routine FN-SKPOVR gets next valid character
13023 2874 FE 29                CP      $29             ; is it ')' end of arguments ?
13024 2876 28 0D                JR      Z,L2885         ; forward to SF-R-BR-2 if so.
13025 2878
13026 2878              ; a comma separator has been encountered in the DEF FN argument list.
13027 2878
13028 2878 E5                   PUSH    HL              ; save position in DEF FN statement
13029 2879
13030 2879 DF                   RST     18H             ; GET-CHAR from FN statement
13031 287A FE 2C                CP      $2C             ; is it ',' ?
13032 287C 20 0D                JR      NZ,L288B        ; forward to REPORT-Q if not
13033 287E                                              ; 'Parameter error'
13034 287E
13035 287E E7                   RST     20H             ; NEXT-CHAR in FN statement advances to next
13036 287F                                              ; argument.
13037 287F
13038 287F E1                   POP     HL              ; restore DEF FN pointer
13039 2880 CD AB 28             CALL    L28AB           ; routine FN-SKPOVR advances to corresponding
13040 2883                                              ; argument.
13041 2883
13042 2883 18 BE                JR      L2843           ; back to SF-ARG-LP looping until all
13043 2885                                              ; arguments are passed into the DEF FN
13044 2885                                              ; hidden locations.
13045 2885
13046 2885              ; ---
13047 2885
13048 2885              ; the branch was here when all arguments passed.
13049 2885
13050 2885              ;; SF-R-BR-2
13051 2885 E5           L2885:  PUSH    HL              ; save location of ')' in DEF FN
13052 2886
13053 2886 DF                   RST     18H             ; GET-CHAR gets next character in FN
13054 2887 FE 29                CP      $29             ; is it a ')' also ?
13055 2889 28 02                JR      Z,L288D         ; forward to SF-VALUE if so.
13056 288B
13057 288B
13058 288B              ;; REPORT-Q
13059 288B CF           L288B:  RST     08H             ; ERROR-1
13060 288C 19                   DEFB    $19             ; Error Report: Parameter error
13061 288D
13062 288D              ;; SF-VALUE
13063 288D D1           L288D:  POP     DE              ; location of ')' in DEF FN to DE.
13064 288E EB                   EX      DE,HL           ; now to HL, FN ')' pointer to DE.
13065 288F 22 5D 5C             LD      ($5C5D),HL      ; initialize CH_ADD to this value.
13066 2892
13067 2892              ; At this point the start of the DEF FN argument list is on the machine stack.
13068 2892              ; We also have to consider that this defined function may form part of the
13069 2892              ; definition of another defined function (though not itself).
13070 2892              ; As this defined function may be part of a hierarchy of defined functions
13071 2892              ; currently being evaluated by recursive calls to SCANNING, then we have to
13072 2892              ; preserve the original value of DEFADD and not assume that it is zero.
13073 2892
13074 2892 2A 0B 5C             LD      HL,($5C0B)      ; get original DEFADD address
13075 2895 E3                   EX      (SP),HL         ; swap with DEF FN address on stack ***
13076 2896 22 0B 5C             LD      ($5C0B),HL      ; set DEFADD to point to this argument list
13077 2899                                              ; during scanning.
13078 2899
13079 2899 D5                   PUSH    DE              ; save FN ')' pointer.
13080 289A
13081 289A E7                   RST     20H             ; NEXT-CHAR advances past ')' in define
13082 289B
13083 289B E7                   RST     20H             ; NEXT-CHAR advances past '=' to expression
13084 289C
13085 289C CD FB 24             CALL    L24FB           ; routine SCANNING evaluates but searches
13086 289F                                              ; initially for variables at DEFADD
13087 289F
13088 289F E1                   POP     HL              ; pop the FN ')' pointer
13089 28A0 22 5D 5C             LD      ($5C5D),HL      ; set CH_ADD to this
13090 28A3 E1                   POP     HL              ; pop the original DEFADD value
13091 28A4 22 0B 5C             LD      ($5C0B),HL      ; and re-insert into DEFADD system variable.
13092 28A7
13093 28A7 E7                   RST     20H             ; NEXT-CHAR advances to character after ')'
13094 28A8 C3 12 27             JP      L2712           ; to S-CONT-2 - to continue current
13095 28AB                                              ; invocation of scanning
13096 28AB
13097 28AB              ; --------------------
13098 28AB              ; Used to parse DEF FN
13099 28AB              ; --------------------
13100 28AB              ; e.g. DEF FN     s $ ( x )     =  b     $ (  TO  x  ) : REM exaggerated
13101 28AB              ;
13102 28AB              ; This routine is used 10 times to advance along a DEF FN statement
13103 28AB              ; skipping spaces and colour control codes. It is similar to NEXT-CHAR
13104 28AB              ; which is, at the same time, used to skip along the corresponding FN function
13105 28AB              ; except the latter has to deal with AT and TAB characters in string
13106 28AB              ; expressions. These cannot occur in a program area so this routine is
13107 28AB              ; simpler as both colour controls and their parameters are less than space.
13108 28AB
13109 28AB              ;; FN-SKPOVR
13110 28AB 23           L28AB:  INC     HL              ; increase pointer
13111 28AC 7E                   LD      A,(HL)          ; fetch addressed character
13112 28AD FE 21                CP      $21             ; compare with space + 1
13113 28AF 38 FA                JR      C,L28AB         ; back to FN-SKPOVR if less
13114 28B1
13115 28B1 C9                   RET                     ; return pointing to a valid character.
13116 28B2
13117 28B2              ; ---------
13118 28B2              ; LOOK-VARS
13119 28B2              ; ---------
13120 28B2              ;
13121 28B2              ;
13122 28B2
13123 28B2              ;; LOOK-VARS
13124 28B2 FD CB 01 F6  L28B2:  SET     6,(IY+$01)      ; update FLAGS - presume numeric result
13125 28B6
13126 28B6 DF                   RST     18H             ; GET-CHAR
13127 28B7 CD 8D 2C             CALL    L2C8D           ; routine ALPHA tests for A-Za-z
13128 28BA D2 8A 1C             JP      NC,L1C8A        ; jump to REPORT-C if not.
13129 28BD                                              ; 'Nonsense in BASIC'
13130 28BD
13131 28BD E5                   PUSH    HL              ; save pointer to first letter       ^1
13132 28BE E6 1F                AND     $1F             ; mask lower bits, 1 - 26 decimal     000xxxxx
13133 28C0 4F                   LD      C,A             ; store in C.
13134 28C1
13135 28C1 E7                   RST     20H             ; NEXT-CHAR
13136 28C2 E5                   PUSH    HL              ; save pointer to second character   ^2
13137 28C3 FE 28                CP      $28             ; is it '(' - an array ?
13138 28C5 28 28                JR      Z,L28EF         ; forward to V-RUN/SYN if so.
13139 28C7
13140 28C7 CB F1                SET     6,C             ; set 6 signaling string if solitary  010
13141 28C9 FE 24                CP      $24             ; is character a '$' ?
13142 28CB 28 11                JR      Z,L28DE         ; forward to V-STR-VAR
13143 28CD
13144 28CD CB E9                SET     5,C             ; signal numeric                       011
13145 28CF CD 88 2C             CALL    L2C88           ; routine ALPHANUM sets carry if second
13146 28D2                                              ; character is alphanumeric.
13147 28D2 30 0F                JR      NC,L28E3        ; forward to V-TEST-FN if just one character
13148 28D4
13149 28D4              ; It is more than one character but re-test current character so that 6 reset
13150 28D4              ; This loop renders the similar loop at V-PASS redundant.
13151 28D4
13152 28D4              ;; V-CHAR
13153 28D4 CD 88 2C     L28D4:  CALL    L2C88           ; routine ALPHANUM
13154 28D7 30 16                JR      NC,L28EF        ; to V-RUN/SYN when no more
13155 28D9
13156 28D9 CB B1                RES     6,C             ; make long named type                 001
13157 28DB
13158 28DB E7                   RST     20H             ; NEXT-CHAR
13159 28DC 18 F6                JR      L28D4           ; loop back to V-CHAR
13160 28DE
13161 28DE              ; ---
13162 28DE
13163 28DE
13164 28DE              ;; V-STR-VAR
13165 28DE E7           L28DE:  RST     20H             ; NEXT-CHAR advances past '$'
13166 28DF FD CB 01 B6          RES     6,(IY+$01)      ; update FLAGS - signal string result.
13167 28E3
13168 28E3              ;; V-TEST-FN
13169 28E3 3A 0C 5C     L28E3:  LD      A,($5C0C)       ; load A with DEFADD_hi
13170 28E6 A7                   AND     A               ; and test for zero.
13171 28E7 28 06                JR      Z,L28EF         ; forward to V-RUN/SYN if a defined function
13172 28E9                                              ; is not being evaluated.
13173 28E9
13174 28E9              ; Note.
13175 28E9
13176 28E9 CD 30 25             CALL    L2530           ; routine SYNTAX-Z
13177 28EC C2 51 29             JP      NZ,L2951        ; JUMP to STK-F-ARG in runtime and then
13178 28EF                                              ; back to this point if no variable found.
13179 28EF
13180 28EF              ;; V-RUN/SYN
13181 28EF 41           L28EF:  LD      B,C             ; save flags in B
13182 28F0 CD 30 25             CALL    L2530           ; routine SYNTAX-Z
13183 28F3 20 08                JR      NZ,L28FD        ; to V-RUN to look for the variable in runtime
13184 28F5
13185 28F5              ; if checking syntax the letter is not returned
13186 28F5
13187 28F5 79                   LD      A,C             ; copy letter/flags to A
13188 28F6 E6 E0                AND     $E0             ; and with 11100000 to get rid of the letter
13189 28F8 CB FF                SET     7,A             ; use spare bit to signal checking syntax.
13190 28FA 4F                   LD      C,A             ; and transfer to C.
13191 28FB 18 37                JR      L2934           ; forward to V-SYNTAX
13192 28FD
13193 28FD              ; ---
13194 28FD
13195 28FD              ; but in runtime search for the variable.
13196 28FD
13197 28FD              ;; V-RUN
13198 28FD 2A 4B 5C     L28FD:  LD      HL,($5C4B)      ; set HL to start of variables from VARS
13199 2900
13200 2900              ;; V-EACH
13201 2900 7E           L2900:  LD      A,(HL)          ; get first character
13202 2901 E6 7F                AND     $7F             ; and with 01111111
13203 2903                                              ; ignoring bit 7 which distinguishes
13204 2903                                              ; arrays or for/next variables.
13205 2903
13206 2903 28 2D                JR      Z,L2932         ; to V-80-BYTE if zero as must be 10000000
13207 2905                                              ; the variables end-marker.
13208 2905
13209 2905 B9                   CP      C               ; compare with supplied value.
13210 2906 20 22                JR      NZ,L292A        ; forward to V-NEXT if no match.
13211 2908
13212 2908 17                   RLA                     ; destructively test
13213 2909 87                   ADD     A,A             ; bits 5 and 6 of A
13214 290A                                              ; jumping if bit 5 reset or 6 set
13215 290A
13216 290A F2 3F 29             JP      P,L293F         ; to V-FOUND-2  strings and arrays
13217 290D
13218 290D 38 30                JR      C,L293F         ; to V-FOUND-2  simple and for next
13219 290F
13220 290F              ; leaving long name variables.
13221 290F
13222 290F D1                   POP     DE              ; pop pointer to 2nd. char
13223 2910 D5                   PUSH    DE              ; save it again
13224 2911 E5                   PUSH    HL              ; save variable first character pointer
13225 2912
13226 2912              ;; V-MATCHES
13227 2912 23           L2912:  INC     HL              ; address next character in vars area
13228 2913
13229 2913              ;; V-SPACES
13230 2913 1A           L2913:  LD      A,(DE)          ; pick up letter from prog area
13231 2914 13                   INC     DE              ; and advance address
13232 2915 FE 20                CP      $20             ; is it a space
13233 2917 28 FA                JR      Z,L2913         ; back to V-SPACES until non-space
13234 2919
13235 2919 F6 20                OR      $20             ; convert to range 1 - 26.
13236 291B BE                   CP      (HL)            ; compare with addressed variables character
13237 291C 28 F4                JR      Z,L2912         ; loop back to V-MATCHES if a match on an
13238 291E                                              ; intermediate letter.
13239 291E
13240 291E F6 80                OR      $80             ; now set bit 7 as last character of long
13241 2920                                              ; names are inverted.
13242 2920 BE                   CP      (HL)            ; compare again
13243 2921 20 06                JR      NZ,L2929        ; forward to V-GET-PTR if no match
13244 2923
13245 2923              ; but if they match check that this is also last letter in prog area
13246 2923
13247 2923 1A                   LD      A,(DE)          ; fetch next character
13248 2924 CD 88 2C             CALL    L2C88           ; routine ALPHANUM sets carry if not alphanum
13249 2927 30 15                JR      NC,L293E        ; forward to V-FOUND-1 with a full match.
13250 2929
13251 2929              ;; V-GET-PTR
13252 2929 E1           L2929:  POP     HL              ; pop saved pointer to char 1
13253 292A
13254 292A              ;; V-NEXT
13255 292A C5           L292A:  PUSH    BC              ; save flags
13256 292B CD B8 19             CALL    L19B8           ; routine NEXT-ONE gets next variable in DE
13257 292E EB                   EX      DE,HL           ; transfer to HL.
13258 292F C1                   POP     BC              ; restore the flags
13259 2930 18 CE                JR      L2900           ; loop back to V-EACH
13260 2932                                              ; to compare each variable
13261 2932
13262 2932              ; ---
13263 2932
13264 2932              ;; V-80-BYTE
13265 2932 CB F8        L2932:  SET     7,B             ; will signal not found
13266 2934
13267 2934              ; the branch was here when checking syntax
13268 2934
13269 2934              ;; V-SYNTAX
13270 2934 D1           L2934:  POP     DE              ; discard the pointer to 2nd. character  v2
13271 2935                                              ; in BASIC line/workspace.
13272 2935
13273 2935 DF                   RST     18H             ; GET-CHAR gets character after variable name.
13274 2936 FE 28                CP      $28             ; is it '(' ?
13275 2938 28 09                JR      Z,L2943         ; forward to V-PASS
13276 293A                                              ; Note. could go straight to V-END ?
13277 293A
13278 293A CB E8                SET     5,B             ; signal not an array
13279 293C 18 0D                JR      L294B           ; forward to V-END
13280 293E
13281 293E              ; ---------------------------
13282 293E
13283 293E              ; the jump was here when a long name matched and HL pointing to last character
13284 293E              ; in variables area.
13285 293E
13286 293E              ;; V-FOUND-1
13287 293E D1           L293E:  POP     DE              ; discard pointer to first var letter
13288 293F
13289 293F              ; the jump was here with all other matches HL points to first var char.
13290 293F
13291 293F              ;; V-FOUND-2
13292 293F D1           L293F:  POP     DE              ; discard pointer to 2nd prog char       v2
13293 2940 D1                   POP     DE              ; drop pointer to 1st prog char          v1
13294 2941 E5                   PUSH    HL              ; save pointer to last char in vars
13295 2942
13296 2942 DF                   RST     18H             ; GET-CHAR
13297 2943
13298 2943              ;; V-PASS
13299 2943 CD 88 2C     L2943:  CALL    L2C88           ; routine ALPHANUM
13300 2946 30 03                JR      NC,L294B        ; forward to V-END if not
13301 2948
13302 2948              ; but it never will be as we advanced past long-named variables earlier.
13303 2948
13304 2948 E7                   RST     20H             ; NEXT-CHAR
13305 2949 18 F8                JR      L2943           ; back to V-PASS
13306 294B
13307 294B              ; ---
13308 294B
13309 294B              ;; V-END
13310 294B E1           L294B:  POP     HL              ; pop the pointer to first character in
13311 294C                                              ; BASIC line/workspace.
13312 294C CB 10                RL      B               ; rotate the B register left
13313 294E                                              ; bit 7 to carry
13314 294E CB 70                BIT     6,B             ; test the array indicator bit.
13315 2950 C9                   RET                     ; return
13316 2951
13317 2951              ; -----------------------
13318 2951              ; Stack function argument
13319 2951              ; -----------------------
13320 2951              ; This branch is taken from LOOK-VARS when a defined function is currently
13321 2951              ; being evaluated.
13322 2951              ; Scanning is evaluating the expression after the '=' and the variable
13323 2951              ; found could be in the argument list to the left of the '=' or in the
13324 2951              ; normal place after the program. Preference will be given to the former.
13325 2951              ; The variable name to be matched is in C.
13326 2951
13327 2951              ;; STK-F-ARG
13328 2951 2A 0B 5C     L2951:  LD      HL,($5C0B)      ; set HL to DEFADD
13329 2954 7E                   LD      A,(HL)          ; load the first character
13330 2955 FE 29                CP      $29             ; is it ')' ?
13331 2957 CA EF 28             JP      Z,L28EF         ; JUMP back to V-RUN/SYN, if so, as there are
13332 295A                                              ; no arguments.
13333 295A
13334 295A              ; but proceed to search argument list of defined function first if not empty.
13335 295A
13336 295A              ;; SFA-LOOP
13337 295A 7E           L295A:  LD      A,(HL)          ; fetch character again.
13338 295B F6 60                OR      $60             ; or with 01100000 presume a simple variable.
13339 295D 47                   LD      B,A             ; save result in B.
13340 295E 23                   INC     HL              ; address next location.
13341 295F 7E                   LD      A,(HL)          ; pick up byte.
13342 2960 FE 0E                CP      $0E             ; is it the number marker ?
13343 2962 28 07                JR      Z,L296B         ; forward to SFA-CP-VR if so.
13344 2964
13345 2964              ; it was a string. White-space may be present but syntax has been checked.
13346 2964
13347 2964 2B                   DEC     HL              ; point back to letter.
13348 2965 CD AB 28             CALL    L28AB           ; routine FN-SKPOVR skips to the '$'
13349 2968 23                   INC     HL              ; now address the hidden marker.
13350 2969 CB A8                RES     5,B             ; signal a string variable.
13351 296B
13352 296B              ;; SFA-CP-VR
13353 296B 78           L296B:  LD      A,B             ; transfer found variable letter to A.
13354 296C B9                   CP      C               ; compare with expected.
13355 296D 28 12                JR      Z,L2981         ; forward to SFA-MATCH with a match.
13356 296F
13357 296F 23                   INC     HL              ; step
13358 2970 23                   INC     HL              ; past
13359 2971 23                   INC     HL              ; the
13360 2972 23                   INC     HL              ; five
13361 2973 23                   INC     HL              ; bytes.
13362 2974
13363 2974 CD AB 28             CALL    L28AB           ; routine FN-SKPOVR skips to next character
13364 2977 FE 29                CP      $29             ; is it ')' ?
13365 2979 CA EF 28             JP      Z,L28EF         ; jump back if so to V-RUN/SYN to look in
13366 297C                                              ; normal variables area.
13367 297C
13368 297C CD AB 28             CALL    L28AB           ; routine FN-SKPOVR skips past the ','
13369 297F                                              ; all syntax has been checked and these
13370 297F                                              ; things can be taken as read.
13371 297F 18 D9                JR      L295A           ; back to SFA-LOOP while there are more
13372 2981                                              ; arguments.
13373 2981
13374 2981              ; ---
13375 2981
13376 2981              ;; SFA-MATCH
13377 2981 CB 69        L2981:  BIT     5,C             ; test if numeric
13378 2983 20 0C                JR      NZ,L2991        ; to SFA-END if so as will be stacked
13379 2985                                              ; by scanning
13380 2985
13381 2985 23                   INC     HL              ; point to start of string descriptor
13382 2986 ED 5B 65 5C          LD      DE,($5C65)      ; set DE to STKEND
13383 298A CD C0 33             CALL    L33C0           ; routine MOVE-FP puts parameters on stack.
13384 298D EB                   EX      DE,HL           ; new free location to HL.
13385 298E 22 65 5C             LD      ($5C65),HL      ; use it to set STKEND system variable.
13386 2991
13387 2991              ;; SFA-END
13388 2991 D1           L2991:  POP     DE              ; discard
13389 2992 D1                   POP     DE              ; pointers.
13390 2993 AF                   XOR     A               ; clear carry flag.
13391 2994 3C                   INC     A               ; and zero flag.
13392 2995 C9                   RET                     ; return.
13393 2996
13394 2996              ; ------------------------
13395 2996              ; Stack variable component
13396 2996              ; ------------------------
13397 2996              ; This is called to evaluate a complex structure that has been found, in
13398 2996              ; runtime, by LOOK-VARS in the variables area.
13399 2996              ; In this case HL points to the initial letter, bits 7-5
13400 2996              ; of which indicate the type of variable.
13401 2996              ; 010 - simple string, 110 - string array, 100 - array of numbers.
13402 2996              ;
13403 2996              ; It is called from CLASS-01 when assigning to a string or array including
13404 2996              ; a slice.
13405 2996              ; It is called from SCANNING to isolate the required part of the structure.
13406 2996              ;
13407 2996              ; An important part of the runtime process is to check that the number of
13408 2996              ; dimensions of the variable match the number of subscripts supplied in the
13409 2996              ; BASIC line.
13410 2996              ;
13411 2996              ; If checking syntax,
13412 2996              ; the B register, which counts dimensions is set to zero (256) to allow
13413 2996              ; the loop to continue till all subscripts are checked. While doing this it
13414 2996              ; is reading dimension sizes from some arbitrary area of memory. Although
13415 2996              ; these are meaningless it is of no concern as the limit is never checked by
13416 2996              ; int-exp during syntax checking.
13417 2996              ;
13418 2996              ; The routine is also called from the syntax path of DIM command to check the
13419 2996              ; syntax of both string and numeric arrays definitions except that bit 6 of C
13420 2996              ; is reset so both are checked as numeric arrays. This ruse avoids a terminal
13421 2996              ; slice being accepted as part of the DIM command.
13422 2996              ; All that is being checked is that there are a valid set of comma-separated
13423 2996              ; expressions before a terminal ')', although, as above, it will still go
13424 2996              ; through the motions of checking dummy dimension sizes.
13425 2996
13426 2996              ;; STK-VAR
13427 2996 AF           L2996:  XOR     A               ; clear A
13428 2997 47                   LD      B,A             ; and B, the syntax dimension counter (256)
13429 2998 CB 79                BIT     7,C             ; checking syntax ?
13430 299A 20 4B                JR      NZ,L29E7        ; forward to SV-COUNT if so.
13431 299C
13432 299C              ; runtime evaluation.
13433 299C
13434 299C CB 7E                BIT     7,(HL)          ; will be reset if a simple string.
13435 299E 20 0E                JR      NZ,L29AE        ; forward to SV-ARRAYS otherwise
13436 29A0
13437 29A0 3C                   INC     A               ; set A to 1, simple string.
13438 29A1
13439 29A1              ;; SV-SIMPLE$
13440 29A1 23           L29A1:  INC     HL              ; address length low
13441 29A2 4E                   LD      C,(HL)          ; place in C
13442 29A3 23                   INC     HL              ; address length high
13443 29A4 46                   LD      B,(HL)          ; place in B
13444 29A5 23                   INC     HL              ; address start of string
13445 29A6 EB                   EX      DE,HL           ; DE = start now.
13446 29A7 CD B2 2A             CALL    L2AB2           ; routine STK-STO-$ stacks string parameters
13447 29AA                                              ; DE start in variables area,
13448 29AA                                              ; BC length, A=1 simple string
13449 29AA
13450 29AA              ; the only thing now is to consider if a slice is required.
13451 29AA
13452 29AA DF                   RST     18H             ; GET-CHAR puts character at CH_ADD in A
13453 29AB C3 49 2A             JP      L2A49           ; jump forward to SV-SLICE? to test for '('
13454 29AE
13455 29AE              ; --------------------------------------------------------
13456 29AE
13457 29AE              ; the branch was here with string and numeric arrays in runtime.
13458 29AE
13459 29AE              ;; SV-ARRAYS
13460 29AE 23           L29AE:  INC     HL              ; step past
13461 29AF 23                   INC     HL              ; the total length
13462 29B0 23                   INC     HL              ; to address Number of dimensions.
13463 29B1 46                   LD      B,(HL)          ; transfer to B overwriting zero.
13464 29B2 CB 71                BIT     6,C             ; a numeric array ?
13465 29B4 28 0A                JR      Z,L29C0         ; forward to SV-PTR with numeric arrays
13466 29B6
13467 29B6 05                   DEC     B               ; ignore the final element of a string array
13468 29B7                                              ; the fixed string size.
13469 29B7
13470 29B7 28 E8                JR      Z,L29A1         ; back to SV-SIMPLE$ if result is zero as has
13471 29B9                                              ; been created with DIM a$(10) for instance
13472 29B9                                              ; and can be treated as a simple string.
13473 29B9
13474 29B9              ; proceed with multi-dimensioned string arrays in runtime.
13475 29B9
13476 29B9 EB                   EX      DE,HL           ; save pointer to dimensions in DE
13477 29BA
13478 29BA DF                   RST     18H             ; GET-CHAR looks at the BASIC line
13479 29BB FE 28                CP      $28             ; is character '(' ?
13480 29BD 20 61                JR      NZ,L2A20        ; to REPORT-3 if not
13481 29BF                                              ; 'Subscript wrong'
13482 29BF
13483 29BF EB                   EX      DE,HL           ; dimensions pointer to HL to synchronize
13484 29C0                                              ; with next instruction.
13485 29C0
13486 29C0              ; runtime numeric arrays path rejoins here.
13487 29C0
13488 29C0              ;; SV-PTR
13489 29C0 EB           L29C0:  EX      DE,HL           ; save dimension pointer in DE
13490 29C1 18 24                JR      L29E7           ; forward to SV-COUNT with true no of dims
13491 29C3                                              ; in B. As there is no initial comma the
13492 29C3                                              ; loop is entered at the midpoint.
13493 29C3
13494 29C3              ; ----------------------------------------------------------
13495 29C3              ; the dimension counting loop which is entered at mid-point.
13496 29C3
13497 29C3              ;; SV-COMMA
13498 29C3 E5           L29C3:  PUSH    HL              ; save counter
13499 29C4
13500 29C4 DF                   RST     18H             ; GET-CHAR
13501 29C5
13502 29C5 E1                   POP     HL              ; pop counter
13503 29C6 FE 2C                CP      $2C             ; is character ',' ?
13504 29C8 28 20                JR      Z,L29EA         ; forward to SV-LOOP if so
13505 29CA
13506 29CA              ; in runtime the variable definition indicates a comma should appear here
13507 29CA
13508 29CA CB 79                BIT     7,C             ; checking syntax ?
13509 29CC 28 52                JR      Z,L2A20         ; forward to REPORT-3 if not
13510 29CE                                              ; 'Subscript error'
13511 29CE
13512 29CE              ; proceed if checking syntax of an array?
13513 29CE
13514 29CE CB 71                BIT     6,C             ; array of strings
13515 29D0 20 06                JR      NZ,L29D8        ; forward to SV-CLOSE if so
13516 29D2
13517 29D2              ; an array of numbers.
13518 29D2
13519 29D2 FE 29                CP      $29             ; is character ')' ?
13520 29D4 20 3C                JR      NZ,L2A12        ; forward to SV-RPT-C if not
13521 29D6                                              ; 'Nonsense in BASIC'
13522 29D6
13523 29D6 E7                   RST     20H             ; NEXT-CHAR moves CH-ADD past the statement
13524 29D7 C9                   RET                     ; return ->
13525 29D8
13526 29D8              ; ---
13527 29D8
13528 29D8              ; the branch was here with an array of strings.
13529 29D8
13530 29D8              ;; SV-CLOSE
13531 29D8 FE 29        L29D8:  CP      $29             ; as above ')' could follow the expression
13532 29DA 28 6C                JR      Z,L2A48         ; forward to SV-DIM if so
13533 29DC
13534 29DC FE CC                CP      $CC             ; is it 'TO' ?
13535 29DE 20 32                JR      NZ,L2A12        ; to SV-RPT-C with anything else
13536 29E0                                              ; 'Nonsense in BASIC'
13537 29E0
13538 29E0              ; now backtrack CH_ADD to set up for slicing routine.
13539 29E0              ; Note. in a BASIC line we can safely backtrack to a colour parameter.
13540 29E0
13541 29E0              ;; SV-CH-ADD
13542 29E0 DF           L29E0:  RST     18H             ; GET-CHAR
13543 29E1 2B                   DEC     HL              ; backtrack HL
13544 29E2 22 5D 5C             LD      ($5C5D),HL      ; to set CH_ADD up for slicing routine
13545 29E5 18 5E                JR      L2A45           ; forward to SV-SLICE and make a return
13546 29E7                                              ; when all slicing complete.
13547 29E7
13548 29E7              ; ----------------------------------------
13549 29E7              ; -> the mid-point entry point of the loop
13550 29E7
13551 29E7              ;; SV-COUNT
13552 29E7 21 00 00     L29E7:  LD      HL,$0000        ; initialize data pointer to zero.
13553 29EA
13554 29EA              ;; SV-LOOP
13555 29EA E5           L29EA:  PUSH    HL              ; save the data pointer.
13556 29EB
13557 29EB E7                   RST     20H             ; NEXT-CHAR in BASIC area points to an
13558 29EC                                              ; expression.
13559 29EC
13560 29EC E1                   POP     HL              ; restore the data pointer.
13561 29ED 79                   LD      A,C             ; transfer name/type to A.
13562 29EE FE C0                CP      $C0             ; is it 11000000 ?
13563 29F0                                              ; Note. the letter component is absent if
13564 29F0                                              ; syntax checking.
13565 29F0 20 09                JR      NZ,L29FB        ; forward to SV-MULT if not an array of
13566 29F2                                              ; strings.
13567 29F2
13568 29F2              ; proceed to check string arrays during syntax.
13569 29F2
13570 29F2 DF                   RST     18H             ; GET-CHAR
13571 29F3 FE 29                CP      $29             ; ')'  end of subscripts ?
13572 29F5 28 51                JR      Z,L2A48         ; forward to SV-DIM to consider further slice
13573 29F7
13574 29F7 FE CC                CP      $CC             ; is it 'TO' ?
13575 29F9 28 E5                JR      Z,L29E0         ; back to SV-CH-ADD to consider a slice.
13576 29FB                                              ; (no need to repeat get-char at L29E0)
13577 29FB
13578 29FB              ; if neither, then an expression is required so rejoin runtime loop ??
13579 29FB              ; registers HL and DE only point to somewhere meaningful in runtime so
13580 29FB              ; comments apply to that situation.
13581 29FB
13582 29FB              ;; SV-MULT
13583 29FB C5           L29FB:  PUSH    BC              ; save dimension number.
13584 29FC E5                   PUSH    HL              ; push data pointer/rubbish.
13585 29FD                                              ; DE points to current dimension.
13586 29FD CD EE 2A             CALL    L2AEE           ; routine DE,(DE+1) gets next dimension in DE
13587 2A00                                              ; and HL points to it.
13588 2A00 E3                   EX      (SP),HL         ; dim pointer to stack, data pointer to HL (*)
13589 2A01 EB                   EX      DE,HL           ; data pointer to DE, dim size to HL.
13590 2A02
13591 2A02 CD CC 2A             CALL    L2ACC           ; routine INT-EXP1 checks integer expression
13592 2A05                                              ; and gets result in BC in runtime.
13593 2A05 38 19                JR      C,L2A20         ; to REPORT-3 if > HL
13594 2A07                                              ; 'Subscript out of range'
13595 2A07
13596 2A07 0B                   DEC     BC              ; adjust returned result from 1-x to 0-x
13597 2A08 CD F4 2A             CALL    L2AF4           ; routine GET-HL*DE multiplies data pointer by
13598 2A0B                                              ; dimension size.
13599 2A0B 09                   ADD     HL,BC           ; add the integer returned by expression.
13600 2A0C D1                   POP     DE              ; pop the dimension pointer.                              ***
13601 2A0D C1                   POP     BC              ; pop dimension counter.
13602 2A0E 10 B3                DJNZ    L29C3           ; back to SV-COMMA if more dimensions
13603 2A10                                              ; Note. during syntax checking, unless there
13604 2A10                                              ; are more than 256 subscripts, the branch
13605 2A10                                              ; back to SV-COMMA is always taken.
13606 2A10
13607 2A10 CB 79                BIT     7,C             ; are we checking syntax ?
13608 2A12                                              ; then we've got a joker here.
13609 2A12
13610 2A12              ;; SV-RPT-C
13611 2A12 20 66        L2A12:  JR      NZ,L2A7A        ; forward to SL-RPT-C if so
13612 2A14                                              ; 'Nonsense in BASIC'
13613 2A14                                              ; more than 256 subscripts in BASIC line.
13614 2A14
13615 2A14              ; but in runtime the number of subscripts are at least the same as dims
13616 2A14
13617 2A14 E5                   PUSH    HL              ; save data pointer.
13618 2A15 CB 71                BIT     6,C             ; is it a string array ?
13619 2A17 20 13                JR      NZ,L2A2C        ; forward to SV-ELEM$ if so.
13620 2A19
13621 2A19              ; a runtime numeric array subscript.
13622 2A19
13623 2A19 42                   LD      B,D             ; register DE has advanced past all dimensions
13624 2A1A 4B                   LD      C,E             ; and points to start of data in variable.
13625 2A1B                                              ; transfer it to BC.
13626 2A1B
13627 2A1B DF                   RST     18H             ; GET-CHAR checks BASIC line
13628 2A1C FE 29                CP      $29             ; must be a ')' ?
13629 2A1E 28 02                JR      Z,L2A22         ; skip to SV-NUMBER if so
13630 2A20
13631 2A20              ; else more subscripts in BASIC line than the variable definition.
13632 2A20
13633 2A20              ;; REPORT-3
13634 2A20 CF           L2A20:  RST     08H             ; ERROR-1
13635 2A21 02                   DEFB    $02             ; Error Report: Subscript wrong
13636 2A22
13637 2A22              ; continue if subscripts matched the numeric array.
13638 2A22
13639 2A22              ;; SV-NUMBER
13640 2A22 E7           L2A22:  RST     20H             ; NEXT-CHAR moves CH_ADD to next statement
13641 2A23                                              ; - finished parsing.
13642 2A23
13643 2A23 E1                   POP     HL              ; pop the data pointer.
13644 2A24 11 05 00             LD      DE,$0005        ; each numeric element is 5 bytes.
13645 2A27 CD F4 2A             CALL    L2AF4           ; routine GET-HL*DE multiplies.
13646 2A2A 09                   ADD     HL,BC           ; now add to start of data in the variable.
13647 2A2B
13648 2A2B C9                   RET                     ; return with HL pointing at the numeric
13649 2A2C                                              ; array subscript.                       ->
13650 2A2C
13651 2A2C              ; ---------------------------------------------------------------
13652 2A2C
13653 2A2C              ; the branch was here for string subscripts when the number of subscripts
13654 2A2C              ; in the BASIC line was one less than in variable definition.
13655 2A2C
13656 2A2C              ;; SV-ELEM$
13657 2A2C CD EE 2A     L2A2C:  CALL    L2AEE           ; routine DE,(DE+1) gets final dimension
13658 2A2F                                              ; the length of strings in this array.
13659 2A2F E3                   EX      (SP),HL         ; start pointer to stack, data pointer to HL.
13660 2A30 CD F4 2A             CALL    L2AF4           ; routine GET-HL*DE multiplies by element
13661 2A33                                              ; size.
13662 2A33 C1                   POP     BC              ; the start of data pointer is added
13663 2A34 09                   ADD     HL,BC           ; in - now points to location before.
13664 2A35 23                   INC     HL              ; point to start of required string.
13665 2A36 42                   LD      B,D             ; transfer the length (final dimension size)
13666 2A37 4B                   LD      C,E             ; from DE to BC.
13667 2A38 EB                   EX      DE,HL           ; put start in DE.
13668 2A39 CD B1 2A             CALL    L2AB1           ; routine STK-ST-0 stores the string parameters
13669 2A3C                                              ; with A=0 - a slice or subscript.
13670 2A3C
13671 2A3C              ; now check that there were no more subscripts in the BASIC line.
13672 2A3C
13673 2A3C DF                   RST     18H             ; GET-CHAR
13674 2A3D FE 29                CP      $29             ; is it ')' ?
13675 2A3F 28 07                JR      Z,L2A48         ; forward to SV-DIM to consider a separate
13676 2A41                                              ; subscript or/and a slice.
13677 2A41
13678 2A41 FE 2C                CP      $2C             ; a comma is allowed if the final subscript
13679 2A43                                              ; is to be sliced e.g. a$(2,3,4 TO 6).
13680 2A43 20 DB                JR      NZ,L2A20        ; to REPORT-3 with anything else
13681 2A45                                              ; 'Subscript error'
13682 2A45
13683 2A45              ;; SV-SLICE
13684 2A45 CD 52 2A     L2A45:  CALL    L2A52           ; routine SLICING slices the string.
13685 2A48
13686 2A48              ; but a slice of a simple string can itself be sliced.
13687 2A48
13688 2A48              ;; SV-DIM
13689 2A48 E7           L2A48:  RST     20H             ; NEXT-CHAR
13690 2A49
13691 2A49              ;; SV-SLICE?
13692 2A49 FE 28        L2A49:  CP      $28             ; is character '(' ?
13693 2A4B 28 F8                JR      Z,L2A45         ; loop back if so to SV-SLICE
13694 2A4D
13695 2A4D FD CB 01 B6          RES     6,(IY+$01)      ; update FLAGS  - Signal string result
13696 2A51 C9                   RET                     ; and return.
13697 2A52
13698 2A52              ; ---
13699 2A52
13700 2A52              ; The above section deals with the flexible syntax allowed.
13701 2A52              ; DIM a$(3,3,10) can be considered as two dimensional array of ten-character
13702 2A52              ; strings or a 3-dimensional array of characters.
13703 2A52              ; a$(1,1) will return a 10-character string as will a$(1,1,1 TO 10)
13704 2A52              ; a$(1,1,1) will return a single character.
13705 2A52              ; a$(1,1) (1 TO 6) is the same as a$(1,1,1 TO 6)
13706 2A52              ; A slice can itself be sliced ad infinitum
13707 2A52              ; b$ () () () () () () (2 TO 10) (2 TO 9) (3) is the same as b$(5)
13708 2A52
13709 2A52
13710 2A52
13711 2A52              ; -------------------------
13712 2A52              ; Handle slicing of strings
13713 2A52              ; -------------------------
13714 2A52              ; The syntax of string slicing is very natural and it is as well to reflect
13715 2A52              ; on the permutations possible.
13716 2A52              ; a$() and a$( TO ) indicate the entire string although just a$ would do
13717 2A52              ; and would avoid coming here.
13718 2A52              ; h$(16) indicates the single character at position 16.
13719 2A52              ; a$( TO 32) indicates the first 32 characters.
13720 2A52              ; a$(257 TO) indicates all except the first 256 characters.
13721 2A52              ; a$(19000 TO 19999) indicates the thousand characters at position 19000.
13722 2A52              ; Also a$(9 TO 5) returns a null string not an error.
13723 2A52              ; This enables a$(2 TO) to return a null string if the passed string is
13724 2A52              ; of length zero or 1.
13725 2A52              ; A string expression in brackets can be sliced. e.g. (STR$ PI) (3 TO )
13726 2A52              ; We arrived here from SCANNING with CH-ADD pointing to the initial '('
13727 2A52              ; or from above.
13728 2A52
13729 2A52              ;; SLICING
13730 2A52 CD 30 25     L2A52:  CALL    L2530           ; routine SYNTAX-Z
13731 2A55 C4 F1 2B             CALL    NZ,L2BF1        ; routine STK-FETCH fetches parameters of
13732 2A58                                              ; string at runtime, start in DE, length
13733 2A58                                              ; in BC. This could be an array subscript.
13734 2A58
13735 2A58 E7                   RST     20H             ; NEXT-CHAR
13736 2A59 FE 29                CP      $29             ; is it ')' ?     e.g. a$()
13737 2A5B 28 50                JR      Z,L2AAD         ; forward to SL-STORE to store entire string.
13738 2A5D
13739 2A5D D5                   PUSH    DE              ; else save start address of string
13740 2A5E
13741 2A5E AF                   XOR     A               ; clear accumulator to use as a running flag.
13742 2A5F F5                   PUSH    AF              ; and save on stack before any branching.
13743 2A60
13744 2A60 C5                   PUSH    BC              ; save length of string to be sliced.
13745 2A61 11 01 00             LD      DE,$0001        ; default the start point to position 1.
13746 2A64
13747 2A64 DF                   RST     18H             ; GET-CHAR
13748 2A65
13749 2A65 E1                   POP     HL              ; pop length to HL as default end point
13750 2A66                                              ; and limit.
13751 2A66
13752 2A66 FE CC                CP      $CC             ; is it 'TO' ?    e.g. a$( TO 10000)
13753 2A68 28 17                JR      Z,L2A81         ; to SL-SECOND to evaluate second parameter.
13754 2A6A
13755 2A6A F1                   POP     AF              ; pop the running flag.
13756 2A6B
13757 2A6B CD CD 2A             CALL    L2ACD           ; routine INT-EXP2 fetches first parameter.
13758 2A6E
13759 2A6E F5                   PUSH    AF              ; save flag (will be $FF if parameter>limit)
13760 2A6F
13761 2A6F 50                   LD      D,B             ; transfer the start
13762 2A70 59                   LD      E,C             ; to DE overwriting 0001.
13763 2A71 E5                   PUSH    HL              ; save original length.
13764 2A72
13765 2A72 DF                   RST     18H             ; GET-CHAR
13766 2A73 E1                   POP     HL              ; pop the limit length.
13767 2A74 FE CC                CP      $CC             ; is it 'TO' after a start ?
13768 2A76 28 09                JR      Z,L2A81         ; to SL-SECOND to evaluate second parameter
13769 2A78
13770 2A78 FE 29                CP      $29             ; is it ')' ?       e.g. a$(365)
13771 2A7A
13772 2A7A              ;; SL-RPT-C
13773 2A7A C2 8A 1C     L2A7A:  JP      NZ,L1C8A        ; jump to REPORT-C with anything else
13774 2A7D                                              ; 'Nonsense in BASIC'
13775 2A7D
13776 2A7D 62                   LD      H,D             ; copy start
13777 2A7E 6B                   LD      L,E             ; to end - just a one character slice.
13778 2A7F 18 13                JR      L2A94           ; forward to SL-DEFINE.
13779 2A81
13780 2A81              ; ---------------------
13781 2A81
13782 2A81              ;; SL-SECOND
13783 2A81 E5           L2A81:  PUSH    HL              ; save limit length.
13784 2A82
13785 2A82 E7                   RST     20H             ; NEXT-CHAR
13786 2A83
13787 2A83 E1                   POP     HL              ; pop the length.
13788 2A84
13789 2A84 FE 29                CP      $29             ; is character ')' ?        e.g. a$(7 TO )
13790 2A86 28 0C                JR      Z,L2A94         ; to SL-DEFINE using length as end point.
13791 2A88
13792 2A88 F1                   POP     AF              ; else restore flag.
13793 2A89 CD CD 2A             CALL    L2ACD           ; routine INT-EXP2 gets second expression.
13794 2A8C
13795 2A8C F5                   PUSH    AF              ; save the running flag.
13796 2A8D
13797 2A8D DF                   RST     18H             ; GET-CHAR
13798 2A8E
13799 2A8E 60                   LD      H,B             ; transfer second parameter
13800 2A8F 69                   LD      L,C             ; to HL.              e.g. a$(42 to 99)
13801 2A90 FE 29                CP      $29             ; is character a ')' ?
13802 2A92 20 E6                JR      NZ,L2A7A        ; to SL-RPT-C if not
13803 2A94                                              ; 'Nonsense in BASIC'
13804 2A94
13805 2A94              ; we now have start in DE and an end in HL.
13806 2A94
13807 2A94              ;; SL-DEFINE
13808 2A94 F1           L2A94:  POP     AF              ; pop the running flag.
13809 2A95 E3                   EX      (SP),HL         ; put end point on stack, start address to HL
13810 2A96 19                   ADD     HL,DE           ; add address of string to the start point.
13811 2A97 2B                   DEC     HL              ; point to first character of slice.
13812 2A98 E3                   EX      (SP),HL         ; start address to stack, end point to HL (*)
13813 2A99 A7                   AND     A               ; prepare to subtract.
13814 2A9A ED 52                SBC     HL,DE           ; subtract start point from end point.
13815 2A9C 01 00 00             LD      BC,$0000        ; default the length result to zero.
13816 2A9F 38 07                JR      C,L2AA8         ; forward to SL-OVER if start > end.
13817 2AA1
13818 2AA1 23                   INC     HL              ; increment the length for inclusive byte.
13819 2AA2
13820 2AA2 A7                   AND     A               ; now test the running flag.
13821 2AA3 FA 20 2A             JP      M,L2A20         ; jump back to REPORT-3 if $FF.
13822 2AA6                                              ; 'Subscript out of range'
13823 2AA6
13824 2AA6 44                   LD      B,H             ; transfer the length
13825 2AA7 4D                   LD      C,L             ; to BC.
13826 2AA8
13827 2AA8              ;; SL-OVER
13828 2AA8 D1           L2AA8:  POP     DE              ; restore start address from machine stack ***
13829 2AA9 FD CB 01 B6          RES     6,(IY+$01)      ; update FLAGS - signal string result for
13830 2AAD                                              ; syntax.
13831 2AAD
13832 2AAD              ;; SL-STORE
13833 2AAD CD 30 25     L2AAD:  CALL    L2530           ; routine SYNTAX-Z  (UNSTACK-Z?)
13834 2AB0 C8                   RET     Z               ; return if checking syntax.
13835 2AB1                                              ; but continue to store the string in runtime.
13836 2AB1
13837 2AB1              ; ------------------------------------
13838 2AB1              ; other than from above, this routine is called from STK-VAR to stack
13839 2AB1              ; a known string array element.
13840 2AB1              ; ------------------------------------
13841 2AB1
13842 2AB1              ;; STK-ST-0
13843 2AB1 AF           L2AB1:  XOR     A               ; clear to signal a sliced string or element.
13844 2AB2
13845 2AB2              ; -------------------------
13846 2AB2              ; this routine is called from chr$, scrn$ etc. to store a simple string result.
13847 2AB2              ; --------------------------
13848 2AB2
13849 2AB2              ;; STK-STO-$
13850 2AB2 FD CB 01 B6  L2AB2:  RES     6,(IY+$01)      ; update FLAGS - signal string result.
13851 2AB6                                              ; and continue to store parameters of string.
13852 2AB6
13853 2AB6              ; ---------------------------------------
13854 2AB6              ; Pass five registers to calculator stack
13855 2AB6              ; ---------------------------------------
13856 2AB6              ; This subroutine puts five registers on the calculator stack.
13857 2AB6
13858 2AB6              ;; STK-STORE
13859 2AB6 C5           L2AB6:  PUSH    BC              ; save two registers
13860 2AB7 CD A9 33             CALL    L33A9           ; routine TEST-5-SP checks room and puts 5
13861 2ABA                                              ; in BC.
13862 2ABA C1                   POP     BC              ; fetch the saved registers.
13863 2ABB 2A 65 5C             LD      HL,($5C65)      ; make HL point to first empty location STKEND
13864 2ABE 77                   LD      (HL),A          ; place the 5 registers.
13865 2ABF 23                   INC     HL              ;
13866 2AC0 73                   LD      (HL),E          ;
13867 2AC1 23                   INC     HL              ;
13868 2AC2 72                   LD      (HL),D          ;
13869 2AC3 23                   INC     HL              ;
13870 2AC4 71                   LD      (HL),C          ;
13871 2AC5 23                   INC     HL              ;
13872 2AC6 70                   LD      (HL),B          ;
13873 2AC7 23                   INC     HL              ;
13874 2AC8 22 65 5C             LD      ($5C65),HL      ; update system variable STKEND.
13875 2ACB C9                   RET                     ; and return.
13876 2ACC
13877 2ACC              ; -------------------------------------------
13878 2ACC              ; Return result of evaluating next expression
13879 2ACC              ; -------------------------------------------
13880 2ACC              ; This clever routine is used to check and evaluate an integer expression
13881 2ACC              ; which is returned in BC, setting A to $FF, if greater than a limit supplied
13882 2ACC              ; in HL. It is used to check array subscripts, parameters of a string slice
13883 2ACC              ; and the arguments of the DIM command. In the latter case, the limit check
13884 2ACC              ; is not required and H is set to $FF. When checking optional string slice
13885 2ACC              ; parameters, it is entered at the second entry point so as not to disturb
13886 2ACC              ; the running flag A, which may be $00 or $FF from a previous invocation.
13887 2ACC
13888 2ACC              ;; INT-EXP1
13889 2ACC AF           L2ACC:  XOR     A               ; set result flag to zero.
13890 2ACD
13891 2ACD              ; -> The entry point is here if A is used as a running flag.
13892 2ACD
13893 2ACD              ;; INT-EXP2
13894 2ACD D5           L2ACD:  PUSH    DE              ; preserve DE register throughout.
13895 2ACE E5                   PUSH    HL              ; save the supplied limit.
13896 2ACF F5                   PUSH    AF              ; save the flag.
13897 2AD0
13898 2AD0 CD 82 1C             CALL    L1C82           ; routine EXPT-1NUM evaluates expression
13899 2AD3                                              ; at CH_ADD returning if numeric result,
13900 2AD3                                              ; with value on calculator stack.
13901 2AD3
13902 2AD3 F1                   POP     AF              ; pop the flag.
13903 2AD4 CD 30 25             CALL    L2530           ; routine SYNTAX-Z
13904 2AD7 28 12                JR      Z,L2AEB         ; forward to I-RESTORE if checking syntax so
13905 2AD9                                              ; avoiding a comparison with supplied limit.
13906 2AD9
13907 2AD9 F5                   PUSH    AF              ; save the flag.
13908 2ADA
13909 2ADA CD 99 1E             CALL    L1E99           ; routine FIND-INT2 fetches value from
13910 2ADD                                              ; calculator stack to BC producing an error
13911 2ADD                                              ; if too high.
13912 2ADD
13913 2ADD D1                   POP     DE              ; pop the flag to D.
13914 2ADE 78                   LD      A,B             ; test value for zero and reject
13915 2ADF B1                   OR      C               ; as arrays and strings begin at 1.
13916 2AE0 37                   SCF                     ; set carry flag.
13917 2AE1 28 05                JR      Z,L2AE8         ; forward to I-CARRY if zero.
13918 2AE3
13919 2AE3 E1                   POP     HL              ; restore the limit.
13920 2AE4 E5                   PUSH    HL              ; and save.
13921 2AE5 A7                   AND     A               ; prepare to subtract.
13922 2AE6 ED 42                SBC     HL,BC           ; subtract value from limit.
13923 2AE8
13924 2AE8              ;; I-CARRY
13925 2AE8 7A           L2AE8:  LD      A,D             ; move flag to accumulator $00 or $FF.
13926 2AE9 DE 00                SBC     A,$00           ; will set to $FF if carry set.
13927 2AEB
13928 2AEB              ;; I-RESTORE
13929 2AEB E1           L2AEB:  POP     HL              ; restore the limit.
13930 2AEC D1                   POP     DE              ; and DE register.
13931 2AED C9                   RET                     ; return.
13932 2AEE
13933 2AEE
13934 2AEE              ; -----------------------
13935 2AEE              ; LD DE,(DE+1) Subroutine
13936 2AEE              ; -----------------------
13937 2AEE              ; This routine just loads the DE register with the contents of the two
13938 2AEE              ; locations following the location addressed by DE.
13939 2AEE              ; It is used to step along the 16-bit dimension sizes in array definitions.
13940 2AEE              ; Note. Such code is made into subroutines to make programs easier to
13941 2AEE              ; write and it would use less space to include the five instructions in-line.
13942 2AEE              ; However, there are so many exchanges going on at the places this is invoked
13943 2AEE              ; that to implement it in-line would make the code hard to follow.
13944 2AEE              ; It probably had a zippier label though as the intention is to simplify the
13945 2AEE              ; program.
13946 2AEE
13947 2AEE              ;; DE,(DE+1)
13948 2AEE EB           L2AEE:  EX      DE,HL           ;
13949 2AEF 23                   INC     HL              ;
13950 2AF0 5E                   LD      E,(HL)          ;
13951 2AF1 23                   INC     HL              ;
13952 2AF2 56                   LD      D,(HL)          ;
13953 2AF3 C9                   RET                     ;
13954 2AF4
13955 2AF4              ; -------------------
13956 2AF4              ; HL=HL*DE Subroutine
13957 2AF4              ; -------------------
13958 2AF4              ; This routine calls the mathematical routine to multiply HL by DE in runtime.
13959 2AF4              ; It is called from STK-VAR and from DIM. In the latter case syntax is not
13960 2AF4              ; being checked so the entry point could have been at the second CALL
13961 2AF4              ; instruction to save a few clock-cycles.
13962 2AF4
13963 2AF4              ;; GET-HL*DE
13964 2AF4 CD 30 25     L2AF4:  CALL    L2530           ; routine SYNTAX-Z.
13965 2AF7 C8                   RET     Z               ; return if checking syntax.
13966 2AF8
13967 2AF8 CD A9 30             CALL    L30A9           ; routine HL-HL*DE.
13968 2AFB DA 15 1F             JP      C,L1F15         ; jump back to REPORT-4 if over 65535.
13969 2AFE
13970 2AFE C9                   RET                     ; else return with 16-bit result in HL.
13971 2AFF
13972 2AFF              ; -----------------
13973 2AFF              ; THE 'LET' COMMAND
13974 2AFF              ; -----------------
13975 2AFF              ; Sinclair BASIC adheres to the ANSI-78 standard and a LET is required in
13976 2AFF              ; assignments e.g. LET a = 1  :   LET h$ = "hat".
13977 2AFF              ;
13978 2AFF              ; Long names may contain spaces but not colour controls (when assigned).
13979 2AFF              ; a substring can appear to the left of the equals sign.
13980 2AFF
13981 2AFF              ; An earlier mathematician Lewis Carroll may have been pleased that
13982 2AFF              ; 10 LET Babies cannot manage crocodiles = Babies are illogical AND
13983 2AFF              ;    Nobody is despised who can manage a crocodile AND Illogical persons
13984 2AFF              ;    are despised
13985 2AFF              ; does not give the 'Nonsense..' error if the three variables exist.
13986 2AFF              ; I digress.
13987 2AFF
13988 2AFF              ;; LET
13989 2AFF 2A 4D 5C     L2AFF:  LD      HL,($5C4D)      ; fetch system variable DEST to HL.
13990 2B02 FD CB 37 4E          BIT     1,(IY+$37)      ; test FLAGX - handling a new variable ?
13991 2B06 28 5E                JR      Z,L2B66         ; forward to L-EXISTS if not.
13992 2B08
13993 2B08              ; continue for a new variable. DEST points to start in BASIC line.
13994 2B08              ; from the CLASS routines.
13995 2B08
13996 2B08 01 05 00             LD      BC,$0005        ; assume numeric and assign an initial 5 bytes
13997 2B0B
13998 2B0B              ;; L-EACH-CH
13999 2B0B 03           L2B0B:  INC     BC              ; increase byte count for each relevant
14000 2B0C                                              ; character
14001 2B0C
14002 2B0C              ;; L-NO-SP
14003 2B0C 23           L2B0C:  INC     HL              ; increase pointer.
14004 2B0D 7E                   LD      A,(HL)          ; fetch character.
14005 2B0E FE 20                CP      $20             ; is it a space ?
14006 2B10 28 FA                JR      Z,L2B0C         ; back to L-NO-SP is so.
14007 2B12
14008 2B12 30 0B                JR      NC,L2B1F        ; forward to L-TEST-CH if higher.
14009 2B14
14010 2B14 FE 10                CP      $10             ; is it $00 - $0F ?
14011 2B16 38 11                JR      C,L2B29         ; forward to L-SPACES if so.
14012 2B18
14013 2B18 FE 16                CP      $16             ; is it $16 - $1F ?
14014 2B1A 30 0D                JR      NC,L2B29        ; forward to L-SPACES if so.
14015 2B1C
14016 2B1C              ; it was $10 - $15  so step over a colour code.
14017 2B1C
14018 2B1C 23                   INC     HL              ; increase pointer.
14019 2B1D 18 ED                JR      L2B0C           ; loop back to L-NO-SP.
14020 2B1F
14021 2B1F              ; ---
14022 2B1F
14023 2B1F              ; the branch was to here if higher than space.
14024 2B1F
14025 2B1F              ;; L-TEST-CH
14026 2B1F CD 88 2C     L2B1F:  CALL    L2C88           ; routine ALPHANUM sets carry if alphanumeric
14027 2B22 38 E7                JR      C,L2B0B         ; loop back to L-EACH-CH for more if so.
14028 2B24
14029 2B24 FE 24                CP      $24             ; is it '$' ?
14030 2B26 CA C0 2B             JP      Z,L2BC0         ; jump forward if so, to L-NEW$
14031 2B29                                              ; with a new string.
14032 2B29
14033 2B29              ;; L-SPACES
14034 2B29 79           L2B29:  LD      A,C             ; save length lo in A.
14035 2B2A 2A 59 5C             LD      HL,($5C59)      ; fetch E_LINE to HL.
14036 2B2D 2B                   DEC     HL              ; point to location before, the variables
14037 2B2E                                              ; end-marker.
14038 2B2E CD 55 16             CALL    L1655           ; routine MAKE-ROOM creates BC spaces
14039 2B31                                              ; for name and numeric value.
14040 2B31 23                   INC     HL              ; advance to first new location.
14041 2B32 23                   INC     HL              ; then to second.
14042 2B33 EB                   EX      DE,HL           ; set DE to second location.
14043 2B34 D5                   PUSH    DE              ; save this pointer.
14044 2B35 2A 4D 5C             LD      HL,($5C4D)      ; reload HL with DEST.
14045 2B38 1B                   DEC     DE              ; point to first.
14046 2B39 D6 06                SUB     $06             ; subtract six from length_lo.
14047 2B3B 47                   LD      B,A             ; save count in B.
14048 2B3C 28 11                JR      Z,L2B4F         ; forward to L-SINGLE if it was just
14049 2B3E                                              ; one character.
14050 2B3E
14051 2B3E              ; HL points to start of variable name after 'LET' in BASIC line.
14052 2B3E
14053 2B3E              ;; L-CHAR
14054 2B3E 23           L2B3E:  INC     HL              ; increase pointer.
14055 2B3F 7E                   LD      A,(HL)          ; pick up character.
14056 2B40 FE 21                CP      $21             ; is it space or higher ?
14057 2B42 38 FA                JR      C,L2B3E         ; back to L-CHAR with space and less.
14058 2B44
14059 2B44 F6 20                OR      $20             ; make variable lower-case.
14060 2B46 13                   INC     DE              ; increase destination pointer.
14061 2B47 12                   LD      (DE),A          ; and load to edit line.
14062 2B48 10 F4                DJNZ    L2B3E           ; loop back to L-CHAR until B is zero.
14063 2B4A
14064 2B4A F6 80                OR      $80             ; invert the last character.
14065 2B4C 12                   LD      (DE),A          ; and overwrite that in edit line.
14066 2B4D
14067 2B4D              ; now consider first character which has bit 6 set
14068 2B4D
14069 2B4D 3E C0                LD      A,$C0           ; set A 11000000 is xor mask for a long name.
14070 2B4F                                              ; %101      is xor/or  result
14071 2B4F
14072 2B4F              ; single character numerics rejoin here with %00000000 in mask.
14073 2B4F              ;                                            %011      will be xor/or result
14074 2B4F
14075 2B4F              ;; L-SINGLE
14076 2B4F 2A 4D 5C     L2B4F:  LD      HL,($5C4D)      ; fetch DEST - HL addresses first character.
14077 2B52 AE                   XOR     (HL)            ; apply variable type indicator mask (above).
14078 2B53 F6 20                OR      $20             ; make lowercase - set bit 5.
14079 2B55 E1                   POP     HL              ; restore pointer to 2nd character.
14080 2B56 CD EA 2B             CALL    L2BEA           ; routine L-FIRST puts A in first character.
14081 2B59                                              ; and returns with HL holding
14082 2B59                                              ; new E_LINE-1  the $80 vars end-marker.
14083 2B59
14084 2B59              ;; L-NUMERIC
14085 2B59 E5           L2B59:  PUSH    HL              ; save the pointer.
14086 2B5A
14087 2B5A              ; the value of variable is deleted but remains after calculator stack.
14088 2B5A
14089 2B5A EF                   RST     28H             ;; FP-CALC
14090 2B5B 02                   DEFB    $02             ;;delete      ; delete variable value
14091 2B5C 38                   DEFB    $38             ;;end-calc
14092 2B5D
14093 2B5D              ; DE (STKEND) points to start of value.
14094 2B5D
14095 2B5D E1                   POP     HL              ; restore the pointer.
14096 2B5E 01 05 00             LD      BC,$0005        ; start of number is five bytes before.
14097 2B61 A7                   AND     A               ; prepare for true subtraction.
14098 2B62 ED 42                SBC     HL,BC           ; HL points to start of value.
14099 2B64 18 40                JR      L2BA6           ; forward to L-ENTER  ==>
14100 2B66
14101 2B66              ; ---
14102 2B66
14103 2B66
14104 2B66              ; the jump was to here if the variable already existed.
14105 2B66
14106 2B66              ;; L-EXISTS
14107 2B66 FD CB 01 76  L2B66:  BIT     6,(IY+$01)      ; test FLAGS - numeric or string result ?
14108 2B6A 28 06                JR      Z,L2B72         ; skip forward to L-DELETE$   -*->
14109 2B6C                                              ; if string result.
14110 2B6C
14111 2B6C              ; A numeric variable could be simple or an array element.
14112 2B6C              ; They are treated the same and the old value is overwritten.
14113 2B6C
14114 2B6C 11 06 00             LD      DE,$0006        ; six bytes forward points to loc past value.
14115 2B6F 19                   ADD     HL,DE           ; add to start of number.
14116 2B70 18 E7                JR      L2B59           ; back to L-NUMERIC to overwrite value.
14117 2B72
14118 2B72              ; ---
14119 2B72
14120 2B72              ; -*-> the branch was here if a string existed.
14121 2B72
14122 2B72              ;; L-DELETE$
14123 2B72 2A 4D 5C     L2B72:  LD      HL,($5C4D)      ; fetch DEST to HL.
14124 2B75                                              ; (still set from first instruction)
14125 2B75 ED 4B 72 5C          LD      BC,($5C72)      ; fetch STRLEN to BC.
14126 2B79 FD CB 37 46          BIT     0,(IY+$37)      ; test FLAGX - handling a complete simple
14127 2B7D                                              ; string ?
14128 2B7D 20 30                JR      NZ,L2BAF        ; forward to L-ADD$ if so.
14129 2B7F
14130 2B7F              ; must be a string array or a slice in workspace.
14131 2B7F              ; Note. LET a$(3 TO 6) = h$   will assign "hat " if h$ = "hat"
14132 2B7F              ;                                  and    "hats" if h$ = "hatstand".
14133 2B7F              ;
14134 2B7F              ; This is known as Procrustean lengthening and shortening after a
14135 2B7F              ; character Procrustes in Greek legend who made travellers sleep in his bed,
14136 2B7F              ; cutting off their feet or stretching them so they fitted the bed perfectly.
14137 2B7F              ; The bloke was hatstand and slain by Theseus.
14138 2B7F
14139 2B7F 78                   LD      A,B             ; test if length
14140 2B80 B1                   OR      C               ; is zero and
14141 2B81 C8                   RET     Z               ; return if so.
14142 2B82
14143 2B82 E5                   PUSH    HL              ; save pointer to start.
14144 2B83
14145 2B83 F7                   RST     30H             ; BC-SPACES creates room.
14146 2B84 D5                   PUSH    DE              ; save pointer to first new location.
14147 2B85 C5                   PUSH    BC              ; and length            (*)
14148 2B86 54                   LD      D,H             ; set DE to point to last location.
14149 2B87 5D                   LD      E,L             ;
14150 2B88 23                   INC     HL              ; set HL to next location.
14151 2B89 36 20                LD      (HL),$20        ; place a space there.
14152 2B8B ED B8                LDDR                    ; copy bytes filling with spaces.
14153 2B8D
14154 2B8D E5                   PUSH    HL              ; save pointer to start.
14155 2B8E CD F1 2B             CALL    L2BF1           ; routine STK-FETCH start to DE,
14156 2B91                                              ; length to BC.
14157 2B91 E1                   POP     HL              ; restore the pointer.
14158 2B92 E3                   EX      (SP),HL         ; (*) length to HL, pointer to stack.
14159 2B93 A7                   AND     A               ; prepare for true subtraction.
14160 2B94 ED 42                SBC     HL,BC           ; subtract old length from new.
14161 2B96 09                   ADD     HL,BC           ; and add back.
14162 2B97 30 02                JR      NC,L2B9B        ; forward if it fits to L-LENGTH.
14163 2B99
14164 2B99 44                   LD      B,H             ; otherwise set
14165 2B9A 4D                   LD      C,L             ; length to old length.
14166 2B9B                                              ; "hatstand" becomes "hats"
14167 2B9B
14168 2B9B              ;; L-LENGTH
14169 2B9B E3           L2B9B:  EX      (SP),HL         ; (*) length to stack, pointer to HL.
14170 2B9C EB                   EX      DE,HL           ; pointer to DE, start of string to HL.
14171 2B9D 78                   LD      A,B             ; is the length zero ?
14172 2B9E B1                   OR      C               ;
14173 2B9F 28 02                JR      Z,L2BA3         ; forward to L-IN-W/S if so
14174 2BA1                                              ; leaving prepared spaces.
14175 2BA1
14176 2BA1 ED B0                LDIR                    ; else copy bytes overwriting some spaces.
14177 2BA3
14178 2BA3              ;; L-IN-W/S
14179 2BA3 C1           L2BA3:  POP     BC              ; pop the new length.  (*)
14180 2BA4 D1                   POP     DE              ; pop pointer to new area.
14181 2BA5 E1                   POP     HL              ; pop pointer to variable in assignment.
14182 2BA6                                              ; and continue copying from workspace
14183 2BA6                                              ; to variables area.
14184 2BA6
14185 2BA6              ; ==> branch here from  L-NUMERIC
14186 2BA6
14187 2BA6              ;; L-ENTER
14188 2BA6 EB           L2BA6:  EX      DE,HL           ; exchange pointers HL=STKEND DE=end of vars.
14189 2BA7 78                   LD      A,B             ; test the length
14190 2BA8 B1                   OR      C               ; and make a
14191 2BA9 C8                   RET     Z               ; return if zero (strings only).
14192 2BAA
14193 2BAA D5                   PUSH    DE              ; save start of destination.
14194 2BAB ED B0                LDIR                    ; copy bytes.
14195 2BAD E1                   POP     HL              ; address the start.
14196 2BAE C9                   RET                     ; and return.
14197 2BAF
14198 2BAF              ; ---
14199 2BAF
14200 2BAF              ; the branch was here from L-DELETE$ if an existing simple string.
14201 2BAF              ; register HL addresses start of string in variables area.
14202 2BAF
14203 2BAF              ;; L-ADD$
14204 2BAF 2B           L2BAF:  DEC     HL              ; point to high byte of length.
14205 2BB0 2B                   DEC     HL              ; to low byte.
14206 2BB1 2B                   DEC     HL              ; to letter.
14207 2BB2 7E                   LD      A,(HL)          ; fetch masked letter to A.
14208 2BB3 E5                   PUSH    HL              ; save the pointer on stack.
14209 2BB4 C5                   PUSH    BC              ; save new length.
14210 2BB5 CD C6 2B             CALL    L2BC6           ; routine L-STRING adds new string at end
14211 2BB8                                              ; of variables area.
14212 2BB8                                              ; if no room we still have old one.
14213 2BB8 C1                   POP     BC              ; restore length.
14214 2BB9 E1                   POP     HL              ; restore start.
14215 2BBA 03                   INC     BC              ; increase
14216 2BBB 03                   INC     BC              ; length by three
14217 2BBC 03                   INC     BC              ; to include character and length bytes.
14218 2BBD C3 E8 19             JP      L19E8           ; jump to indirect exit via RECLAIM-2
14219 2BC0                                              ; deleting old version and adjusting pointers.
14220 2BC0
14221 2BC0              ; ---
14222 2BC0
14223 2BC0              ; the jump was here with a new string variable.
14224 2BC0
14225 2BC0              ;; L-NEW$
14226 2BC0 3E DF        L2BC0:  LD      A,$DF           ; indicator mask %11011111 for
14227 2BC2                                              ;                %010xxxxx will be result
14228 2BC2 2A 4D 5C             LD      HL,($5C4D)      ; address DEST first character.
14229 2BC5 A6                   AND     (HL)            ; combine mask with character.
14230 2BC6
14231 2BC6              ;; L-STRING
14232 2BC6 F5           L2BC6:  PUSH    AF              ; save first character and mask.
14233 2BC7 CD F1 2B             CALL    L2BF1           ; routine STK-FETCH fetches parameters of
14234 2BCA                                              ; the string.
14235 2BCA EB                   EX      DE,HL           ; transfer start to HL.
14236 2BCB 09                   ADD     HL,BC           ; add to length.
14237 2BCC C5                   PUSH    BC              ; save the length.
14238 2BCD 2B                   DEC     HL              ; point to end of string.
14239 2BCE 22 4D 5C             LD      ($5C4D),HL      ; save pointer in DEST.
14240 2BD1                                              ; (updated by POINTERS if in workspace)
14241 2BD1 03                   INC     BC              ; extra byte for letter.
14242 2BD2 03                   INC     BC              ; two bytes
14243 2BD3 03                   INC     BC              ; for the length of string.
14244 2BD4 2A 59 5C             LD      HL,($5C59)      ; address E_LINE.
14245 2BD7 2B                   DEC     HL              ; now end of VARS area.
14246 2BD8 CD 55 16             CALL    L1655           ; routine MAKE-ROOM makes room for string.
14247 2BDB                                              ; updating pointers including DEST.
14248 2BDB 2A 4D 5C             LD      HL,($5C4D)      ; pick up pointer to end of string from DEST.
14249 2BDE C1                   POP     BC              ; restore length from stack.
14250 2BDF C5                   PUSH    BC              ; and save again on stack.
14251 2BE0 03                   INC     BC              ; add a byte.
14252 2BE1 ED B8                LDDR                    ; copy bytes from end to start.
14253 2BE3 EB                   EX      DE,HL           ; HL addresses length low
14254 2BE4 23                   INC     HL              ; increase to address high byte
14255 2BE5 C1                   POP     BC              ; restore length to BC
14256 2BE6 70                   LD      (HL),B          ; insert high byte
14257 2BE7 2B                   DEC     HL              ; address low byte location
14258 2BE8 71                   LD      (HL),C          ; insert that byte
14259 2BE9 F1                   POP     AF              ; restore character and mask
14260 2BEA
14261 2BEA              ;; L-FIRST
14262 2BEA 2B           L2BEA:  DEC     HL              ; address variable name
14263 2BEB 77                   LD      (HL),A          ; and insert character.
14264 2BEC 2A 59 5C             LD      HL,($5C59)      ; load HL with E_LINE.
14265 2BEF 2B                   DEC     HL              ; now end of VARS area.
14266 2BF0 C9                   RET                     ; return
14267 2BF1
14268 2BF1              ; ------------------------------------
14269 2BF1              ; Get last value from calculator stack
14270 2BF1              ; ------------------------------------
14271 2BF1              ;
14272 2BF1              ;
14273 2BF1
14274 2BF1              ;; STK-FETCH
14275 2BF1 2A 65 5C     L2BF1:  LD      HL,($5C65)      ; STKEND
14276 2BF4 2B                   DEC     HL              ;
14277 2BF5 46                   LD      B,(HL)          ;
14278 2BF6 2B                   DEC     HL              ;
14279 2BF7 4E                   LD      C,(HL)          ;
14280 2BF8 2B                   DEC     HL              ;
14281 2BF9 56                   LD      D,(HL)          ;
14282 2BFA 2B                   DEC     HL              ;
14283 2BFB 5E                   LD      E,(HL)          ;
14284 2BFC 2B                   DEC     HL              ;
14285 2BFD 7E                   LD      A,(HL)          ;
14286 2BFE 22 65 5C             LD      ($5C65),HL      ; STKEND
14287 2C01 C9                   RET                     ;
14288 2C02
14289 2C02              ; ------------------
14290 2C02              ; Handle DIM command
14291 2C02              ; ------------------
14292 2C02              ; e.g. DIM a(2,3,4,7): DIM a$(32) : DIM b$(20,2,768) : DIM c$(20000)
14293 2C02              ; the only limit to dimensions is memory so, for example,
14294 2C02              ; DIM a(2,2,2,2,2,2,2,2,2,2,2,2,2) is possible and creates a multi-
14295 2C02              ; dimensional array of zeros. String arrays are initialized to spaces.
14296 2C02              ; It is not possible to erase an array, but it can be re-dimensioned to
14297 2C02              ; a minimal size of 1, after use, to free up memory.
14298 2C02
14299 2C02              ;; DIM
14300 2C02 CD B2 28     L2C02:  CALL    L28B2           ; routine LOOK-VARS
14301 2C05
14302 2C05              ;; D-RPORT-C
14303 2C05 C2 8A 1C     L2C05:  JP      NZ,L1C8A        ; jump to REPORT-C if a long-name variable.
14304 2C08                                              ; DIM lottery numbers(49) doesn't work.
14305 2C08
14306 2C08 CD 30 25             CALL    L2530           ; routine SYNTAX-Z
14307 2C0B 20 08                JR      NZ,L2C15        ; forward to D-RUN in runtime.
14308 2C0D
14309 2C0D CB B1                RES     6,C             ; signal 'numeric' array even if string as
14310 2C0F                                              ; this simplifies the syntax checking.
14311 2C0F
14312 2C0F CD 96 29             CALL    L2996           ; routine STK-VAR checks syntax.
14313 2C12 CD EE 1B             CALL    L1BEE           ; routine CHECK-END performs early exit ->
14314 2C15
14315 2C15              ; the branch was here in runtime.
14316 2C15
14317 2C15              ;; D-RUN
14318 2C15 38 08        L2C15:  JR      C,L2C1F         ; skip to D-LETTER if variable did not exist.
14319 2C17                                              ; else reclaim the old one.
14320 2C17
14321 2C17 C5                   PUSH    BC              ; save type in C.
14322 2C18 CD B8 19             CALL    L19B8           ; routine NEXT-ONE find following variable
14323 2C1B                                              ; or position of $80 end-marker.
14324 2C1B CD E8 19             CALL    L19E8           ; routine RECLAIM-2 reclaims the
14325 2C1E                                              ; space between.
14326 2C1E C1                   POP     BC              ; pop the type.
14327 2C1F
14328 2C1F              ;; D-LETTER
14329 2C1F CB F9        L2C1F:  SET     7,C             ; signal array.
14330 2C21 06 00                LD      B,$00           ; initialize dimensions to zero and
14331 2C23 C5                   PUSH    BC              ; save with the type.
14332 2C24 21 01 00             LD      HL,$0001        ; make elements one character presuming string
14333 2C27 CB 71                BIT     6,C             ; is it a string ?
14334 2C29 20 02                JR      NZ,L2C2D        ; forward to D-SIZE if so.
14335 2C2B
14336 2C2B 2E 05                LD      L,$05           ; make elements 5 bytes as is numeric.
14337 2C2D
14338 2C2D              ;; D-SIZE
14339 2C2D EB           L2C2D:  EX      DE,HL           ; save the element size in DE.
14340 2C2E
14341 2C2E              ; now enter a loop to parse each of the integers in the list.
14342 2C2E
14343 2C2E              ;; D-NO-LOOP
14344 2C2E E7           L2C2E:  RST     20H             ; NEXT-CHAR
14345 2C2F 26 FF                LD      H,$FF           ; disable limit check by setting HL high
14346 2C31 CD CC 2A             CALL    L2ACC           ; routine INT-EXP1
14347 2C34 DA 20 2A             JP      C,L2A20         ; to REPORT-3 if > 65280 and then some
14348 2C37                                              ; 'Subscript out of range'
14349 2C37
14350 2C37 E1                   POP     HL              ; pop dimension counter, array type
14351 2C38 C5                   PUSH    BC              ; save dimension size                     ***
14352 2C39 24                   INC     H               ; increment the dimension counter
14353 2C3A E5                   PUSH    HL              ; save the dimension counter
14354 2C3B 60                   LD      H,B             ; transfer size
14355 2C3C 69                   LD      L,C             ; to HL
14356 2C3D CD F4 2A             CALL    L2AF4           ; routine GET-HL*DE multiplies dimension by
14357 2C40                                              ; running total of size required initially
14358 2C40                                              ; 1 or 5.
14359 2C40 EB                   EX      DE,HL           ; save running total in DE
14360 2C41
14361 2C41 DF                   RST     18H             ; GET-CHAR
14362 2C42 FE 2C                CP      $2C             ; is it ',' ?
14363 2C44 28 E8                JR      Z,L2C2E         ; loop back to D-NO-LOOP until all dimensions
14364 2C46                                              ; have been considered
14365 2C46
14366 2C46              ; when loop complete continue.
14367 2C46
14368 2C46 FE 29                CP      $29             ; is it ')' ?
14369 2C48 20 BB                JR      NZ,L2C05        ; to D-RPORT-C with anything else
14370 2C4A                                              ; 'Nonsense in BASIC'
14371 2C4A
14372 2C4A
14373 2C4A E7                   RST     20H             ; NEXT-CHAR advances to next statement/CR
14374 2C4B
14375 2C4B C1                   POP     BC              ; pop dimension counter/type
14376 2C4C 79                   LD      A,C             ; type to A
14377 2C4D
14378 2C4D              ; now calculate space required for array variable
14379 2C4D
14380 2C4D 68                   LD      L,B             ; dimensions to L since these require 16 bits
14381 2C4E                                              ; then this value will be doubled
14382 2C4E 26 00                LD      H,$00           ; set high byte to zero
14383 2C50
14384 2C50              ; another four bytes are required for letter(1), total length(2), number of
14385 2C50              ; dimensions(1) but since we have yet to double allow for two
14386 2C50
14387 2C50 23                   INC     HL              ; increment
14388 2C51 23                   INC     HL              ; increment
14389 2C52
14390 2C52 29                   ADD     HL,HL           ; now double giving 4 + dimensions * 2
14391 2C53
14392 2C53 19                   ADD     HL,DE           ; add to space required for array contents
14393 2C54
14394 2C54 DA 15 1F             JP      C,L1F15         ; to REPORT-4 if > 65535
14395 2C57                                              ; 'Out of memory'
14396 2C57
14397 2C57 D5                   PUSH    DE              ; save data space
14398 2C58 C5                   PUSH    BC              ; save dimensions/type
14399 2C59 E5                   PUSH    HL              ; save total space
14400 2C5A 44                   LD      B,H             ; total space
14401 2C5B 4D                   LD      C,L             ; to BC
14402 2C5C 2A 59 5C             LD      HL,($5C59)      ; address E_LINE - first location after
14403 2C5F                                              ; variables area
14404 2C5F 2B                   DEC     HL              ; point to location before - the $80 end-marker
14405 2C60 CD 55 16             CALL    L1655           ; routine MAKE-ROOM creates the space if
14406 2C63                                              ; memory is available.
14407 2C63
14408 2C63 23                   INC     HL              ; point to first new location and
14409 2C64 77                   LD      (HL),A          ; store letter/type
14410 2C65
14411 2C65 C1                   POP     BC              ; pop total space
14412 2C66 0B                   DEC     BC              ; exclude name
14413 2C67 0B                   DEC     BC              ; exclude the 16-bit
14414 2C68 0B                   DEC     BC              ; counter itself
14415 2C69 23                   INC     HL              ; point to next location the 16-bit counter
14416 2C6A 71                   LD      (HL),C          ; insert low byte
14417 2C6B 23                   INC     HL              ; address next
14418 2C6C 70                   LD      (HL),B          ; insert high byte
14419 2C6D
14420 2C6D C1                   POP     BC              ; pop the number of dimensions.
14421 2C6E 78                   LD      A,B             ; dimensions to A
14422 2C6F 23                   INC     HL              ; address next
14423 2C70 77                   LD      (HL),A          ; and insert "No. of dims"
14424 2C71
14425 2C71 62                   LD      H,D             ; transfer DE space + 1 from make-room
14426 2C72 6B                   LD      L,E             ; to HL
14427 2C73 1B                   DEC     DE              ; set DE to next location down.
14428 2C74 36 00                LD      (HL),$00        ; presume numeric and insert a zero
14429 2C76 CB 71                BIT     6,C             ; test bit 6 of C. numeric or string ?
14430 2C78 28 02                JR      Z,L2C7C         ; skip to DIM-CLEAR if numeric
14431 2C7A
14432 2C7A 36 20                LD      (HL),$20        ; place a space character in HL
14433 2C7C
14434 2C7C              ;; DIM-CLEAR
14435 2C7C C1           L2C7C:  POP     BC              ; pop the data length
14436 2C7D
14437 2C7D ED B8                LDDR                    ; LDDR sets to zeros or spaces
14438 2C7F
14439 2C7F              ; The number of dimensions is still in A.
14440 2C7F              ; A loop is now entered to insert the size of each dimension that was pushed
14441 2C7F              ; during the D-NO-LOOP working downwards from position before start of data.
14442 2C7F
14443 2C7F              ;; DIM-SIZES
14444 2C7F C1           L2C7F:  POP     BC              ; pop a dimension size                    ***
14445 2C80 70                   LD      (HL),B          ; insert high byte at position
14446 2C81 2B                   DEC     HL              ; next location down
14447 2C82 71                   LD      (HL),C          ; insert low byte
14448 2C83 2B                   DEC     HL              ; next location down
14449 2C84 3D                   DEC     A               ; decrement dimension counter
14450 2C85 20 F8                JR      NZ,L2C7F        ; back to DIM-SIZES until all done.
14451 2C87
14452 2C87 C9                   RET                     ; return.
14453 2C88
14454 2C88              ; -----------------------------
14455 2C88              ; Check whether digit or letter
14456 2C88              ; -----------------------------
14457 2C88              ; This routine checks that the character in A is alphanumeric
14458 2C88              ; returning with carry set if so.
14459 2C88
14460 2C88              ;; ALPHANUM
14461 2C88 CD 1B 2D     L2C88:  CALL    L2D1B           ; routine NUMERIC will reset carry if so.
14462 2C8B 3F                   CCF                     ; Complement Carry Flag
14463 2C8C D8                   RET     C               ; Return if numeric else continue into
14464 2C8D                                              ; next routine.
14465 2C8D
14466 2C8D              ; This routine checks that the character in A is alphabetic
14467 2C8D
14468 2C8D              ;; ALPHA
14469 2C8D FE 41        L2C8D:  CP      $41             ; less than 'A' ?
14470 2C8F 3F                   CCF                     ; Complement Carry Flag
14471 2C90 D0                   RET     NC              ; return if so
14472 2C91
14473 2C91 FE 5B                CP      $5B             ; less than 'Z'+1 ?
14474 2C93 D8                   RET     C               ; is within first range
14475 2C94
14476 2C94 FE 61                CP      $61             ; less than 'a' ?
14477 2C96 3F                   CCF                     ; Complement Carry Flag
14478 2C97 D0                   RET     NC              ; return if so.
14479 2C98
14480 2C98 FE 7B                CP      $7B             ; less than 'z'+1 ?
14481 2C9A C9                   RET                     ; carry set if within a-z.
14482 2C9B
14483 2C9B              ; -------------------------
14484 2C9B              ; Decimal to floating point
14485 2C9B              ; -------------------------
14486 2C9B              ; This routine finds the floating point number represented by an expression
14487 2C9B              ; beginning with BIN, '.' or a digit.
14488 2C9B              ; Note that BIN need not have any '0's or '1's after it.
14489 2C9B              ; BIN is really just a notational symbol and not a function.
14490 2C9B
14491 2C9B              ;; DEC-TO-FP
14492 2C9B FE C4        L2C9B:  CP      $C4             ; 'BIN' token ?
14493 2C9D 20 19                JR      NZ,L2CB8        ; to NOT-BIN if not
14494 2C9F
14495 2C9F 11 00 00             LD      DE,$0000        ; initialize 16 bit buffer register.
14496 2CA2
14497 2CA2              ;; BIN-DIGIT
14498 2CA2 E7           L2CA2:  RST     20H             ; NEXT-CHAR
14499 2CA3 D6 31                SUB     $31             ; '1'
14500 2CA5 CE 00                ADC     A,$00           ; will be zero if '1' or '0'
14501 2CA7                                              ; carry will be set if was '0'
14502 2CA7 20 0A                JR      NZ,L2CB3        ; forward to BIN-END if result not zero
14503 2CA9
14504 2CA9 EB                   EX      DE,HL           ; buffer to HL
14505 2CAA 3F                   CCF                     ; Carry now set if originally '1'
14506 2CAB ED 6A                ADC     HL,HL           ; shift the carry into HL
14507 2CAD DA AD 31             JP      C,L31AD         ; to REPORT-6 if overflow - too many digits
14508 2CB0                                              ; after first '1'. There can be an unlimited
14509 2CB0                                              ; number of leading zeros.
14510 2CB0                                              ; 'Number too big' - raise an error
14511 2CB0
14512 2CB0 EB                   EX      DE,HL           ; save the buffer
14513 2CB1 18 EF                JR      L2CA2           ; back to BIN-DIGIT for more digits
14514 2CB3
14515 2CB3              ; ---
14516 2CB3
14517 2CB3              ;; BIN-END
14518 2CB3 42           L2CB3:  LD      B,D             ; transfer 16 bit buffer
14519 2CB4 4B                   LD      C,E             ; to BC register pair.
14520 2CB5 C3 2B 2D             JP      L2D2B           ; JUMP to STACK-BC to put on calculator stack
14521 2CB8
14522 2CB8              ; ---
14523 2CB8
14524 2CB8              ; continue here with .1,  42, 3.14, 5., 2.3 E -4
14525 2CB8
14526 2CB8              ;; NOT-BIN
14527 2CB8 FE 2E        L2CB8:  CP      $2E             ; '.' - leading decimal point ?
14528 2CBA 28 0F                JR      Z,L2CCB         ; skip to DECIMAL if so.
14529 2CBC
14530 2CBC CD 3B 2D             CALL    L2D3B           ; routine INT-TO-FP to evaluate all digits
14531 2CBF                                              ; This number 'x' is placed on stack.
14532 2CBF FE 2E                CP      $2E             ; '.' - mid decimal point ?
14533 2CC1
14534 2CC1 20 28                JR      NZ,L2CEB        ; to E-FORMAT if not to consider that format
14535 2CC3
14536 2CC3 E7                   RST     20H             ; NEXT-CHAR
14537 2CC4 CD 1B 2D             CALL    L2D1B           ; routine NUMERIC returns carry reset if 0-9
14538 2CC7
14539 2CC7 38 22                JR      C,L2CEB         ; to E-FORMAT if not a digit e.g. '1.'
14540 2CC9
14541 2CC9 18 0A                JR      L2CD5           ; to DEC-STO-1 to add the decimal part to 'x'
14542 2CCB
14543 2CCB              ; ---
14544 2CCB
14545 2CCB              ; a leading decimal point has been found in a number.
14546 2CCB
14547 2CCB              ;; DECIMAL
14548 2CCB E7           L2CCB:  RST     20H             ; NEXT-CHAR
14549 2CCC CD 1B 2D             CALL    L2D1B           ; routine NUMERIC will reset carry if digit
14550 2CCF
14551 2CCF              ;; DEC-RPT-C
14552 2CCF DA 8A 1C     L2CCF:  JP      C,L1C8A         ; to REPORT-C if just a '.'
14553 2CD2                                              ; raise 'Nonsense in BASIC'
14554 2CD2
14555 2CD2              ; since there is no leading zero put one on the calculator stack.
14556 2CD2
14557 2CD2 EF                   RST     28H             ;; FP-CALC
14558 2CD3 A0                   DEFB    $A0             ;;stk-zero  ; 0.
14559 2CD4 38                   DEFB    $38             ;;end-calc
14560 2CD5
14561 2CD5              ; If rejoining from earlier there will be a value 'x' on stack.
14562 2CD5              ; If continuing from above the value zero.
14563 2CD5              ; Now store 1 in mem-0.
14564 2CD5              ; Note. At each pass of the digit loop this will be divided by ten.
14565 2CD5
14566 2CD5              ;; DEC-STO-1
14567 2CD5 EF           L2CD5:  RST     28H             ;; FP-CALC
14568 2CD6 A1                   DEFB    $A1             ;;stk-one   ;x or 0,1.
14569 2CD7 C0                   DEFB    $C0             ;;st-mem-0  ;x or 0,1.
14570 2CD8 02                   DEFB    $02             ;;delete    ;x or 0.
14571 2CD9 38                   DEFB    $38             ;;end-calc
14572 2CDA
14573 2CDA
14574 2CDA              ;; NXT-DGT-1
14575 2CDA DF           L2CDA:  RST     18H             ; GET-CHAR
14576 2CDB CD 22 2D             CALL    L2D22           ; routine STK-DIGIT stacks single digit 'd'
14577 2CDE 38 0B                JR      C,L2CEB         ; exit to E-FORMAT when digits exhausted  >
14578 2CE0
14579 2CE0
14580 2CE0 EF                   RST     28H             ;; FP-CALC   ;x or 0,d.           first pass.
14581 2CE1 E0                   DEFB    $E0             ;;get-mem-0  ;x or 0,d,1.
14582 2CE2 A4                   DEFB    $A4             ;;stk-ten    ;x or 0,d,1,10.
14583 2CE3 05                   DEFB    $05             ;;division   ;x or 0,d,1/10.
14584 2CE4 C0                   DEFB    $C0             ;;st-mem-0   ;x or 0,d,1/10.
14585 2CE5 04                   DEFB    $04             ;;multiply   ;x or 0,d/10.
14586 2CE6 0F                   DEFB    $0F             ;;addition   ;x or 0 + d/10.
14587 2CE7 38                   DEFB    $38             ;;end-calc   last value.
14588 2CE8
14589 2CE8 E7                   RST     20H             ; NEXT-CHAR  moves to next character
14590 2CE9 18 EF                JR      L2CDA           ; back to NXT-DGT-1
14591 2CEB
14592 2CEB              ; ---
14593 2CEB
14594 2CEB              ; although only the first pass is shown it can be seen that at each pass
14595 2CEB              ; the new less significant digit is multiplied by an increasingly smaller
14596 2CEB              ; factor (1/100, 1/1000, 1/10000 ... ) before being added to the previous
14597 2CEB              ; last value to form a new last value.
14598 2CEB
14599 2CEB              ; Finally see if an exponent has been input.
14600 2CEB
14601 2CEB              ;; E-FORMAT
14602 2CEB FE 45        L2CEB:  CP      $45             ; is character 'E' ?
14603 2CED 28 03                JR      Z,L2CF2         ; to SIGN-FLAG if so
14604 2CEF
14605 2CEF FE 65                CP      $65             ; 'e' is acceptable as well.
14606 2CF1 C0                   RET     NZ              ; return as no exponent.
14607 2CF2
14608 2CF2              ;; SIGN-FLAG
14609 2CF2 06 FF        L2CF2:  LD      B,$FF           ; initialize temporary sign byte to $FF
14610 2CF4
14611 2CF4 E7                   RST     20H             ; NEXT-CHAR
14612 2CF5 FE 2B                CP      $2B             ; is character '+' ?
14613 2CF7 28 05                JR      Z,L2CFE         ; to SIGN-DONE
14614 2CF9
14615 2CF9 FE 2D                CP      $2D             ; is character '-' ?
14616 2CFB 20 02                JR      NZ,L2CFF        ; to ST-E-PART as no sign
14617 2CFD
14618 2CFD 04                   INC     B               ; set sign to zero
14619 2CFE
14620 2CFE              ; now consider digits of exponent.
14621 2CFE              ; Note. incidentally this is the only occasion in Spectrum BASIC when an
14622 2CFE              ; expression may not be used when a number is expected.
14623 2CFE
14624 2CFE              ;; SIGN-DONE
14625 2CFE E7           L2CFE:  RST     20H             ; NEXT-CHAR
14626 2CFF
14627 2CFF              ;; ST-E-PART
14628 2CFF CD 1B 2D     L2CFF:  CALL    L2D1B           ; routine NUMERIC
14629 2D02 38 CB                JR      C,L2CCF         ; to DEC-RPT-C if not
14630 2D04                                              ; raise 'Nonsense in BASIC'.
14631 2D04
14632 2D04 C5                   PUSH    BC              ; save sign (in B)
14633 2D05 CD 3B 2D             CALL    L2D3B           ; routine INT-TO-FP places exponent on stack
14634 2D08 CD D5 2D             CALL    L2DD5           ; routine FP-TO-A  transfers it to A
14635 2D0B C1                   POP     BC              ; restore sign
14636 2D0C DA AD 31             JP      C,L31AD         ; to REPORT-6 if overflow (over 255)
14637 2D0F                                              ; raise 'Number too big'.
14638 2D0F
14639 2D0F A7                   AND     A               ; set flags
14640 2D10 FA AD 31             JP      M,L31AD         ; to REPORT-6 if over '127'.
14641 2D13                                              ; raise 'Number too big'.
14642 2D13                                              ; 127 is still way too high and it is
14643 2D13                                              ; impossible to enter an exponent greater
14644 2D13                                              ; than 39 from the keyboard. The error gets
14645 2D13                                              ; raised later in E-TO-FP so two different
14646 2D13                                              ; error messages depending how high A is.
14647 2D13
14648 2D13 04                   INC     B               ; $FF to $00 or $00 to $01 - expendable now.
14649 2D14 28 02                JR      Z,L2D18         ; forward to E-FP-JUMP if exponent positive
14650 2D16
14651 2D16 ED 44                NEG                     ; Negate the exponent.
14652 2D18
14653 2D18              ;; E-FP-JUMP
14654 2D18 C3 4F 2D     L2D18:  JP      L2D4F           ; JUMP forward to E-TO-FP to assign to
14655 2D1B                                              ; last value x on stack x * 10 to power A
14656 2D1B                                              ; a relative jump would have done.
14657 2D1B
14658 2D1B              ; ---------------------
14659 2D1B              ; Check for valid digit
14660 2D1B              ; ---------------------
14661 2D1B              ; This routine checks that the ASCII character in A is numeric
14662 2D1B              ; returning with carry reset if so.
14663 2D1B
14664 2D1B              ;; NUMERIC
14665 2D1B FE 30        L2D1B:  CP      $30             ; '0'
14666 2D1D D8                   RET     C               ; return if less than zero character.
14667 2D1E
14668 2D1E FE 3A                CP      $3A             ; The upper test is '9'
14669 2D20 3F                   CCF                     ; Complement Carry Flag
14670 2D21 C9                   RET                     ; Return - carry clear if character '0' - '9'
14671 2D22
14672 2D22              ; -----------
14673 2D22              ; Stack Digit
14674 2D22              ; -----------
14675 2D22              ; This subroutine is called from INT-TO-FP and DEC-TO-FP to stack a digit
14676 2D22              ; on the calculator stack.
14677 2D22
14678 2D22              ;; STK-DIGIT
14679 2D22 CD 1B 2D     L2D22:  CALL    L2D1B           ; routine NUMERIC
14680 2D25 D8                   RET     C               ; return if not numeric character
14681 2D26
14682 2D26 D6 30                SUB     $30             ; convert from ASCII to digit
14683 2D28
14684 2D28              ; -----------------
14685 2D28              ; Stack accumulator
14686 2D28              ; -----------------
14687 2D28              ;
14688 2D28              ;
14689 2D28
14690 2D28              ;; STACK-A
14691 2D28 4F           L2D28:  LD      C,A             ; transfer to C
14692 2D29 06 00                LD      B,$00           ; and make B zero
14693 2D2B
14694 2D2B              ; ----------------------
14695 2D2B              ; Stack BC register pair
14696 2D2B              ; ----------------------
14697 2D2B              ;
14698 2D2B
14699 2D2B              ;; STACK-BC
14700 2D2B FD 21 3A 5C  L2D2B:  LD      IY,$5C3A        ; re-initialize ERR_NR
14701 2D2F
14702 2D2F AF                   XOR     A               ; clear to signal small integer
14703 2D30 5F                   LD      E,A             ; place in E for sign
14704 2D31 51                   LD      D,C             ; LSB to D
14705 2D32 48                   LD      C,B             ; MSB to C
14706 2D33 47                   LD      B,A             ; last byte not used
14707 2D34 CD B6 2A             CALL    L2AB6           ; routine STK-STORE
14708 2D37
14709 2D37 EF                   RST     28H             ;; FP-CALC
14710 2D38 38                   DEFB    $38             ;;end-calc  make HL = STKEND-5
14711 2D39
14712 2D39 A7                   AND     A               ; clear carry
14713 2D3A C9                   RET                     ; before returning
14714 2D3B
14715 2D3B              ; -------------------------
14716 2D3B              ; Integer to floating point
14717 2D3B              ; -------------------------
14718 2D3B              ; This routine places one or more digits found in a BASIC line
14719 2D3B              ; on the calculator stack multiplying the previous value by ten each time
14720 2D3B              ; before adding in the new digit to form a last value on calculator stack.
14721 2D3B
14722 2D3B              ;; INT-TO-FP
14723 2D3B F5           L2D3B:  PUSH    AF              ; save first character
14724 2D3C
14725 2D3C EF                   RST     28H             ;; FP-CALC
14726 2D3D A0                   DEFB    $A0             ;;stk-zero    ; v=0. initial value
14727 2D3E 38                   DEFB    $38             ;;end-calc
14728 2D3F
14729 2D3F F1                   POP     AF              ; fetch first character back.
14730 2D40
14731 2D40              ;; NXT-DGT-2
14732 2D40 CD 22 2D     L2D40:  CALL    L2D22           ; routine STK-DIGIT puts 0-9 on stack
14733 2D43 D8                   RET     C               ; will return when character is not numeric >
14734 2D44
14735 2D44 EF                   RST     28H             ;; FP-CALC    ; v, d.
14736 2D45 01                   DEFB    $01             ;;exchange    ; d, v.
14737 2D46 A4                   DEFB    $A4             ;;stk-ten     ; d, v, 10.
14738 2D47 04                   DEFB    $04             ;;multiply    ; d, v*10.
14739 2D48 0F                   DEFB    $0F             ;;addition    ; d + v*10 = newvalue
14740 2D49 38                   DEFB    $38             ;;end-calc    ; v.
14741 2D4A
14742 2D4A CD 74 00             CALL    L0074           ; routine CH-ADD+1 get next character
14743 2D4D 18 F1                JR      L2D40           ; back to NXT-DGT-2 to process as a digit
14744 2D4F
14745 2D4F
14746 2D4F              ;*********************************
14747 2D4F              ;** Part 9. ARITHMETIC ROUTINES **
14748 2D4F              ;*********************************
14749 2D4F
14750 2D4F              ; --------------------------
14751 2D4F              ; E-format to floating point
14752 2D4F              ; --------------------------
14753 2D4F              ; This subroutine is used by the PRINT-FP routine and the decimal to FP
14754 2D4F              ; routines to stack a number expressed in exponent format.
14755 2D4F              ; Note. Though not used by the ROM as such, it has also been set up as
14756 2D4F              ; a unary calculator literal but this will not work as the accumulator
14757 2D4F              ; is not available from within the calculator.
14758 2D4F
14759 2D4F              ; on entry there is a value x on the calculator stack and an exponent of ten
14760 2D4F              ; in A.    The required value is x + 10 ^ A
14761 2D4F
14762 2D4F              ;; e-to-fp
14763 2D4F              ;; E-TO-FP
14764 2D4F 07           L2D4F:  RLCA                    ; this will set the          x.
14765 2D50 0F                   RRCA                    ; carry if bit 7 is set
14766 2D51
14767 2D51 30 02                JR      NC,L2D55        ; to E-SAVE  if positive.
14768 2D53
14769 2D53 2F                   CPL                     ; make negative positive
14770 2D54 3C                   INC     A               ; without altering carry.
14771 2D55
14772 2D55              ;; E-SAVE
14773 2D55 F5           L2D55:  PUSH    AF              ; save positive exp and sign in carry
14774 2D56
14775 2D56 21 92 5C             LD      HL,$5C92        ; address MEM-0
14776 2D59
14777 2D59 CD 0B 35             CALL    L350B           ; routine FP-0/1
14778 2D5C                                              ; places an integer zero, if no carry,
14779 2D5C                                              ; else a one in mem-0 as a sign flag
14780 2D5C
14781 2D5C EF                   RST     28H             ;; FP-CALC
14782 2D5D A4                   DEFB    $A4             ;;stk-ten                    x, 10.
14783 2D5E 38                   DEFB    $38             ;;end-calc
14784 2D5F
14785 2D5F F1                   POP     AF              ; pop the exponent.
14786 2D60
14787 2D60              ; now enter a loop
14788 2D60
14789 2D60              ;; E-LOOP
14790 2D60 CB 3F        L2D60:  SRL     A               ; 0>76543210>C
14791 2D62
14792 2D62 30 0D                JR      NC,L2D71        ; forward to E-TST-END if no bit
14793 2D64
14794 2D64 F5                   PUSH    AF              ; save shifted exponent.
14795 2D65
14796 2D65 EF                   RST     28H             ;; FP-CALC
14797 2D66 C1                   DEFB    $C1             ;;st-mem-1                   x, 10.
14798 2D67 E0                   DEFB    $E0             ;;get-mem-0                  x, 10, (0/1).
14799 2D68 00                   DEFB    $00             ;;jump-true
14800 2D69
14801 2D69 04                   DEFB    $04             ;;to L2D6D, E-DIVSN
14802 2D6A
14803 2D6A 04                   DEFB    $04             ;;multiply                   x*10.
14804 2D6B 33                   DEFB    $33             ;;jump
14805 2D6C
14806 2D6C 02                   DEFB    $02             ;;to L2D6E, E-FETCH
14807 2D6D
14808 2D6D              ;; E-DIVSN
14809 2D6D 05           L2D6D:  DEFB    $05             ;;division                   x/10.
14810 2D6E
14811 2D6E              ;; E-FETCH
14812 2D6E E1           L2D6E:  DEFB    $E1             ;;get-mem-1                  x/10 or x*10, 10.
14813 2D6F 38                   DEFB    $38             ;;end-calc                   new x, 10.
14814 2D70
14815 2D70 F1                   POP     AF              ; restore shifted exponent
14816 2D71
14817 2D71              ; the loop branched to here with no carry
14818 2D71
14819 2D71              ;; E-TST-END
14820 2D71 28 08        L2D71:  JR      Z,L2D7B         ; forward to E-END  if A emptied of bits
14821 2D73
14822 2D73 F5                   PUSH    AF              ; re-save shifted exponent
14823 2D74
14824 2D74 EF                   RST     28H             ;; FP-CALC
14825 2D75 31                   DEFB    $31             ;;duplicate                  new x, 10, 10.
14826 2D76 04                   DEFB    $04             ;;multiply                   new x, 100.
14827 2D77 38                   DEFB    $38             ;;end-calc
14828 2D78
14829 2D78 F1                   POP     AF              ; restore shifted exponent
14830 2D79 18 E5                JR      L2D60           ; back to E-LOOP  until all bits done.
14831 2D7B
14832 2D7B              ; ---
14833 2D7B
14834 2D7B              ; although only the first pass is shown it can be seen that for each set bit
14835 2D7B              ; representing a power of two, x is multiplied or divided by the
14836 2D7B              ; corresponding power of ten.
14837 2D7B
14838 2D7B              ;; E-END
14839 2D7B EF           L2D7B:  RST     28H             ;; FP-CALC                   final x, factor.
14840 2D7C 02                   DEFB    $02             ;;delete                     final x.
14841 2D7D 38                   DEFB    $38             ;;end-calc                   x.
14842 2D7E
14843 2D7E C9                   RET                     ; return
14844 2D7F
14845 2D7F
14846 2D7F
14847 2D7F
14848 2D7F              ; -------------
14849 2D7F              ; Fetch integer
14850 2D7F              ; -------------
14851 2D7F              ; This routine is called by the mathematical routines - FP-TO-BC, PRINT-FP,
14852 2D7F              ; mult, re-stack and negate to fetch an integer from address HL.
14853 2D7F              ; HL points to the stack or a location in MEM and no deletion occurs.
14854 2D7F              ; If the number is negative then a similar process to that used in INT-STORE
14855 2D7F              ; is used to restore the twos complement number to normal in DE and a sign
14856 2D7F              ; in C.
14857 2D7F
14858 2D7F              ;; INT-FETCH
14859 2D7F 23           L2D7F:  INC     HL              ; skip zero indicator.
14860 2D80 4E                   LD      C,(HL)          ; fetch sign to C
14861 2D81 23                   INC     HL              ; address low byte
14862 2D82 7E                   LD      A,(HL)          ; fetch to A
14863 2D83 A9                   XOR     C               ; two's complement
14864 2D84 91                   SUB     C               ;
14865 2D85 5F                   LD      E,A             ; place in E
14866 2D86 23                   INC     HL              ; address high byte
14867 2D87 7E                   LD      A,(HL)          ; fetch to A
14868 2D88 89                   ADC     A,C             ; two's complement
14869 2D89 A9                   XOR     C               ;
14870 2D8A 57                   LD      D,A             ; place in D
14871 2D8B C9                   RET                     ; return
14872 2D8C
14873 2D8C              ; ------------------------
14874 2D8C              ; Store a positive integer
14875 2D8C              ; ------------------------
14876 2D8C              ; This entry point is not used in this ROM but would
14877 2D8C              ; store any integer as positive.
14878 2D8C
14879 2D8C              ;; p-int-sto
14880 2D8C 0E 00        L2D8C:  LD      C,$00           ; make sign byte positive and continue
14881 2D8E
14882 2D8E              ; -------------
14883 2D8E              ; Store integer
14884 2D8E              ; -------------
14885 2D8E              ; this routine stores an integer in DE at address HL.
14886 2D8E              ; It is called from mult, truncate, negate and sgn.
14887 2D8E              ; The sign byte $00 +ve or $FF -ve is in C.
14888 2D8E              ; If negative, the number is stored in 2's complement form so that it is
14889 2D8E              ; ready to be added.
14890 2D8E
14891 2D8E              ;; INT-STORE
14892 2D8E E5           L2D8E:  PUSH    HL              ; preserve HL
14893 2D8F
14894 2D8F 36 00                LD      (HL),$00        ; first byte zero shows integer not exponent
14895 2D91 23                   INC     HL              ;
14896 2D92 71                   LD      (HL),C          ; then store the sign byte
14897 2D93 23                   INC     HL              ;
14898 2D94                                              ; e.g.             +1             -1
14899 2D94 7B                   LD      A,E             ; fetch low byte   00000001       00000001
14900 2D95 A9                   XOR     C               ; xor sign         00000000   or  11111111
14901 2D96                                              ; gives            00000001   or  11111110
14902 2D96 91                   SUB     C               ; sub sign         00000000   or  11111111
14903 2D97                                              ; gives            00000001>0 or  11111111>C
14904 2D97 77                   LD      (HL),A          ; store 2's complement.
14905 2D98 23                   INC     HL              ;
14906 2D99 7A                   LD      A,D             ; high byte        00000000       00000000
14907 2D9A 89                   ADC     A,C             ; sign             00000000<0     11111111<C
14908 2D9B                                              ; gives            00000000   or  00000000
14909 2D9B A9                   XOR     C               ; xor sign         00000000       11111111
14910 2D9C 77                   LD      (HL),A          ; store 2's complement.
14911 2D9D 23                   INC     HL              ;
14912 2D9E 36 00                LD      (HL),$00        ; last byte always zero for integers.
14913 2DA0                                              ; is not used and need not be looked at when
14914 2DA0                                              ; testing for zero but comes into play should
14915 2DA0                                              ; an integer be converted to fp.
14916 2DA0 E1                   POP     HL              ; restore HL
14917 2DA1 C9                   RET                     ; return.
14918 2DA2
14919 2DA2
14920 2DA2              ; -----------------------------
14921 2DA2              ; Floating point to BC register
14922 2DA2              ; -----------------------------
14923 2DA2              ; This routine gets a floating point number e.g. 127.4 from the calculator
14924 2DA2              ; stack to the BC register.
14925 2DA2
14926 2DA2              ;; FP-TO-BC
14927 2DA2 EF           L2DA2:  RST     28H             ;; FP-CALC            set HL to
14928 2DA3 38                   DEFB    $38             ;;end-calc            point to last value.
14929 2DA4
14930 2DA4 7E                   LD      A,(HL)          ; get first of 5 bytes
14931 2DA5 A7                   AND     A               ; and test
14932 2DA6 28 05                JR      Z,L2DAD         ; forward to FP-DELETE if an integer
14933 2DA8
14934 2DA8              ; The value is first rounded up and then converted to integer.
14935 2DA8
14936 2DA8 EF                   RST     28H             ;; FP-CALC           x.
14937 2DA9 A2                   DEFB    $A2             ;;stk-half           x. 1/2.
14938 2DAA 0F                   DEFB    $0F             ;;addition           x + 1/2.
14939 2DAB 27                   DEFB    $27             ;;int                int(x + .5)
14940 2DAC 38                   DEFB    $38             ;;end-calc
14941 2DAD
14942 2DAD              ; now delete but leave HL pointing at integer
14943 2DAD
14944 2DAD              ;; FP-DELETE
14945 2DAD EF           L2DAD:  RST     28H             ;; FP-CALC
14946 2DAE 02                   DEFB    $02             ;;delete
14947 2DAF 38                   DEFB    $38             ;;end-calc
14948 2DB0
14949 2DB0 E5                   PUSH    HL              ; save pointer.
14950 2DB1 D5                   PUSH    DE              ; and STKEND.
14951 2DB2 EB                   EX      DE,HL           ; make HL point to exponent/zero indicator
14952 2DB3 46                   LD      B,(HL)          ; indicator to B
14953 2DB4 CD 7F 2D             CALL    L2D7F           ; routine INT-FETCH
14954 2DB7                                              ; gets int in DE sign byte to C
14955 2DB7                                              ; but meaningless values if a large integer
14956 2DB7
14957 2DB7 AF                   XOR     A               ; clear A
14958 2DB8 90                   SUB     B               ; subtract indicator byte setting carry
14959 2DB9                                              ; if not a small integer.
14960 2DB9
14961 2DB9 CB 79                BIT     7,C             ; test a bit of the sign byte setting zero
14962 2DBB                                              ; if positive.
14963 2DBB
14964 2DBB 42                   LD      B,D             ; transfer int
14965 2DBC 4B                   LD      C,E             ; to BC
14966 2DBD 7B                   LD      A,E             ; low byte to A as a useful return value.
14967 2DBE
14968 2DBE D1                   POP     DE              ; pop STKEND
14969 2DBF E1                   POP     HL              ; and pointer to last value
14970 2DC0 C9                   RET                     ; return
14971 2DC1                                              ; if carry is set then the number was too big.
14972 2DC1
14973 2DC1              ; ------------
14974 2DC1              ; LOG(2^A)
14975 2DC1              ; ------------
14976 2DC1              ; This routine is used when printing floating point numbers to calculate
14977 2DC1              ; the number of digits before the decimal point.
14978 2DC1
14979 2DC1              ; first convert a one-byte signed integer to its five byte form.
14980 2DC1
14981 2DC1              ;; LOG(2^A)
14982 2DC1 57           L2DC1:  LD      D,A             ; store a copy of A in D.
14983 2DC2 17                   RLA                     ; test sign bit of A.
14984 2DC3 9F                   SBC     A,A             ; now $FF if negative or $00
14985 2DC4 5F                   LD      E,A             ; sign byte to E.
14986 2DC5 4F                   LD      C,A             ; and to C
14987 2DC6 AF                   XOR     A               ; clear A
14988 2DC7 47                   LD      B,A             ; and B.
14989 2DC8 CD B6 2A             CALL    L2AB6           ; routine STK-STORE stacks number AEDCB
14990 2DCB
14991 2DCB              ;  so 00 00 XX 00 00 (positive) or 00 FF XX FF 00 (negative).
14992 2DCB              ;  i.e. integer indicator, sign byte, low, high, unused.
14993 2DCB
14994 2DCB              ; now multiply exponent by log to the base 10 of two.
14995 2DCB
14996 2DCB EF                   RST      28H            ;; FP-CALC
14997 2DCC
14998 2DCC 34                   DEFB    $34             ;;stk-data                      .30103 (log 2)
14999 2DCD EF                   DEFB    $EF             ;;Exponent: $7F, Bytes: 4
15000 2DCE 1A 20 9A 85          DEFB    $1A,$20,$9A,$85 ;;
15001 2DD2 04                   DEFB    $04             ;;multiply
15002 2DD3
15003 2DD3 27                   DEFB    $27             ;;int
15004 2DD4
15005 2DD4 38                   DEFB    $38             ;;end-calc
15006 2DD5
15007 2DD5              ; -------------------
15008 2DD5              ; Floating point to A
15009 2DD5              ; -------------------
15010 2DD5              ; this routine collects a floating point number from the stack into the
15011 2DD5              ; accumulator returning carry set if not in range 0 - 255.
15012 2DD5              ; Not all the calling routines raise an error with overflow so no attempt
15013 2DD5              ; is made to produce an error report here.
15014 2DD5
15015 2DD5              ;; FP-TO-A
15016 2DD5 CD A2 2D     L2DD5:  CALL    L2DA2           ; routine FP-TO-BC returns with C in A also.
15017 2DD8 D8                   RET     C               ; return with carry set if > 65535, overflow
15018 2DD9
15019 2DD9 F5                   PUSH    AF              ; save the value and flags
15020 2DDA 05                   DEC     B               ; and test that
15021 2DDB 04                   INC     B               ; the high byte is zero.
15022 2DDC 28 03                JR      Z,L2DE1         ; forward  FP-A-END if zero
15023 2DDE
15024 2DDE              ; else there has been 8-bit overflow
15025 2DDE
15026 2DDE F1                   POP     AF              ; retrieve the value
15027 2DDF 37                   SCF                     ; set carry flag to show overflow
15028 2DE0 C9                   RET                     ; and return.
15029 2DE1
15030 2DE1              ; ---
15031 2DE1
15032 2DE1              ;; FP-A-END
15033 2DE1 F1           L2DE1:  POP     AF              ; restore value and success flag and
15034 2DE2 C9                   RET                     ; return.
15035 2DE3
15036 2DE3
15037 2DE3              ; -----------------------------
15038 2DE3              ; Print a floating point number
15039 2DE3              ; -----------------------------
15040 2DE3              ; Not a trivial task.
15041 2DE3              ; Begin by considering whether to print a leading sign for negative numbers.
15042 2DE3
15043 2DE3              ;; PRINT-FP
15044 2DE3 EF           L2DE3:  RST     28H             ;; FP-CALC
15045 2DE4 31                   DEFB    $31             ;;duplicate
15046 2DE5 36                   DEFB    $36             ;;less-0
15047 2DE6 00                   DEFB    $00             ;;jump-true
15048 2DE7
15049 2DE7 0B                   DEFB    $0B             ;;to L2DF2, PF-NEGTVE
15050 2DE8
15051 2DE8 31                   DEFB    $31             ;;duplicate
15052 2DE9 37                   DEFB    $37             ;;greater-0
15053 2DEA 00                   DEFB    $00             ;;jump-true
15054 2DEB
15055 2DEB 0D                   DEFB    $0D             ;;to L2DF8, PF-POSTVE
15056 2DEC
15057 2DEC              ; must be zero itself
15058 2DEC
15059 2DEC 02                   DEFB    $02             ;;delete
15060 2DED 38                   DEFB    $38             ;;end-calc
15061 2DEE
15062 2DEE 3E 30                LD      A,$30           ; prepare the character '0'
15063 2DF0
15064 2DF0 D7                   RST     10H             ; PRINT-A
15065 2DF1 C9                   RET                     ; return.                 ->
15066 2DF2              ; ---
15067 2DF2
15068 2DF2              ;; PF-NEGTVE
15069 2DF2 2A           L2DF2:  DEFB    $2A             ;;abs
15070 2DF3 38                   DEFB    $38             ;;end-calc
15071 2DF4
15072 2DF4 3E 2D                LD      A,$2D           ; the character '-'
15073 2DF6
15074 2DF6 D7                   RST     10H             ; PRINT-A
15075 2DF7
15076 2DF7              ; and continue to print the now positive number.
15077 2DF7
15078 2DF7 EF                   RST     28H             ;; FP-CALC
15079 2DF8
15080 2DF8              ;; PF-POSTVE
15081 2DF8 A0           L2DF8:  DEFB    $A0             ;;stk-zero     x,0.     begin by
15082 2DF9 C3                   DEFB    $C3             ;;st-mem-3     x,0.     clearing a temporary
15083 2DFA C4                   DEFB    $C4             ;;st-mem-4     x,0.     output buffer to
15084 2DFB C5                   DEFB    $C5             ;;st-mem-5     x,0.     fifteen zeros.
15085 2DFC 02                   DEFB    $02             ;;delete       x.
15086 2DFD 38                   DEFB    $38             ;;end-calc     x.
15087 2DFE
15088 2DFE D9                   EXX                     ; in case called from 'str$' then save the
15089 2DFF E5                   PUSH    HL              ; pointer to whatever comes after
15090 2E00 D9                   EXX                     ; str$ as H'L' will be used.
15091 2E01
15092 2E01              ; now enter a loop?
15093 2E01
15094 2E01              ;; PF-LOOP
15095 2E01 EF           L2E01:  RST     28H             ;; FP-CALC
15096 2E02 31                   DEFB    $31             ;;duplicate    x,x.
15097 2E03 27                   DEFB    $27             ;;int          x,int x.
15098 2E04 C2                   DEFB    $C2             ;;st-mem-2     x,int x.
15099 2E05 03                   DEFB    $03             ;;subtract     x-int x.     fractional part.
15100 2E06 E2                   DEFB    $E2             ;;get-mem-2    x-int x, int x.
15101 2E07 01                   DEFB    $01             ;;exchange     int x, x-int x.
15102 2E08 C2                   DEFB    $C2             ;;st-mem-2     int x, x-int x.
15103 2E09 02                   DEFB    $02             ;;delete       int x.
15104 2E0A 38                   DEFB    $38             ;;end-calc     int x.
15105 2E0B                                              ;
15106 2E0B                                              ; mem-2 holds the fractional part.
15107 2E0B
15108 2E0B              ; HL points to last value int x
15109 2E0B
15110 2E0B 7E                   LD      A,(HL)          ; fetch exponent of int x.
15111 2E0C A7                   AND     A               ; test
15112 2E0D 20 47                JR      NZ,L2E56        ; forward to PF-LARGE if a large integer
15113 2E0F                                              ; > 65535
15114 2E0F
15115 2E0F              ; continue with small positive integer components in range 0 - 65535
15116 2E0F              ; if original number was say .999 then this integer component is zero.
15117 2E0F
15118 2E0F CD 7F 2D             CALL    L2D7F           ; routine INT-FETCH gets x in DE
15119 2E12                                              ; (but x is not deleted)
15120 2E12
15121 2E12 06 10                LD      B,$10           ; set B, bit counter, to 16d
15122 2E14
15123 2E14 7A                   LD      A,D             ; test if
15124 2E15 A7                   AND     A               ; high byte is zero
15125 2E16 20 06                JR      NZ,L2E1E        ; forward to PF-SAVE if 16-bit integer.
15126 2E18
15127 2E18              ; and continue with integer in range 0 - 255.
15128 2E18
15129 2E18 B3                   OR      E               ; test the low byte for zero
15130 2E19                                              ; i.e. originally just point something or other.
15131 2E19 28 09                JR      Z,L2E24         ; forward if so to PF-SMALL
15132 2E1B
15133 2E1B              ;
15134 2E1B
15135 2E1B 53                   LD      D,E             ; transfer E to D
15136 2E1C 06 08                LD      B,$08           ; and reduce the bit counter to 8.
15137 2E1E
15138 2E1E              ;; PF-SAVE
15139 2E1E D5           L2E1E:  PUSH    DE              ; save the part before decimal point.
15140 2E1F D9                   EXX                     ;
15141 2E20 D1                   POP     DE              ; and pop in into D'E'
15142 2E21 D9                   EXX                     ;
15143 2E22 18 57                JR      L2E7B           ; forward to PF-BITS
15144 2E24
15145 2E24              ; ---------------------
15146 2E24
15147 2E24              ; the branch was here when 'int x' was found to be zero as in say 0.5.
15148 2E24              ; The zero has been fetched from the calculator stack but not deleted and
15149 2E24              ; this should occur now. This omission leaves the stack unbalanced and while
15150 2E24              ; that causes no problems with a simple PRINT statement, it will if str$ is
15151 2E24              ; being used in an expression e.g. "2" + STR$ 0.5 gives the result "0.5"
15152 2E24              ; instead of the expected result "20.5".
15153 2E24              ; credit Tony Stratton, 1982.
15154 2E24              ; A DEFB 02 delete is required immediately on using the calculator.
15155 2E24
15156 2E24              ;; PF-SMALL
15157 2E24 EF           L2E24:  RST     28H             ;; FP-CALC       int x = 0.
15158 2E25 E2           L2E25:  DEFB    $E2             ;;get-mem-2      int x = 0, x-int x.
15159 2E26 38                   DEFB    $38             ;;end-calc
15160 2E27
15161 2E27 7E                   LD      A,(HL)          ; fetch exponent of positive fractional number
15162 2E28 D6 7E                SUB     $7E             ; subtract
15163 2E2A
15164 2E2A CD C1 2D             CALL    L2DC1           ; routine LOG(2^A) calculates leading digits.
15165 2E2D
15166 2E2D 57                   LD      D,A             ; transfer count to D
15167 2E2E 3A AC 5C             LD      A,($5CAC)       ; fetch total MEM-5-1
15168 2E31 92                   SUB     D               ;
15169 2E32 32 AC 5C             LD      ($5CAC),A       ; MEM-5-1
15170 2E35 7A                   LD      A,D             ;
15171 2E36 CD 4F 2D             CALL    L2D4F           ; routine E-TO-FP
15172 2E39
15173 2E39 EF                   RST     28H             ;; FP-CALC
15174 2E3A 31                   DEFB    $31             ;;duplicate
15175 2E3B 27                   DEFB    $27             ;;int
15176 2E3C C1                   DEFB    $C1             ;;st-mem-1
15177 2E3D 03                   DEFB    $03             ;;subtract
15178 2E3E E1                   DEFB    $E1             ;;get-mem-1
15179 2E3F 38                   DEFB    $38             ;;end-calc
15180 2E40
15181 2E40 CD D5 2D             CALL    L2DD5           ; routine FP-TO-A
15182 2E43
15183 2E43 E5                   PUSH    HL              ; save HL
15184 2E44 32 A1 5C             LD      ($5CA1),A       ; MEM-3-1
15185 2E47 3D                   DEC     A               ;
15186 2E48 17                   RLA                     ;
15187 2E49 9F                   SBC     A,A             ;
15188 2E4A 3C                   INC     A               ;
15189 2E4B
15190 2E4B 21 AB 5C             LD      HL,$5CAB        ; address MEM-5-1 leading digit counter
15191 2E4E 77                   LD      (HL),A          ; store counter
15192 2E4F 23                   INC     HL              ; address MEM-5-2 total digits
15193 2E50 86                   ADD     A,(HL)          ; add counter to contents
15194 2E51 77                   LD      (HL),A          ; and store updated value
15195 2E52 E1                   POP     HL              ; restore HL
15196 2E53
15197 2E53 C3 CF 2E             JP      L2ECF           ; JUMP forward to PF-FRACTN
15198 2E56
15199 2E56              ; ---
15200 2E56
15201 2E56              ; Note. while it would be pedantic to comment on every occasion a JP
15202 2E56              ; instruction could be replaced with a JR instruction, this applies to the
15203 2E56              ; above, which is useful if you wish to correct the unbalanced stack error
15204 2E56              ; by inserting a 'DEFB 02 delete' at L2E25, and maintain main addresses.
15205 2E56
15206 2E56              ; the branch was here with a large positive integer > 65535 e.g. 123456789
15207 2E56              ; the accumulator holds the exponent.
15208 2E56
15209 2E56              ;; PF-LARGE
15210 2E56 D6 80        L2E56:  SUB     $80             ; make exponent positive
15211 2E58 FE 1C                CP      $1C             ; compare to 28
15212 2E5A 38 13                JR      C,L2E6F         ; to PF-MEDIUM if integer <= 2^27
15213 2E5C
15214 2E5C CD C1 2D             CALL    L2DC1           ; routine LOG(2^A)
15215 2E5F D6 07                SUB     $07             ;
15216 2E61 47                   LD      B,A             ;
15217 2E62 21 AC 5C             LD      HL,$5CAC        ; address MEM-5-1 the leading digits counter.
15218 2E65 86                   ADD     A,(HL)          ; add A to contents
15219 2E66 77                   LD      (HL),A          ; store updated value.
15220 2E67 78                   LD      A,B             ;
15221 2E68 ED 44                NEG                     ; negate
15222 2E6A CD 4F 2D             CALL    L2D4F           ; routine E-TO-FP
15223 2E6D 18 92                JR      L2E01           ; back to PF-LOOP
15224 2E6F
15225 2E6F              ; ----------------------------
15226 2E6F
15227 2E6F              ;; PF-MEDIUM
15228 2E6F EB           L2E6F:  EX      DE,HL           ;
15229 2E70 CD BA 2F             CALL    L2FBA           ; routine FETCH-TWO
15230 2E73 D9                   EXX                     ;
15231 2E74 CB FA                SET     7,D             ;
15232 2E76 7D                   LD      A,L             ;
15233 2E77 D9                   EXX                     ;
15234 2E78 D6 80                SUB     $80             ;
15235 2E7A 47                   LD      B,A             ;
15236 2E7B
15237 2E7B              ; the branch was here to handle bits in DE with 8 or 16 in B  if small int
15238 2E7B              ; and integer in D'E', 6 nibbles will accommodate 065535 but routine does
15239 2E7B              ; 32-bit numbers as well from above
15240 2E7B
15241 2E7B              ;; PF-BITS
15242 2E7B CB 23        L2E7B:  SLA     E               ;  C<xxxxxxxx<0
15243 2E7D CB 12                RL      D               ;  C<xxxxxxxx<C
15244 2E7F D9                   EXX                     ;
15245 2E80 CB 13                RL      E               ;  C<xxxxxxxx<C
15246 2E82 CB 12                RL      D               ;  C<xxxxxxxx<C
15247 2E84 D9                   EXX                     ;
15248 2E85
15249 2E85 21 AA 5C             LD      HL,$5CAA        ; set HL to mem-4-5th last byte of buffer
15250 2E88 0E 05                LD      C,$05           ; set byte count to 5 -  10 nibbles
15251 2E8A
15252 2E8A              ;; PF-BYTES
15253 2E8A 7E           L2E8A:  LD      A,(HL)          ; fetch 0 or prev value
15254 2E8B 8F                   ADC     A,A             ; shift left add in carry    C<xxxxxxxx<C
15255 2E8C
15256 2E8C 27                   DAA                     ; Decimal Adjust Accumulator.
15257 2E8D                                              ; if greater than 9 then the left hand
15258 2E8D                                              ; nibble is incremented. If greater than
15259 2E8D                                              ; 99 then adjusted and carry set.
15260 2E8D                                              ; so if we'd built up 7 and a carry came in
15261 2E8D                                              ;      0000 0111 < C
15262 2E8D                                              ;      0000 1111
15263 2E8D                                              ; daa     1 0101  which is 15 in BCD
15264 2E8D
15265 2E8D 77                   LD      (HL),A          ; put back
15266 2E8E 2B                   DEC     HL              ; work down thru mem 4
15267 2E8F 0D                   DEC     C               ; decrease the 5 counter.
15268 2E90 20 F8                JR      NZ,L2E8A        ; back to PF-BYTES until the ten nibbles rolled
15269 2E92
15270 2E92 10 E7                DJNZ    L2E7B           ; back to PF-BITS until 8 or 16 (or 32) done
15271 2E94
15272 2E94              ; at most 9 digits for 32-bit number will have been loaded with digits
15273 2E94              ; each of the 9 nibbles in mem 4 is placed into ten bytes in mem-3 and mem 4
15274 2E94              ; unless the nibble is zero as the buffer is already zero.
15275 2E94              ; ( or in the case of mem-5 will become zero as a result of RLD instruction )
15276 2E94
15277 2E94 AF                   XOR     A               ; clear to accept
15278 2E95 21 A6 5C             LD      HL,$5CA6        ; address MEM-4-0 byte destination.
15279 2E98 11 A1 5C             LD      DE,$5CA1        ; address MEM-3-0 nibble source.
15280 2E9B 06 09                LD      B,$09           ; the count is 9 (not ten) as the first
15281 2E9D                                              ; nibble is known to be blank.
15282 2E9D
15283 2E9D ED 6F                RLD                     ; shift RH nibble to left in (HL)
15284 2E9F                                              ;    A           (HL)
15285 2E9F                                              ; 0000 0000 < 0000 3210
15286 2E9F                                              ; 0000 0000   3210 0000
15287 2E9F                                              ; A picks up the blank nibble
15288 2E9F
15289 2E9F
15290 2E9F 0E FF                LD      C,$FF           ; set a flag to indicate when a significant
15291 2EA1                                              ; digit has been encountered.
15292 2EA1
15293 2EA1              ;; PF-DIGITS
15294 2EA1 ED 6F        L2EA1:  RLD                     ; pick up leftmost nibble from (HL)
15295 2EA3                                              ;    A           (HL)
15296 2EA3                                              ; 0000 0000 < 7654 3210
15297 2EA3                                              ; 0000 7654   3210 0000
15298 2EA3
15299 2EA3
15300 2EA3 20 04                JR      NZ,L2EA9        ; to PF-INSERT if non-zero value picked up.
15301 2EA5
15302 2EA5 0D                   DEC     C               ; test
15303 2EA6 0C                   INC     C               ; flag
15304 2EA7 20 0A                JR      NZ,L2EB3        ; skip forward to PF-TEST-2 if flag still $FF
15305 2EA9                                              ; indicating this is a leading zero.
15306 2EA9
15307 2EA9              ; but if the zero is a significant digit e.g. 10 then include in digit totals.
15308 2EA9              ; the path for non-zero digits rejoins here.
15309 2EA9
15310 2EA9              ;; PF-INSERT
15311 2EA9 12           L2EA9:  LD      (DE),A          ; insert digit at destination
15312 2EAA 13                   INC     DE              ; increase the destination pointer
15313 2EAB FD 34 71             INC     (IY+$71)        ; increment MEM-5-1st  digit counter
15314 2EAE FD 34 72             INC     (IY+$72)        ; increment MEM-5-2nd  leading digit counter
15315 2EB1 0E 00                LD      C,$00           ; set flag to zero indicating that any
15316 2EB3                                              ; subsequent zeros are significant and not
15317 2EB3                                              ; leading.
15318 2EB3
15319 2EB3              ;; PF-TEST-2
15320 2EB3 CB 40        L2EB3:  BIT     0,B             ; test if the nibble count is even
15321 2EB5 28 01                JR      Z,L2EB8         ; skip to PF-ALL-9 if so to deal with the
15322 2EB7                                              ; other nibble in the same byte
15323 2EB7
15324 2EB7 23                   INC     HL              ; point to next source byte if not
15325 2EB8
15326 2EB8              ;; PF-ALL-9
15327 2EB8 10 E7        L2EB8:  DJNZ    L2EA1           ; decrement the nibble count, back to PF-DIGITS
15328 2EBA                                              ; if all nine not done.
15329 2EBA
15330 2EBA              ; For 8-bit integers there will be at most 3 digits.
15331 2EBA              ; For 16-bit integers there will be at most 5 digits.
15332 2EBA              ; but for larger integers there could be nine leading digits.
15333 2EBA              ; if nine digits complete then the last one is rounded up as the number will
15334 2EBA              ; be printed using E-format notation
15335 2EBA
15336 2EBA 3A AB 5C             LD      A,($5CAB)       ; fetch digit count from MEM-5-1st
15337 2EBD D6 09                SUB     $09             ; subtract 9 - max possible
15338 2EBF 38 0A                JR      C,L2ECB         ; forward if less to PF-MORE
15339 2EC1
15340 2EC1 FD 35 71             DEC     (IY+$71)        ; decrement digit counter MEM-5-1st to 8
15341 2EC4 3E 04                LD      A,$04           ; load A with the value 4.
15342 2EC6 FD BE 6F             CP      (IY+$6F)        ; compare with MEM-4-4th - the ninth digit
15343 2EC9 18 41                JR      L2F0C           ; forward to PF-ROUND
15344 2ECB                                              ; to consider rounding.
15345 2ECB
15346 2ECB              ; ---------------------------------------
15347 2ECB
15348 2ECB              ; now delete int x from calculator stack and fetch fractional part.
15349 2ECB
15350 2ECB              ;; PF-MORE
15351 2ECB EF           L2ECB:  RST     28H             ;; FP-CALC        int x.
15352 2ECC 02                   DEFB    $02             ;;delete          .
15353 2ECD E2                   DEFB    $E2             ;;get-mem-2       x - int x = f.
15354 2ECE 38                   DEFB    $38             ;;end-calc        f.
15355 2ECF
15356 2ECF              ;; PF-FRACTN
15357 2ECF EB           L2ECF:  EX      DE,HL           ;
15358 2ED0 CD BA 2F             CALL    L2FBA           ; routine FETCH-TWO
15359 2ED3 D9                   EXX                     ;
15360 2ED4 3E 80                LD      A,$80           ;
15361 2ED6 95                   SUB     L               ;
15362 2ED7 2E 00                LD      L,$00           ;
15363 2ED9 CB FA                SET     7,D             ;
15364 2EDB D9                   EXX                     ;
15365 2EDC CD DD 2F             CALL    L2FDD           ; routine SHIFT-FP
15366 2EDF
15367 2EDF              ;; PF-FRN-LP
15368 2EDF FD 7E 71     L2EDF:  LD      A,(IY+$71)      ; MEM-5-1st
15369 2EE2 FE 08                CP      $08             ;
15370 2EE4 38 06                JR      C,L2EEC         ; to PF-FR-DGT
15371 2EE6
15372 2EE6 D9                   EXX                     ;
15373 2EE7 CB 12                RL      D               ;
15374 2EE9 D9                   EXX                     ;
15375 2EEA 18 20                JR      L2F0C           ; to PF-ROUND
15376 2EEC
15377 2EEC              ; ---
15378 2EEC
15379 2EEC              ;; PF-FR-DGT
15380 2EEC 01 00 02     L2EEC:  LD      BC,$0200        ;
15381 2EEF
15382 2EEF              ;; PF-FR-EXX
15383 2EEF 7B           L2EEF:  LD      A,E             ;
15384 2EF0 CD 8B 2F             CALL    L2F8B           ; routine CA-10*A+C
15385 2EF3 5F                   LD      E,A             ;
15386 2EF4 7A                   LD      A,D             ;
15387 2EF5 CD 8B 2F             CALL    L2F8B           ; routine CA-10*A+C
15388 2EF8 57                   LD      D,A             ;
15389 2EF9 C5                   PUSH    BC              ;
15390 2EFA D9                   EXX                     ;
15391 2EFB C1                   POP     BC              ;
15392 2EFC 10 F1                DJNZ    L2EEF           ; to PF-FR-EXX
15393 2EFE
15394 2EFE 21 A1 5C             LD      HL,$5CA1        ; MEM-3
15395 2F01 79                   LD      A,C             ;
15396 2F02 FD 4E 71             LD      C,(IY+$71)      ; MEM-5-1st
15397 2F05 09                   ADD     HL,BC           ;
15398 2F06 77                   LD      (HL),A          ;
15399 2F07 FD 34 71             INC     (IY+$71)        ; MEM-5-1st
15400 2F0A 18 D3                JR      L2EDF           ; to PF-FRN-LP
15401 2F0C
15402 2F0C              ; ----------------
15403 2F0C
15404 2F0C              ; 1) with 9 digits but 8 in mem-5-1 and A holding 4, carry set if rounding up.
15405 2F0C              ; e.g.
15406 2F0C              ;      999999999 is printed as 1E+9
15407 2F0C              ;      100000001 is printed as 1E+8
15408 2F0C              ;      100000009 is printed as 1.0000001E+8
15409 2F0C
15410 2F0C              ;; PF-ROUND
15411 2F0C F5           L2F0C:  PUSH    AF              ; save A and flags
15412 2F0D 21 A1 5C             LD      HL,$5CA1        ; address MEM-3 start of digits
15413 2F10 FD 4E 71             LD      C,(IY+$71)      ; MEM-5-1st No. of digits to C
15414 2F13 06 00                LD      B,$00           ; prepare to add
15415 2F15 09                   ADD     HL,BC           ; address last digit + 1
15416 2F16 41                   LD      B,C             ; No. of digits to B counter
15417 2F17 F1                   POP     AF              ; restore A and carry flag from comparison.
15418 2F18
15419 2F18              ;; PF-RND-LP
15420 2F18 2B           L2F18:  DEC     HL              ; address digit at rounding position.
15421 2F19 7E                   LD      A,(HL)          ; fetch it
15422 2F1A CE 00                ADC     A,$00           ; add carry from the comparison
15423 2F1C 77                   LD      (HL),A          ; put back result even if $0A.
15424 2F1D A7                   AND     A               ; test A
15425 2F1E 28 05                JR      Z,L2F25         ; skip to PF-R-BACK if ZERO?
15426 2F20
15427 2F20 FE 0A                CP      $0A             ; compare to 'ten' - overflow
15428 2F22 3F                   CCF                     ; complement carry flag so that set if ten.
15429 2F23 30 08                JR      NC,L2F2D        ; forward to PF-COUNT with 1 - 9.
15430 2F25
15431 2F25              ;; PF-R-BACK
15432 2F25 10 F1        L2F25:  DJNZ    L2F18           ; loop back to PF-RND-LP
15433 2F27
15434 2F27              ; if B counts down to zero then we've rounded right back as in 999999995.
15435 2F27              ; and the first 8 locations all hold $0A.
15436 2F27
15437 2F27
15438 2F27 36 01                LD      (HL),$01        ; load first location with digit 1.
15439 2F29 04                   INC     B               ; make B hold 1 also.
15440 2F2A                                              ; could save an instruction byte here.
15441 2F2A FD 34 72             INC     (IY+$72)        ; make MEM-5-2nd hold 1.
15442 2F2D                                              ; and proceed to initialize total digits to 1.
15443 2F2D
15444 2F2D              ;; PF-COUNT
15445 2F2D FD 70 71     L2F2D:  LD      (IY+$71),B      ; MEM-5-1st
15446 2F30
15447 2F30              ; now balance the calculator stack by deleting  it
15448 2F30
15449 2F30 EF                   RST     28H             ;; FP-CALC
15450 2F31 02                   DEFB    $02             ;;delete
15451 2F32 38                   DEFB    $38             ;;end-calc
15452 2F33
15453 2F33              ; note if used from str$ then other values may be on the calculator stack.
15454 2F33              ; we can also restore the next literal pointer from its position on the
15455 2F33              ; machine stack.
15456 2F33
15457 2F33 D9                   EXX                     ;
15458 2F34 E1                   POP     HL              ; restore next literal pointer.
15459 2F35 D9                   EXX                     ;
15460 2F36
15461 2F36 ED 4B AB 5C          LD      BC,($5CAB)      ; set C to MEM-5-1st digit counter.
15462 2F3A                                              ; set B to MEM-5-2nd leading digit counter.
15463 2F3A 21 A1 5C             LD      HL,$5CA1        ; set HL to start of digits at MEM-3-1
15464 2F3D 78                   LD      A,B             ;
15465 2F3E FE 09                CP      $09             ;
15466 2F40 38 04                JR      C,L2F46         ; to PF-NOT-E
15467 2F42
15468 2F42 FE FC                CP      $FC             ;
15469 2F44 38 26                JR      C,L2F6C         ; to PF-E-FRMT
15470 2F46
15471 2F46              ;; PF-NOT-E
15472 2F46 A7           L2F46:  AND     A               ; test for zero leading digits as in .123
15473 2F47
15474 2F47 CC EF 15             CALL    Z,L15EF         ; routine OUT-CODE prints a zero e.g. 0.123
15475 2F4A
15476 2F4A              ;; PF-E-SBRN
15477 2F4A AF           L2F4A:  XOR     A               ;
15478 2F4B 90                   SUB     B               ;
15479 2F4C FA 52 2F             JP      M,L2F52         ; skip forward to PF-OUT-LP if originally +ve
15480 2F4F
15481 2F4F 47                   LD      B,A             ; else negative count now +ve
15482 2F50 18 0C                JR      L2F5E           ; forward to PF-DC-OUT       ->
15483 2F52
15484 2F52              ; ---
15485 2F52
15486 2F52              ;; PF-OUT-LP
15487 2F52 79           L2F52:  LD      A,C             ; fetch total digit count
15488 2F53 A7                   AND     A               ; test for zero
15489 2F54 28 03                JR      Z,L2F59         ; forward to PF-OUT-DT if so
15490 2F56
15491 2F56 7E                   LD      A,(HL)          ; fetch digit
15492 2F57 23                   INC     HL              ; address next digit
15493 2F58 0D                   DEC     C               ; decrease total digit counter
15494 2F59
15495 2F59              ;; PF-OUT-DT
15496 2F59 CD EF 15     L2F59:  CALL    L15EF           ; routine OUT-CODE outputs it.
15497 2F5C 10 F4                DJNZ    L2F52           ; loop back to PF-OUT-LP until B leading
15498 2F5E                                              ; digits output.
15499 2F5E
15500 2F5E              ;; PF-DC-OUT
15501 2F5E 79           L2F5E:  LD      A,C             ; fetch total digits and
15502 2F5F A7                   AND     A               ; test if also zero
15503 2F60 C8                   RET     Z               ; return if so              -->
15504 2F61
15505 2F61              ;
15506 2F61
15507 2F61 04                   INC     B               ; increment B
15508 2F62 3E 2E                LD      A,$2E           ; prepare the character '.'
15509 2F64
15510 2F64              ;; PF-DEC-0S
15511 2F64 D7           L2F64:  RST     10H             ; PRINT-A outputs the character '.' or '0'
15512 2F65
15513 2F65 3E 30                LD      A,$30           ; prepare the character '0'
15514 2F67                                              ; (for cases like .000012345678)
15515 2F67 10 FB                DJNZ    L2F64           ; loop back to PF-DEC-0S for B times.
15516 2F69
15517 2F69 41                   LD      B,C             ; load B with now trailing digit counter.
15518 2F6A 18 E6                JR      L2F52           ; back to PF-OUT-LP
15519 2F6C
15520 2F6C              ; ---------------------------------
15521 2F6C
15522 2F6C              ; the branch was here for E-format printing e.g. 123456789 => 1.2345679e+8
15523 2F6C
15524 2F6C              ;; PF-E-FRMT
15525 2F6C 50           L2F6C:  LD      D,B             ; counter to D
15526 2F6D 15                   DEC     D               ; decrement
15527 2F6E 06 01                LD      B,$01           ; load B with 1.
15528 2F70
15529 2F70 CD 4A 2F             CALL    L2F4A           ; routine PF-E-SBRN above
15530 2F73
15531 2F73 3E 45                LD      A,$45           ; prepare character 'e'
15532 2F75 D7                   RST     10H             ; PRINT-A
15533 2F76
15534 2F76 4A                   LD      C,D             ; exponent to C
15535 2F77 79                   LD      A,C             ; and to A
15536 2F78 A7                   AND     A               ; test exponent
15537 2F79 F2 83 2F             JP      P,L2F83         ; to PF-E-POS if positive
15538 2F7C
15539 2F7C ED 44                NEG                     ; negate
15540 2F7E 4F                   LD      C,A             ; positive exponent to C
15541 2F7F 3E 2D                LD      A,$2D           ; prepare character '-'
15542 2F81 18 02                JR      L2F85           ; skip to PF-E-SIGN
15543 2F83
15544 2F83              ; ---
15545 2F83
15546 2F83              ;; PF-E-POS
15547 2F83 3E 2B        L2F83:  LD      A,$2B           ; prepare character '+'
15548 2F85
15549 2F85              ;; PF-E-SIGN
15550 2F85 D7           L2F85:  RST     10H             ; PRINT-A outputs the sign
15551 2F86
15552 2F86 06 00                LD      B,$00           ; make the high byte zero.
15553 2F88 C3 1B 1A             JP      L1A1B           ; exit via OUT-NUM-1 to print exponent in BC
15554 2F8B
15555 2F8B              ; ------------------------------
15556 2F8B              ; Handle printing floating point
15557 2F8B              ; ------------------------------
15558 2F8B              ; This subroutine is called twice from above when printing floating-point
15559 2F8B              ; numbers. It returns 10*A +C in registers C and A
15560 2F8B
15561 2F8B              ;; CA-10*A+C
15562 2F8B D5           L2F8B:  PUSH    DE              ; preserve DE.
15563 2F8C 6F                   LD      L,A             ; transfer A to L
15564 2F8D 26 00                LD      H,$00           ; zero high byte.
15565 2F8F 5D                   LD      E,L             ; copy HL
15566 2F90 54                   LD      D,H             ; to DE.
15567 2F91 29                   ADD     HL,HL           ; double (*2)
15568 2F92 29                   ADD     HL,HL           ; double (*4)
15569 2F93 19                   ADD     HL,DE           ; add DE (*5)
15570 2F94 29                   ADD     HL,HL           ; double (*10)
15571 2F95 59                   LD      E,C             ; copy C to E    (D is 0)
15572 2F96 19                   ADD     HL,DE           ; and add to give required result.
15573 2F97 4C                   LD      C,H             ; transfer to
15574 2F98 7D                   LD      A,L             ; destination registers.
15575 2F99 D1                   POP     DE              ; restore DE
15576 2F9A C9                   RET                     ; return with result.
15577 2F9B
15578 2F9B              ; --------------
15579 2F9B              ; Prepare to add
15580 2F9B              ; --------------
15581 2F9B              ; This routine is called twice by addition to prepare the two numbers. The
15582 2F9B              ; exponent is picked up in A and the location made zero. Then the sign bit
15583 2F9B              ; is tested before being set to the implied state. Negative numbers are twos
15584 2F9B              ; complemented.
15585 2F9B
15586 2F9B              ;; PREP-ADD
15587 2F9B 7E           L2F9B:  LD      A,(HL)          ; pick up exponent
15588 2F9C 36 00                LD      (HL),$00        ; make location zero
15589 2F9E A7                   AND     A               ; test if number is zero
15590 2F9F C8                   RET     Z               ; return if so
15591 2FA0
15592 2FA0 23                   INC     HL              ; address mantissa
15593 2FA1 CB 7E                BIT     7,(HL)          ; test the sign bit
15594 2FA3 CB FE                SET     7,(HL)          ; set it to implied state
15595 2FA5 2B                   DEC     HL              ; point to exponent
15596 2FA6 C8                   RET     Z               ; return if positive number.
15597 2FA7
15598 2FA7 C5                   PUSH    BC              ; preserve BC
15599 2FA8 01 05 00             LD      BC,$0005        ; length of number
15600 2FAB 09                   ADD     HL,BC           ; point HL past end
15601 2FAC 41                   LD      B,C             ; set B to 5 counter
15602 2FAD 4F                   LD      C,A             ; store exponent in C
15603 2FAE 37                   SCF                     ; set carry flag
15604 2FAF
15605 2FAF              ;; NEG-BYTE
15606 2FAF 2B           L2FAF:  DEC     HL              ; work from LSB to MSB
15607 2FB0 7E                   LD      A,(HL)          ; fetch byte
15608 2FB1 2F                   CPL                     ; complement
15609 2FB2 CE 00                ADC     A,$00           ; add in initial carry or from prev operation
15610 2FB4 77                   LD      (HL),A          ; put back
15611 2FB5 10 F8                DJNZ    L2FAF           ; loop to NEG-BYTE till all 5 done
15612 2FB7
15613 2FB7 79                   LD      A,C             ; stored exponent to A
15614 2FB8 C1                   POP     BC              ; restore original BC
15615 2FB9 C9                   RET                     ; return
15616 2FBA
15617 2FBA              ; -----------------
15618 2FBA              ; Fetch two numbers
15619 2FBA              ; -----------------
15620 2FBA              ; This routine is called twice when printing floating point numbers and also
15621 2FBA              ; to fetch two numbers by the addition, multiply and division routines.
15622 2FBA              ; HL addresses the first number, DE addresses the second number.
15623 2FBA              ; For arithmetic only, A holds the sign of the result which is stored in
15624 2FBA              ; the second location.
15625 2FBA
15626 2FBA              ;; FETCH-TWO
15627 2FBA E5           L2FBA:  PUSH    HL              ; save pointer to first number, result if math.
15628 2FBB F5                   PUSH    AF              ; save result sign.
15629 2FBC
15630 2FBC 4E                   LD      C,(HL)          ;
15631 2FBD 23                   INC     HL              ;
15632 2FBE
15633 2FBE 46                   LD      B,(HL)          ;
15634 2FBF 77                   LD      (HL),A          ; store the sign at correct location in
15635 2FC0                                              ; destination 5 bytes for arithmetic only.
15636 2FC0 23                   INC     HL              ;
15637 2FC1
15638 2FC1 79                   LD      A,C             ;
15639 2FC2 4E                   LD      C,(HL)          ;
15640 2FC3 C5                   PUSH    BC              ;
15641 2FC4 23                   INC     HL              ;
15642 2FC5 4E                   LD      C,(HL)          ;
15643 2FC6 23                   INC     HL              ;
15644 2FC7 46                   LD      B,(HL)          ;
15645 2FC8 EB                   EX      DE,HL           ;
15646 2FC9 57                   LD      D,A             ;
15647 2FCA 5E                   LD      E,(HL)          ;
15648 2FCB D5                   PUSH    DE              ;
15649 2FCC 23                   INC     HL              ;
15650 2FCD 56                   LD      D,(HL)          ;
15651 2FCE 23                   INC     HL              ;
15652 2FCF 5E                   LD      E,(HL)          ;
15653 2FD0 D5                   PUSH    DE              ;
15654 2FD1 D9                   EXX                     ;
15655 2FD2 D1                   POP     DE              ;
15656 2FD3 E1                   POP     HL              ;
15657 2FD4 C1                   POP     BC              ;
15658 2FD5 D9                   EXX                     ;
15659 2FD6 23                   INC     HL              ;
15660 2FD7 56                   LD      D,(HL)          ;
15661 2FD8 23                   INC     HL              ;
15662 2FD9 5E                   LD      E,(HL)          ;
15663 2FDA
15664 2FDA F1                   POP     AF              ; restore possible result sign.
15665 2FDB E1                   POP     HL              ; and pointer to possible result.
15666 2FDC C9                   RET                     ; return.
15667 2FDD
15668 2FDD              ; ---------------------------------
15669 2FDD              ; Shift floating point number right
15670 2FDD              ; ---------------------------------
15671 2FDD              ;
15672 2FDD              ;
15673 2FDD
15674 2FDD              ;; SHIFT-FP
15675 2FDD A7           L2FDD:  AND     A               ;
15676 2FDE C8                   RET     Z               ;
15677 2FDF
15678 2FDF FE 21                CP      $21             ;
15679 2FE1 30 16                JR      NC,L2FF9        ; to ADDEND-0
15680 2FE3
15681 2FE3 C5                   PUSH    BC              ;
15682 2FE4 47                   LD      B,A             ;
15683 2FE5
15684 2FE5              ;; ONE-SHIFT
15685 2FE5 D9           L2FE5:  EXX                     ;
15686 2FE6 CB 2D                SRA     L               ;
15687 2FE8 CB 1A                RR      D               ;
15688 2FEA CB 1B                RR      E               ;
15689 2FEC D9                   EXX                     ;
15690 2FED CB 1A                RR      D               ;
15691 2FEF CB 1B                RR      E               ;
15692 2FF1 10 F2                DJNZ    L2FE5           ; to ONE-SHIFT
15693 2FF3
15694 2FF3 C1                   POP     BC              ;
15695 2FF4 D0                   RET     NC              ;
15696 2FF5
15697 2FF5 CD 04 30             CALL    L3004           ; routine ADD-BACK
15698 2FF8 C0                   RET     NZ              ;
15699 2FF9
15700 2FF9              ;; ADDEND-0
15701 2FF9 D9           L2FF9:  EXX                     ;
15702 2FFA AF                   XOR     A               ;
15703 2FFB
15704 2FFB              ;; ZEROS-4/5
15705 2FFB 2E 00        L2FFB:  LD      L,$00           ;
15706 2FFD 57                   LD      D,A             ;
15707 2FFE 5D                   LD      E,L             ;
15708 2FFF D9                   EXX                     ;
15709 3000 11 00 00             LD      DE,$0000        ;
15710 3003 C9                   RET                     ;
15711 3004
15712 3004              ; ------------------
15713 3004              ; Add back any carry
15714 3004              ; ------------------
15715 3004              ;
15716 3004              ;
15717 3004
15718 3004              ;; ADD-BACK
15719 3004 1C           L3004:  INC     E               ;
15720 3005 C0                   RET     NZ              ;
15721 3006
15722 3006 14                   INC      D              ;
15723 3007 C0                   RET     NZ              ;
15724 3008
15725 3008 D9                   EXX                     ;
15726 3009 1C                   INC     E               ;
15727 300A 20 01                JR      NZ,L300D        ; to ALL-ADDED
15728 300C
15729 300C 14                   INC     D               ;
15730 300D
15731 300D              ;; ALL-ADDED
15732 300D D9           L300D:  EXX                     ;
15733 300E C9                   RET                     ;
15734 300F
15735 300F              ; -----------------------
15736 300F              ; Handle subtraction (03)
15737 300F              ; -----------------------
15738 300F              ; Subtraction is done by switching the sign byte/bit of the second number
15739 300F              ; which may be integer of floating point and continuing into addition.
15740 300F
15741 300F              ;; subtract
15742 300F EB           L300F:  EX      DE,HL           ; address second number with HL
15743 3010
15744 3010 CD 6E 34             CALL    L346E           ; routine NEGATE switches sign
15745 3013
15746 3013 EB                   EX      DE,HL           ; address first number again
15747 3014                                              ; and continue.
15748 3014
15749 3014              ; --------------------
15750 3014              ; Handle addition (0F)
15751 3014              ; --------------------
15752 3014              ; HL points to first number, DE to second.
15753 3014              ; If they are both integers, then go for the easy route.
15754 3014
15755 3014              ;; addition
15756 3014 1A           L3014:  LD      A,(DE)          ; fetch first byte of second
15757 3015 B6                   OR      (HL)            ; combine with first byte of first
15758 3016 20 26                JR      NZ,L303E        ; forward to FULL-ADDN if at least one was
15759 3018                                              ; in floating point form.
15760 3018
15761 3018              ; continue if both were small integers.
15762 3018
15763 3018 D5                   PUSH    DE              ; save pointer to lowest number for result.
15764 3019
15765 3019 23                   INC     HL              ; address sign byte and
15766 301A E5                   PUSH    HL              ; push the pointer.
15767 301B
15768 301B 23                   INC     HL              ; address low byte
15769 301C 5E                   LD      E,(HL)          ; to E
15770 301D 23                   INC     HL              ; address high byte
15771 301E 56                   LD      D,(HL)          ; to D
15772 301F 23                   INC     HL              ; address unused byte
15773 3020
15774 3020 23                   INC     HL              ; address known zero indicator of 1st number
15775 3021 23                   INC     HL              ; address sign byte
15776 3022
15777 3022 7E                   LD      A,(HL)          ; sign to A, $00 or $FF
15778 3023
15779 3023 23                   INC     HL              ; address low byte
15780 3024 4E                   LD      C,(HL)          ; to C
15781 3025 23                   INC     HL              ; address high byte
15782 3026 46                   LD      B,(HL)          ; to B
15783 3027
15784 3027 E1                   POP     HL              ; pop result sign pointer
15785 3028 EB                   EX      DE,HL           ; integer to HL
15786 3029
15787 3029 09                   ADD     HL,BC           ; add to the other one in BC
15788 302A                                              ; setting carry if overflow.
15789 302A
15790 302A EB                   EX      DE,HL           ; save result in DE bringing back sign pointer
15791 302B
15792 302B 8E                   ADC     A,(HL)          ; if pos/pos A=01 with overflow else 00
15793 302C                                              ; if neg/neg A=FF with overflow else FE
15794 302C                                              ; if mixture A=00 with overflow else FF
15795 302C
15796 302C 0F                   RRCA                    ; bit 0 to (C)
15797 302D
15798 302D CE 00                ADC     A,$00           ; both acceptable signs now zero
15799 302F
15800 302F 20 0B                JR      NZ,L303C        ; forward to ADDN-OFLW if not
15801 3031
15802 3031 9F                   SBC     A,A             ; restore a negative result sign
15803 3032
15804 3032 77                   LD      (HL),A          ;
15805 3033 23                   INC     HL              ;
15806 3034 73                   LD      (HL),E          ;
15807 3035 23                   INC     HL              ;
15808 3036 72                   LD      (HL),D          ;
15809 3037 2B                   DEC     HL              ;
15810 3038 2B                   DEC     HL              ;
15811 3039 2B                   DEC     HL              ;
15812 303A
15813 303A D1                   POP     DE              ; STKEND
15814 303B C9                   RET                     ;
15815 303C
15816 303C              ; ---
15817 303C
15818 303C              ;; ADDN-OFLW
15819 303C 2B           L303C:  DEC     HL              ;
15820 303D D1                   POP     DE              ;
15821 303E
15822 303E              ;; FULL-ADDN
15823 303E CD 93 32     L303E:  CALL    L3293           ; routine RE-ST-TWO
15824 3041 D9                   EXX                     ;
15825 3042 E5                   PUSH    HL              ;
15826 3043 D9                   EXX                     ;
15827 3044 D5                   PUSH    DE              ;
15828 3045 E5                   PUSH    HL              ;
15829 3046 CD 9B 2F             CALL    L2F9B           ; routine PREP-ADD
15830 3049 47                   LD      B,A             ;
15831 304A EB                   EX      DE,HL           ;
15832 304B CD 9B 2F             CALL    L2F9B           ; routine PREP-ADD
15833 304E 4F                   LD       C,A            ;
15834 304F B8                   CP      B               ;
15835 3050 30 03                JR      NC,L3055        ; to SHIFT-LEN
15836 3052
15837 3052 78                   LD      A,B             ;
15838 3053 41                   LD      B,C             ;
15839 3054 EB                   EX      DE,HL           ;
15840 3055
15841 3055              ;; SHIFT-LEN
15842 3055 F5           L3055:  PUSH    AF              ;
15843 3056 90                   SUB     B               ;
15844 3057 CD BA 2F             CALL    L2FBA           ; routine FETCH-TWO
15845 305A CD DD 2F             CALL    L2FDD           ; routine SHIFT-FP
15846 305D F1                   POP     AF              ;
15847 305E E1                   POP     HL              ;
15848 305F 77                   LD      (HL),A          ;
15849 3060 E5                   PUSH    HL              ;
15850 3061 68                   LD      L,B             ;
15851 3062 61                   LD      H,C             ;
15852 3063 19                   ADD     HL,DE           ;
15853 3064 D9                   EXX                     ;
15854 3065 EB                   EX      DE,HL           ;
15855 3066 ED 4A                ADC     HL,BC           ;
15856 3068 EB                   EX      DE,HL           ;
15857 3069 7C                   LD      A,H             ;
15858 306A 8D                   ADC     A,L             ;
15859 306B 6F                   LD      L,A             ;
15860 306C 1F                   RRA                     ;
15861 306D AD                   XOR     L               ;
15862 306E D9                   EXX                     ;
15863 306F EB                   EX      DE,HL           ;
15864 3070 E1                   POP     HL              ;
15865 3071 1F                   RRA                     ;
15866 3072 30 08                JR      NC,L307C        ; to TEST-NEG
15867 3074
15868 3074 3E 01                LD      A,$01           ;
15869 3076 CD DD 2F             CALL    L2FDD           ; routine SHIFT-FP
15870 3079 34                   INC     (HL)            ;
15871 307A 28 23                JR      Z,L309F         ; to ADD-REP-6
15872 307C
15873 307C              ;; TEST-NEG
15874 307C D9           L307C:  EXX                     ;
15875 307D 7D                   LD      A,L             ;
15876 307E E6 80                AND     $80             ;
15877 3080 D9                   EXX                     ;
15878 3081 23                   INC     HL              ;
15879 3082 77                   LD      (HL),A          ;
15880 3083 2B                   DEC     HL              ;
15881 3084 28 1F                JR      Z,L30A5         ; to GO-NC-MLT
15882 3086
15883 3086 7B                   LD      A,E             ;
15884 3087 ED 44                NEG                     ; Negate
15885 3089 3F                   CCF                     ; Complement Carry Flag
15886 308A 5F                   LD      E,A             ;
15887 308B 7A                   LD      A,D             ;
15888 308C 2F                   CPL                     ;
15889 308D CE 00                ADC     A,$00           ;
15890 308F 57                   LD      D,A             ;
15891 3090 D9                   EXX                     ;
15892 3091 7B                   LD      A,E             ;
15893 3092 2F                   CPL                     ;
15894 3093 CE 00                ADC     A,$00           ;
15895 3095 5F                   LD      E,A             ;
15896 3096 7A                   LD      A,D             ;
15897 3097 2F                   CPL                     ;
15898 3098 CE 00                ADC     A,$00           ;
15899 309A 30 07                JR      NC,L30A3        ; to END-COMPL
15900 309C
15901 309C 1F                   RRA                     ;
15902 309D D9                   EXX                     ;
15903 309E 34                   INC     (HL)            ;
15904 309F
15905 309F              ;; ADD-REP-6
15906 309F CA AD 31     L309F:  JP      Z,L31AD         ; to REPORT-6
15907 30A2
15908 30A2 D9                   EXX                     ;
15909 30A3
15910 30A3              ;; END-COMPL
15911 30A3 57           L30A3:  LD      D,A             ;
15912 30A4 D9                   EXX                     ;
15913 30A5
15914 30A5              ;; GO-NC-MLT
15915 30A5 AF           L30A5:  XOR     A               ;
15916 30A6 C3 55 31             JP      L3155           ; to TEST-NORM
15917 30A9
15918 30A9              ; -----------------------------
15919 30A9              ; Used in 16 bit multiplication
15920 30A9              ; -----------------------------
15921 30A9              ; This routine is used, in the first instance, by the multiply calculator
15922 30A9              ; literal to perform an integer multiplication in preference to
15923 30A9              ; 32-bit multiplication to which it will resort if this overflows.
15924 30A9              ;
15925 30A9              ; It is also used by STK-VAR to calculate array subscripts and by DIM to
15926 30A9              ; calculate the space required for multi-dimensional arrays.
15927 30A9
15928 30A9              ;; HL-HL*DE
15929 30A9 C5           L30A9:  PUSH    BC              ; preserve BC throughout
15930 30AA 06 10                LD      B,$10           ; set B to 16
15931 30AC 7C                   LD      A,H             ; save H in A high byte
15932 30AD 4D                   LD      C,L             ; save L in C low byte
15933 30AE 21 00 00             LD      HL,$0000        ; initialize result to zero
15934 30B1
15935 30B1              ; now enter a loop.
15936 30B1
15937 30B1              ;; HL-LOOP
15938 30B1 29           L30B1:  ADD     HL,HL           ; double result
15939 30B2 38 0A                JR      C,L30BE         ; to HL-END if overflow
15940 30B4
15941 30B4 CB 11                RL      C               ; shift AC left into carry
15942 30B6 17                   RLA                     ;
15943 30B7 30 03                JR      NC,L30BC        ; to HL-AGAIN to skip addition if no carry
15944 30B9
15945 30B9 19                   ADD     HL,DE           ; add in DE
15946 30BA 38 02                JR      C,L30BE         ; to HL-END if overflow
15947 30BC
15948 30BC              ;; HL-AGAIN
15949 30BC 10 F3        L30BC:  DJNZ    L30B1           ; back to HL-LOOP for all 16 bits
15950 30BE
15951 30BE              ;; HL-END
15952 30BE C1           L30BE:  POP     BC              ; restore preserved BC
15953 30BF C9                   RET                     ; return with carry reset if successful
15954 30C0                                              ; and result in HL.
15955 30C0
15956 30C0              ; ----------------------------------------------
15957 30C0              ; THE 'PREPARE TO MULTIPLY OR DIVIDE' SUBROUTINE
15958 30C0              ; ----------------------------------------------
15959 30C0              ;   This routine is called in succession from multiply and divide to prepare
15960 30C0              ;   two mantissas by setting the leftmost bit that is used for the sign.
15961 30C0              ;   On the first call A holds zero and picks up the sign bit. On the second
15962 30C0              ;   call the two bits are XORed to form the result sign - minus * minus giving
15963 30C0              ;   plus etc. If either number is zero then this is flagged.
15964 30C0              ;   HL addresses the exponent.
15965 30C0
15966 30C0              ;; PREP-M/D
15967 30C0 CD E9 34     L30C0:  CALL    L34E9           ; routine TEST-ZERO  preserves accumulator.
15968 30C3 D8                   RET     C               ; return carry set if zero
15969 30C4
15970 30C4 23                   INC     HL              ; address first byte of mantissa
15971 30C5 AE                   XOR     (HL)            ; pick up the first or xor with first.
15972 30C6 CB FE                SET     7,(HL)          ; now set to give true 32-bit mantissa
15973 30C8 2B                   DEC     HL              ; point to exponent
15974 30C9 C9                   RET                     ; return with carry reset
15975 30CA
15976 30CA              ; ----------------------
15977 30CA              ; THE 'MULTIPLY' ROUTINE
15978 30CA              ; ----------------------
15979 30CA              ; (offset: $04 'multiply')
15980 30CA              ;
15981 30CA              ;
15982 30CA              ;   "He said go forth and something about mathematics, I wasn't really
15983 30CA              ;    listening" - overheard conversation between two unicorns.
15984 30CA              ;    [ The Odd Streak ].
15985 30CA
15986 30CA              ;; multiply
15987 30CA 1A           L30CA:  LD      A,(DE)          ;
15988 30CB B6                   OR      (HL)            ;
15989 30CC 20 22                JR      NZ,L30F0        ; to MULT-LONG
15990 30CE
15991 30CE D5                   PUSH    DE              ;
15992 30CF E5                   PUSH    HL              ;
15993 30D0 D5                   PUSH    DE              ;
15994 30D1 CD 7F 2D             CALL    L2D7F           ; routine INT-FETCH
15995 30D4 EB                   EX      DE,HL           ;
15996 30D5 E3                   EX      (SP),HL         ;
15997 30D6 41                   LD      B,C             ;
15998 30D7 CD 7F 2D             CALL    L2D7F           ; routine INT-FETCH
15999 30DA 78                   LD      A,B             ;
16000 30DB A9                   XOR     C               ;
16001 30DC 4F                   LD      C,A             ;
16002 30DD E1                   POP     HL              ;
16003 30DE CD A9 30             CALL    L30A9           ; routine HL-HL*DE
16004 30E1 EB                   EX      DE,HL           ;
16005 30E2 E1                   POP     HL              ;
16006 30E3 38 0A                JR      C,L30EF         ; to MULT-OFLW
16007 30E5
16008 30E5 7A                   LD      A,D             ;
16009 30E6 B3                   OR      E               ;
16010 30E7 20 01                JR      NZ,L30EA        ; to MULT-RSLT
16011 30E9
16012 30E9 4F                   LD      C,A             ;
16013 30EA
16014 30EA              ;; MULT-RSLT
16015 30EA CD 8E 2D     L30EA:  CALL    L2D8E           ; routine INT-STORE
16016 30ED D1                   POP      DE             ;
16017 30EE C9                   RET                     ;
16018 30EF
16019 30EF              ; ---
16020 30EF
16021 30EF              ;; MULT-OFLW
16022 30EF D1           L30EF:  POP     DE              ;
16023 30F0
16024 30F0              ;; MULT-LONG
16025 30F0 CD 93 32     L30F0:  CALL    L3293           ; routine RE-ST-TWO
16026 30F3 AF                   XOR     A               ;
16027 30F4 CD C0 30             CALL    L30C0           ; routine PREP-M/D
16028 30F7 D8                   RET     C               ;
16029 30F8
16030 30F8 D9                   EXX                     ;
16031 30F9 E5                   PUSH    HL              ;
16032 30FA D9                   EXX                     ;
16033 30FB D5                   PUSH    DE              ;
16034 30FC EB                   EX      DE,HL           ;
16035 30FD CD C0 30             CALL    L30C0           ; routine PREP-M/D
16036 3100 EB                   EX      DE,HL           ;
16037 3101 38 5A                JR      C,L315D         ; to ZERO-RSLT
16038 3103
16039 3103 E5                   PUSH    HL              ;
16040 3104 CD BA 2F             CALL    L2FBA           ; routine FETCH-TWO
16041 3107 78                   LD      A,B             ;
16042 3108 A7                   AND     A               ;
16043 3109 ED 62                SBC     HL,HL           ;
16044 310B D9                   EXX                     ;
16045 310C E5                   PUSH    HL              ;
16046 310D ED 62                SBC     HL,HL           ;
16047 310F D9                   EXX                     ;
16048 3110 06 21                LD      B,$21           ;
16049 3112 18 11                JR      L3125           ; to STRT-MLT
16050 3114
16051 3114              ; ---
16052 3114
16053 3114              ;; MLT-LOOP
16054 3114 30 05        L3114:  JR      NC,L311B        ; to NO-ADD
16055 3116
16056 3116 19                   ADD     HL,DE           ;
16057 3117 D9                   EXX                     ;
16058 3118 ED 5A                ADC     HL,DE           ;
16059 311A D9                   EXX                     ;
16060 311B
16061 311B              ;; NO-ADD
16062 311B D9           L311B:  EXX                     ;
16063 311C CB 1C                RR      H               ;
16064 311E CB 1D                RR      L               ;
16065 3120 D9                   EXX                     ;
16066 3121 CB 1C                RR      H               ;
16067 3123 CB 1D                RR      L               ;
16068 3125
16069 3125              ;; STRT-MLT
16070 3125 D9           L3125:  EXX                     ;
16071 3126 CB 18                RR      B               ;
16072 3128 CB 19                RR      C               ;
16073 312A D9                   EXX                     ;
16074 312B CB 19                RR      C               ;
16075 312D 1F                   RRA                     ;
16076 312E 10 E4                DJNZ    L3114           ; to MLT-LOOP
16077 3130
16078 3130 EB                   EX      DE,HL           ;
16079 3131 D9                   EXX                     ;
16080 3132 EB                   EX      DE,HL           ;
16081 3133 D9                   EXX                     ;
16082 3134 C1                   POP     BC              ;
16083 3135 E1                   POP     HL              ;
16084 3136 78                   LD      A,B             ;
16085 3137 81                   ADD     A,C             ;
16086 3138 20 01                JR      NZ,L313B        ; to MAKE-EXPT
16087 313A
16088 313A A7                   AND     A               ;
16089 313B
16090 313B              ;; MAKE-EXPT
16091 313B 3D           L313B:  DEC     A               ;
16092 313C 3F                   CCF                     ; Complement Carry Flag
16093 313D
16094 313D              ;; DIVN-EXPT
16095 313D 17           L313D:  RLA                     ;
16096 313E 3F                   CCF                     ; Complement Carry Flag
16097 313F 1F                   RRA                     ;
16098 3140 F2 46 31             JP      P,L3146         ; to OFLW1-CLR
16099 3143
16100 3143 30 68                JR      NC,L31AD        ; to REPORT-6
16101 3145
16102 3145 A7                   AND     A               ;
16103 3146
16104 3146              ;; OFLW1-CLR
16105 3146 3C           L3146:  INC     A               ;
16106 3147 20 08                JR      NZ,L3151        ; to OFLW2-CLR
16107 3149
16108 3149 38 06                JR      C,L3151         ; to OFLW2-CLR
16109 314B
16110 314B D9                   EXX                     ;
16111 314C CB 7A                BIT     7,D             ;
16112 314E D9                   EXX                     ;
16113 314F 20 5C                JR      NZ,L31AD        ; to REPORT-6
16114 3151
16115 3151              ;; OFLW2-CLR
16116 3151 77           L3151:  LD      (HL),A          ;
16117 3152 D9                   EXX                     ;
16118 3153 78                   LD      A,B             ;
16119 3154 D9                   EXX                     ;
16120 3155
16121 3155              ;; TEST-NORM
16122 3155 30 15        L3155:  JR      NC,L316C        ; to NORMALISE
16123 3157
16124 3157 7E                   LD      A,(HL)          ;
16125 3158 A7                   AND     A               ;
16126 3159
16127 3159              ;; NEAR-ZERO
16128 3159 3E 80        L3159:  LD      A,$80           ;
16129 315B 28 01                JR      Z,L315E         ; to SKIP-ZERO
16130 315D
16131 315D              ;; ZERO-RSLT
16132 315D AF           L315D:  XOR     A               ;
16133 315E
16134 315E              ;; SKIP-ZERO
16135 315E D9           L315E:  EXX                     ;
16136 315F A2                   AND     D               ;
16137 3160 CD FB 2F             CALL    L2FFB           ; routine ZEROS-4/5
16138 3163 07                   RLCA                    ;
16139 3164 77                   LD      (HL),A          ;
16140 3165 38 2E                JR      C,L3195         ; to OFLOW-CLR
16141 3167
16142 3167 23                   INC     HL              ;
16143 3168 77                   LD      (HL),A          ;
16144 3169 2B                   DEC     HL              ;
16145 316A 18 29                JR      L3195           ; to OFLOW-CLR
16146 316C
16147 316C              ; ---
16148 316C
16149 316C              ;; NORMALISE
16150 316C 06 20        L316C:  LD      B,$20           ;
16151 316E
16152 316E              ;; SHIFT-ONE
16153 316E D9           L316E:  EXX                     ;
16154 316F CB 7A                BIT     7,D             ;
16155 3171 D9                   EXX                     ;
16156 3172 20 12                JR      NZ,L3186        ; to NORML-NOW
16157 3174
16158 3174 07                   RLCA                    ;
16159 3175 CB 13                RL      E               ;
16160 3177 CB 12                RL      D               ;
16161 3179 D9                   EXX                     ;
16162 317A CB 13                RL      E               ;
16163 317C CB 12                RL      D               ;
16164 317E D9                   EXX                     ;
16165 317F 35                   DEC     (HL)            ;
16166 3180 28 D7                JR      Z,L3159         ; to NEAR-ZERO
16167 3182
16168 3182 10 EA                DJNZ    L316E           ; to SHIFT-ONE
16169 3184
16170 3184 18 D7                JR      L315D           ; to ZERO-RSLT
16171 3186
16172 3186              ; ---
16173 3186
16174 3186              ;; NORML-NOW
16175 3186 17           L3186:  RLA                     ;
16176 3187 30 0C                JR      NC,L3195        ; to OFLOW-CLR
16177 3189
16178 3189 CD 04 30             CALL    L3004           ; routine ADD-BACK
16179 318C 20 07                JR      NZ,L3195        ; to OFLOW-CLR
16180 318E
16181 318E D9                   EXX                     ;
16182 318F 16 80                LD       D,$80          ;
16183 3191 D9                   EXX                     ;
16184 3192 34                   INC     (HL)            ;
16185 3193 28 18                JR      Z,L31AD         ; to REPORT-6
16186 3195
16187 3195              ;; OFLOW-CLR
16188 3195 E5           L3195:  PUSH    HL              ;
16189 3196 23                   INC     HL              ;
16190 3197 D9                   EXX                     ;
16191 3198 D5                   PUSH    DE              ;
16192 3199 D9                   EXX                     ;
16193 319A C1                   POP     BC              ;
16194 319B 78                   LD      A,B             ;
16195 319C 17                   RLA                     ;
16196 319D CB 16                RL      (HL)            ;
16197 319F 1F                   RRA                     ;
16198 31A0 77                   LD      (HL),A          ;
16199 31A1 23                   INC     HL              ;
16200 31A2 71                   LD      (HL),C          ;
16201 31A3 23                   INC     HL              ;
16202 31A4 72                   LD      (HL),D          ;
16203 31A5 23                   INC     HL              ;
16204 31A6 73                   LD      (HL),E          ;
16205 31A7 E1                   POP     HL              ;
16206 31A8 D1                   POP     DE              ;
16207 31A9 D9                   EXX                     ;
16208 31AA E1                   POP     HL              ;
16209 31AB D9                   EXX                     ;
16210 31AC C9                   RET                     ;
16211 31AD
16212 31AD              ; ---
16213 31AD
16214 31AD              ;; REPORT-6
16215 31AD CF           L31AD:  RST     08H             ; ERROR-1
16216 31AE 05                   DEFB    $05             ; Error Report: Number too big
16217 31AF
16218 31AF              ; ----------------------
16219 31AF              ; THE 'DIVISION' ROUTINE
16220 31AF              ; ----------------------
16221 31AF              ; (offset: $05 'division')
16222 31AF              ;
16223 31AF              ;   "He who can properly define and divide is to be considered a god"
16224 31AF              ;   - Plato,  429 - 347 B.C.
16225 31AF
16226 31AF              ;; division
16227 31AF CD 93 32     L31AF:  CALL    L3293           ; routine RE-ST-TWO
16228 31B2 EB                   EX      DE,HL           ;
16229 31B3 AF                   XOR     A               ;
16230 31B4 CD C0 30             CALL    L30C0           ; routine PREP-M/D
16231 31B7 38 F4                JR      C,L31AD         ; to REPORT-6
16232 31B9
16233 31B9 EB                   EX      DE,HL           ;
16234 31BA CD C0 30             CALL    L30C0           ; routine PREP-M/D
16235 31BD D8                   RET     C               ;
16236 31BE
16237 31BE D9                   EXX                     ;
16238 31BF E5                   PUSH    HL              ;
16239 31C0 D9                   EXX                     ;
16240 31C1 D5                   PUSH    DE              ;
16241 31C2 E5                   PUSH    HL              ;
16242 31C3 CD BA 2F             CALL    L2FBA           ; routine FETCH-TWO
16243 31C6 D9                   EXX                     ;
16244 31C7 E5                   PUSH    HL              ;
16245 31C8 60                   LD      H,B             ;
16246 31C9 69                   LD      L,C             ;
16247 31CA D9                   EXX                     ;
16248 31CB 61                   LD      H,C             ;
16249 31CC 68                   LD      L,B             ;
16250 31CD AF                   XOR     A               ;
16251 31CE 06 DF                LD      B,$DF           ;
16252 31D0 18 10                JR      L31E2           ; to DIV-START
16253 31D2
16254 31D2              ; ---
16255 31D2
16256 31D2              ;; DIV-LOOP
16257 31D2 17           L31D2:  RLA                     ;
16258 31D3 CB 11                RL      C               ;
16259 31D5 D9                   EXX                     ;
16260 31D6 CB 11                RL      C               ;
16261 31D8 CB 10                RL      B               ;
16262 31DA D9                   EXX                     ;
16263 31DB
16264 31DB              ;; div-34th
16265 31DB 29           L31DB:  ADD     HL,HL           ;
16266 31DC D9                   EXX                     ;
16267 31DD ED 6A                ADC     HL,HL           ;
16268 31DF D9                   EXX                     ;
16269 31E0 38 10                JR      C,L31F2         ; to SUBN-ONLY
16270 31E2
16271 31E2              ;; DIV-START
16272 31E2 ED 52        L31E2:  SBC     HL,DE           ;
16273 31E4 D9                   EXX                     ;
16274 31E5 ED 52                SBC     HL,DE           ;
16275 31E7 D9                   EXX                     ;
16276 31E8 30 0F                JR      NC,L31F9        ; to NO-RSTORE
16277 31EA
16278 31EA 19                   ADD     HL,DE           ;
16279 31EB D9                   EXX                     ;
16280 31EC ED 5A                ADC     HL,DE           ;
16281 31EE D9                   EXX                     ;
16282 31EF A7                   AND     A               ;
16283 31F0 18 08                JR      L31FA           ; to COUNT-ONE
16284 31F2
16285 31F2              ; ---
16286 31F2
16287 31F2              ;; SUBN-ONLY
16288 31F2 A7           L31F2:  AND     A               ;
16289 31F3 ED 52                SBC     HL,DE           ;
16290 31F5 D9                   EXX                     ;
16291 31F6 ED 52                SBC     HL,DE           ;
16292 31F8 D9                   EXX                     ;
16293 31F9
16294 31F9              ;; NO-RSTORE
16295 31F9 37           L31F9:  SCF                     ; Set Carry Flag
16296 31FA
16297 31FA              ;; COUNT-ONE
16298 31FA 04           L31FA:  INC     B               ;
16299 31FB FA D2 31             JP      M,L31D2         ; to DIV-LOOP
16300 31FE
16301 31FE F5                   PUSH    AF              ;
16302 31FF 28 E1                JR      Z,L31E2         ; to DIV-START
16303 3201
16304 3201              ;
16305 3201              ;
16306 3201              ;
16307 3201              ;
16308 3201
16309 3201 5F                   LD      E,A             ;
16310 3202 51                   LD      D,C             ;
16311 3203 D9                   EXX                     ;
16312 3204 59                   LD      E,C             ;
16313 3205 50                   LD      D,B             ;
16314 3206 F1                   POP     AF              ;
16315 3207 CB 18                RR      B               ;
16316 3209 F1                   POP     AF              ;
16317 320A CB 18                RR      B               ;
16318 320C D9                   EXX                     ;
16319 320D C1                   POP     BC              ;
16320 320E E1                   POP     HL              ;
16321 320F 78                   LD      A,B             ;
16322 3210 91                   SUB     C               ;
16323 3211 C3 3D 31             JP      L313D           ; jump back to DIVN-EXPT
16324 3214
16325 3214              ; ------------------------------------
16326 3214              ; Integer truncation towards zero ($3A)
16327 3214              ; ------------------------------------
16328 3214              ;
16329 3214              ;
16330 3214
16331 3214              ;; truncate
16332 3214 7E           L3214:  LD      A,(HL)          ;
16333 3215 A7                   AND     A               ;
16334 3216 C8                   RET     Z               ;
16335 3217
16336 3217 FE 81                CP      $81             ;
16337 3219 30 06                JR      NC,L3221        ; to T-GR-ZERO
16338 321B
16339 321B 36 00                LD      (HL),$00        ;
16340 321D 3E 20                LD      A,$20           ;
16341 321F 18 51                JR      L3272           ; to NIL-BYTES
16342 3221
16343 3221              ; ---
16344 3221
16345 3221              ;; T-GR-ZERO
16346 3221 FE 91        L3221:  CP      $91             ;
16347 3223 20 1A                JR      NZ,L323F        ; to T-SMALL
16348 3225
16349 3225 23                   INC     HL              ;
16350 3226 23                   INC     HL              ;
16351 3227 23                   INC     HL              ;
16352 3228 3E 80                LD      A,$80           ;
16353 322A A6                   AND     (HL)            ;
16354 322B 2B                   DEC     HL              ;
16355 322C B6                   OR      (HL)            ;
16356 322D 2B                   DEC     HL              ;
16357 322E 20 03                JR      NZ,L3233        ; to T-FIRST
16358 3230
16359 3230 3E 80                LD      A,$80           ;
16360 3232 AE                   XOR     (HL)            ;
16361 3233
16362 3233              ;; T-FIRST
16363 3233 2B           L3233:  DEC     HL              ;
16364 3234 20 36                JR      NZ,L326C        ; to T-EXPNENT
16365 3236
16366 3236 77                   LD      (HL),A          ;
16367 3237 23                   INC     HL              ;
16368 3238 36 FF                LD      (HL),$FF        ;
16369 323A 2B                   DEC     HL              ;
16370 323B 3E 18                LD      A,$18           ;
16371 323D 18 33                JR      L3272           ; to NIL-BYTES
16372 323F
16373 323F              ; ---
16374 323F
16375 323F              ;; T-SMALL
16376 323F 30 2C        L323F:  JR      NC,L326D        ; to X-LARGE
16377 3241
16378 3241 D5                   PUSH    DE              ;
16379 3242 2F                   CPL                     ;
16380 3243 C6 91                ADD     A,$91           ;
16381 3245 23                   INC     HL              ;
16382 3246 56                   LD      D,(HL)          ;
16383 3247 23                   INC     HL              ;
16384 3248 5E                   LD      E,(HL)          ;
16385 3249 2B                   DEC     HL              ;
16386 324A 2B                   DEC     HL              ;
16387 324B 0E 00                LD      C,$00           ;
16388 324D CB 7A                BIT     7,D             ;
16389 324F 28 01                JR      Z,L3252         ; to T-NUMERIC
16390 3251
16391 3251 0D                   DEC     C               ;
16392 3252
16393 3252              ;; T-NUMERIC
16394 3252 CB FA        L3252:  SET     7,D             ;
16395 3254 06 08                LD      B,$08           ;
16396 3256 90                   SUB     B               ;
16397 3257 80                   ADD     A,B             ;
16398 3258 38 04                JR      C,L325E         ; to T-TEST
16399 325A
16400 325A 5A                   LD      E,D             ;
16401 325B 16 00                LD      D,$00           ;
16402 325D 90                   SUB     B               ;
16403 325E
16404 325E              ;; T-TEST
16405 325E 28 07        L325E:  JR      Z,L3267         ; to T-STORE
16406 3260
16407 3260 47                   LD      B,A             ;
16408 3261
16409 3261              ;; T-SHIFT
16410 3261 CB 3A        L3261:  SRL     D               ;
16411 3263 CB 1B                RR      E               ;
16412 3265 10 FA                DJNZ    L3261           ; to T-SHIFT
16413 3267
16414 3267              ;; T-STORE
16415 3267 CD 8E 2D     L3267:  CALL    L2D8E           ; routine INT-STORE
16416 326A D1                   POP     DE              ;
16417 326B C9                   RET                     ;
16418 326C
16419 326C              ; ---
16420 326C
16421 326C              ;; T-EXPNENT
16422 326C 7E           L326C:  LD      A,(HL)          ;
16423 326D
16424 326D              ;; X-LARGE
16425 326D D6 A0        L326D:  SUB     $A0             ;
16426 326F F0                   RET     P               ;
16427 3270
16428 3270 ED 44                NEG                     ; Negate
16429 3272
16430 3272              ;; NIL-BYTES
16431 3272 D5           L3272:  PUSH    DE              ;
16432 3273 EB                   EX      DE,HL           ;
16433 3274 2B                   DEC     HL              ;
16434 3275 47                   LD      B,A             ;
16435 3276 CB 38                SRL     B               ;
16436 3278 CB 38                SRL     B               ;
16437 327A CB 38                SRL     B               ;
16438 327C 28 05                JR      Z,L3283         ; to BITS-ZERO
16439 327E
16440 327E              ;; BYTE-ZERO
16441 327E 36 00        L327E:  LD      (HL),$00        ;
16442 3280 2B                   DEC     HL              ;
16443 3281 10 FB                DJNZ    L327E           ; to BYTE-ZERO
16444 3283
16445 3283              ;; BITS-ZERO
16446 3283 E6 07        L3283:  AND     $07             ;
16447 3285 28 09                JR      Z,L3290         ; to IX-END
16448 3287
16449 3287 47                   LD      B,A             ;
16450 3288 3E FF                LD      A,$FF           ;
16451 328A
16452 328A              ;; LESS-MASK
16453 328A CB 27        L328A:  SLA     A               ;
16454 328C 10 FC                DJNZ    L328A           ; to LESS-MASK
16455 328E
16456 328E A6                   AND     (HL)            ;
16457 328F 77                   LD      (HL),A          ;
16458 3290
16459 3290              ;; IX-END
16460 3290 EB           L3290:  EX      DE,HL           ;
16461 3291 D1                   POP     DE              ;
16462 3292 C9                   RET                     ;
16463 3293
16464 3293              ; ----------------------------------
16465 3293              ; Storage of numbers in 5 byte form.
16466 3293              ; ==================================
16467 3293              ; Both integers and floating-point numbers can be stored in five bytes.
16468 3293              ; Zero is a special case stored as 5 zeros.
16469 3293              ; For integers the form is
16470 3293              ; Byte 1 - zero,
16471 3293              ; Byte 2 - sign byte, $00 +ve, $FF -ve.
16472 3293              ; Byte 3 - Low byte of integer.
16473 3293              ; Byte 4 - High byte
16474 3293              ; Byte 5 - unused but always zero.
16475 3293              ;
16476 3293              ; it seems unusual to store the low byte first but it is just as easy either
16477 3293              ; way. Statistically it just increases the chances of trailing zeros which
16478 3293              ; is an advantage elsewhere in saving ROM code.
16479 3293              ;
16480 3293              ;             zero     sign     low      high    unused
16481 3293              ; So +1 is  00000000 00000000 00000001 00000000 00000000
16482 3293              ;
16483 3293              ; and -1 is 00000000 11111111 11111111 11111111 00000000
16484 3293              ;
16485 3293              ; much of the arithmetic found in BASIC lines can be done using numbers
16486 3293              ; in this form using the Z80's 16 bit register operation ADD.
16487 3293              ; (multiplication is done by a sequence of additions).
16488 3293              ;
16489 3293              ; Storing -ve integers in two's complement form, means that they are ready for
16490 3293              ; addition and you might like to add the numbers above to prove that the
16491 3293              ; answer is zero. If, as in this case, the carry is set then that denotes that
16492 3293              ; the result is positive. This only applies when the signs don't match.
16493 3293              ; With positive numbers a carry denotes the result is out of integer range.
16494 3293              ; With negative numbers a carry denotes the result is within range.
16495 3293              ; The exception to the last rule is when the result is -65536
16496 3293              ;
16497 3293              ; Floating point form is an alternative method of storing numbers which can
16498 3293              ; be used for integers and larger (or fractional) numbers.
16499 3293              ;
16500 3293              ; In this form 1 is stored as
16501 3293              ;           10000001 00000000 00000000 00000000 00000000
16502 3293              ;
16503 3293              ; When a small integer is converted to a floating point number the last two
16504 3293              ; bytes are always blank so they are omitted in the following steps
16505 3293              ;
16506 3293              ; first make exponent +1 +16d  (bit 7 of the exponent is set if positive)
16507 3293
16508 3293              ; 10010001 00000000 00000001
16509 3293              ; 10010000 00000000 00000010 <-  now shift left and decrement exponent
16510 3293              ; ...
16511 3293              ; 10000010 01000000 00000000 <-  until a 1 abuts the imaginary point
16512 3293              ; 10000001 10000000 00000000     to the left of the mantissa.
16513 3293              ;
16514 3293              ; however since the leftmost bit of the mantissa is always set then it can
16515 3293              ; be used to denote the sign of the mantissa and put back when needed by the
16516 3293              ; PREP routines which gives
16517 3293              ;
16518 3293              ; 10000001 00000000 00000000
16519 3293
16520 3293              ; ----------------------------------------------
16521 3293              ; THE 'RE-STACK TWO "SMALL" INTEGERS' SUBROUTINE
16522 3293              ; ----------------------------------------------
16523 3293              ;   This routine is called to re-stack two numbers in full floating point form
16524 3293              ;   e.g. from mult when integer multiplication has overflowed.
16525 3293
16526 3293              ;; RE-ST-TWO
16527 3293 CD 96 32     L3293:  CALL    L3296           ; routine RESTK-SUB  below and continue
16528 3296                                              ; into the routine to do the other one.
16529 3296
16530 3296              ;; RESTK-SUB
16531 3296 EB           L3296:  EX      DE,HL           ; swap pointers
16532 3297
16533 3297              ; ---------------------------------------------
16534 3297              ; THE 'RE-STACK ONE "SMALL" INTEGER' SUBROUTINE
16535 3297              ; ---------------------------------------------
16536 3297              ; (offset: $3D 're-stack')
16537 3297              ;   This routine re-stacks an integer, usually on the calculator stack, in full
16538 3297              ;   floating point form.  HL points to first byte.
16539 3297
16540 3297              ;; re-stack
16541 3297 7E           L3297:  LD      A,(HL)          ; Fetch Exponent byte to A
16542 3298 A7                   AND     A               ; test it
16543 3299 C0                   RET     NZ              ; return if not zero as already in full
16544 329A                                              ; floating-point form.
16545 329A
16546 329A D5                   PUSH    DE              ; preserve DE.
16547 329B CD 7F 2D             CALL    L2D7F           ; routine INT-FETCH
16548 329E                                              ; integer to DE, sign to C.
16549 329E
16550 329E              ; HL points to 4th byte.
16551 329E
16552 329E AF                   XOR     A               ; clear accumulator.
16553 329F 23                   INC     HL              ; point to 5th.
16554 32A0 77                   LD      (HL),A          ; and blank.
16555 32A1 2B                   DEC     HL              ; point to 4th.
16556 32A2 77                   LD      (HL),A          ; and blank.
16557 32A3
16558 32A3 06 91                LD      B,$91           ; set exponent byte +ve $81
16559 32A5                                              ; and imaginary dec point 16 bits to right
16560 32A5                                              ; of first bit.
16561 32A5
16562 32A5              ;   we could skip to normalize now but it's quicker to avoid normalizing
16563 32A5              ;   through an empty D.
16564 32A5
16565 32A5 7A                   LD      A,D             ; fetch the high byte D
16566 32A6 A7                   AND     A               ; is it zero ?
16567 32A7 20 08                JR      NZ,L32B1        ; skip to RS-NRMLSE if not.
16568 32A9
16569 32A9 B3                   OR      E               ; low byte E to A and test for zero
16570 32AA 42                   LD      B,D             ; set B exponent to 0
16571 32AB 28 10                JR      Z,L32BD         ; forward to RS-STORE if value is zero.
16572 32AD
16573 32AD 53                   LD      D,E             ; transfer E to D
16574 32AE 58                   LD      E,B             ; set E to 0
16575 32AF 06 89                LD      B,$89           ; reduce the initial exponent by eight.
16576 32B1
16577 32B1
16578 32B1              ;; RS-NRMLSE
16579 32B1 EB           L32B1:  EX      DE,HL           ; integer to HL, addr of 4th byte to DE.
16580 32B2
16581 32B2              ;; RSTK-LOOP
16582 32B2 05           L32B2:  DEC     B               ; decrease exponent
16583 32B3 29                   ADD     HL,HL           ; shift DE left
16584 32B4 30 FC                JR      NC,L32B2        ; loop back to RSTK-LOOP
16585 32B6                                              ; until a set bit pops into carry
16586 32B6
16587 32B6 CB 09                RRC     C               ; now rotate the sign byte $00 or $FF
16588 32B8                                              ; into carry to give a sign bit
16589 32B8
16590 32B8 CB 1C                RR      H               ; rotate the sign bit to left of H
16591 32BA CB 1D                RR      L               ; rotate any carry into L
16592 32BC
16593 32BC EB                   EX      DE,HL           ; address 4th byte, normalized int to DE
16594 32BD
16595 32BD              ;; RS-STORE
16596 32BD 2B           L32BD:  DEC     HL              ; address 3rd byte
16597 32BE 73                   LD      (HL),E          ; place E
16598 32BF 2B                   DEC     HL              ; address 2nd byte
16599 32C0 72                   LD      (HL),D          ; place D
16600 32C1 2B                   DEC     HL              ; address 1st byte
16601 32C2 70                   LD      (HL),B          ; store the exponent
16602 32C3
16603 32C3 D1                   POP     DE              ; restore initial DE.
16604 32C4 C9                   RET                     ; return.
16605 32C5
16606 32C5              ;****************************************
16607 32C5              ;** Part 10. FLOATING-POINT CALCULATOR **
16608 32C5              ;****************************************
16609 32C5
16610 32C5              ; As a general rule the calculator avoids using the IY register.
16611 32C5              ; exceptions are val, val$ and str$.
16612 32C5              ; So an assembly language programmer who has disabled interrupts to use
16613 32C5              ; IY for other purposes can still use the calculator for mathematical
16614 32C5              ; purposes.
16615 32C5
16616 32C5
16617 32C5              ; ------------------------
16618 32C5              ; THE 'TABLE OF CONSTANTS'
16619 32C5              ; ------------------------
16620 32C5              ;
16621 32C5              ;
16622 32C5
16623 32C5              ; used 11 times
16624 32C5              ;; stk-zero                                                 00 00 00 00 00
16625 32C5 00           L32C5:  DEFB    $00             ;;Bytes: 1
16626 32C6 B0                   DEFB    $B0             ;;Exponent $00
16627 32C7 00                   DEFB    $00             ;;(+00,+00,+00)
16628 32C8
16629 32C8              ; used 19 times
16630 32C8              ;; stk-one                                                  00 00 01 00 00
16631 32C8 40           L32C8:  DEFB    $40             ;;Bytes: 2
16632 32C9 B0                   DEFB    $B0             ;;Exponent $00
16633 32CA 00 01                DEFB    $00,$01         ;;(+00,+00)
16634 32CC
16635 32CC              ; used 9 times
16636 32CC              ;; stk-half                                                 80 00 00 00 00
16637 32CC 30           L32CC:  DEFB    $30             ;;Exponent: $80, Bytes: 1
16638 32CD 00                   DEFB    $00             ;;(+00,+00,+00)
16639 32CE
16640 32CE              ; used 4 times.
16641 32CE              ;; stk-pi/2                                                 81 49 0F DA A2
16642 32CE F1           L32CE:  DEFB    $F1             ;;Exponent: $81, Bytes: 4
16643 32CF 49 0F DA A2          DEFB    $49,$0F,$DA,$A2 ;;
16644 32D3
16645 32D3              ; used 3 times.
16646 32D3              ;; stk-ten                                                  00 00 0A 00 00
16647 32D3 40           L32D3:  DEFB    $40             ;;Bytes: 2
16648 32D4 B0                   DEFB    $B0             ;;Exponent $00
16649 32D5 00 0A                DEFB    $00,$0A         ;;(+00,+00)
16650 32D7
16651 32D7
16652 32D7              ; ------------------------
16653 32D7              ; THE 'TABLE OF ADDRESSES'
16654 32D7              ; ------------------------
16655 32D7              ;  "Each problem that I solved became a rule which served afterwards to solve
16656 32D7              ;   other problems" - Rene Descartes 1596 - 1650.
16657 32D7              ;
16658 32D7              ;   Starts with binary operations which have two operands and one result.
16659 32D7              ;   Three pseudo binary operations first.
16660 32D7
16661 32D7              ;; tbl-addrs
16662 32D7 8F 36        L32D7:  DEFW    L368F           ; $00 Address: $368F - jump-true
16663 32D9 3C 34                DEFW    L343C           ; $01 Address: $343C - exchange
16664 32DB A1 33                DEFW    L33A1           ; $02 Address: $33A1 - delete
16665 32DD
16666 32DD              ;   True binary operations.
16667 32DD
16668 32DD 0F 30                DEFW    L300F           ; $03 Address: $300F - subtract
16669 32DF CA 30                DEFW    L30CA           ; $04 Address: $30CA - multiply
16670 32E1 AF 31                DEFW    L31AF           ; $05 Address: $31AF - division
16671 32E3 51 38                DEFW    L3851           ; $06 Address: $3851 - to-power
16672 32E5 1B 35                DEFW    L351B           ; $07 Address: $351B - or
16673 32E7
16674 32E7 24 35                DEFW    L3524           ; $08 Address: $3524 - no-&-no
16675 32E9 3B 35                DEFW    L353B           ; $09 Address: $353B - no-l-eql
16676 32EB 3B 35                DEFW    L353B           ; $0A Address: $353B - no-gr-eql
16677 32ED 3B 35                DEFW    L353B           ; $0B Address: $353B - nos-neql
16678 32EF 3B 35                DEFW    L353B           ; $0C Address: $353B - no-grtr
16679 32F1 3B 35                DEFW    L353B           ; $0D Address: $353B - no-less
16680 32F3 3B 35                DEFW    L353B           ; $0E Address: $353B - nos-eql
16681 32F5 14 30                DEFW    L3014           ; $0F Address: $3014 - addition
16682 32F7
16683 32F7 2D 35                DEFW    L352D           ; $10 Address: $352D - str-&-no
16684 32F9 3B 35                DEFW    L353B           ; $11 Address: $353B - str-l-eql
16685 32FB 3B 35                DEFW    L353B           ; $12 Address: $353B - str-gr-eql
16686 32FD 3B 35                DEFW    L353B           ; $13 Address: $353B - strs-neql
16687 32FF 3B 35                DEFW    L353B           ; $14 Address: $353B - str-grtr
16688 3301 3B 35                DEFW    L353B           ; $15 Address: $353B - str-less
16689 3303 3B 35                DEFW    L353B           ; $16 Address: $353B - strs-eql
16690 3305 9C 35                DEFW    L359C           ; $17 Address: $359C - strs-add
16691 3307
16692 3307              ;   Unary follow.
16693 3307
16694 3307 DE 35                DEFW    L35DE           ; $18 Address: $35DE - val$
16695 3309 BC 34                DEFW    L34BC           ; $19 Address: $34BC - usr-$
16696 330B 45 36                DEFW    L3645           ; $1A Address: $3645 - read-in
16697 330D 6E 34                DEFW    L346E           ; $1B Address: $346E - negate
16698 330F
16699 330F 69 36                DEFW    L3669           ; $1C Address: $3669 - code
16700 3311 DE 35                DEFW    L35DE           ; $1D Address: $35DE - val
16701 3313 74 36                DEFW    L3674           ; $1E Address: $3674 - len
16702 3315 B5 37                DEFW    L37B5           ; $1F Address: $37B5 - sin
16703 3317 AA 37                DEFW    L37AA           ; $20 Address: $37AA - cos
16704 3319 DA 37                DEFW    L37DA           ; $21 Address: $37DA - tan
16705 331B 33 38                DEFW    L3833           ; $22 Address: $3833 - asn
16706 331D 43 38                DEFW    L3843           ; $23 Address: $3843 - acs
16707 331F E2 37                DEFW    L37E2           ; $24 Address: $37E2 - atn
16708 3321 13 37                DEFW    L3713           ; $25 Address: $3713 - ln
16709 3323 C4 36                DEFW    L36C4           ; $26 Address: $36C4 - exp
16710 3325 AF 36                DEFW    L36AF           ; $27 Address: $36AF - int
16711 3327 4A 38                DEFW    L384A           ; $28 Address: $384A - sqr
16712 3329 92 34                DEFW    L3492           ; $29 Address: $3492 - sgn
16713 332B 6A 34                DEFW    L346A           ; $2A Address: $346A - abs
16714 332D AC 34                DEFW    L34AC           ; $2B Address: $34AC - peek
16715 332F A5 34                DEFW    L34A5           ; $2C Address: $34A5 - in
16716 3331 B3 34                DEFW    L34B3           ; $2D Address: $34B3 - usr-no
16717 3333 1F 36                DEFW    L361F           ; $2E Address: $361F - str$
16718 3335 C9 35                DEFW    L35C9           ; $2F Address: $35C9 - chrs
16719 3337 01 35                DEFW    L3501           ; $30 Address: $3501 - not
16720 3339
16721 3339              ;   End of true unary.
16722 3339
16723 3339 C0 33                DEFW    L33C0           ; $31 Address: $33C0 - duplicate
16724 333B A0 36                DEFW    L36A0           ; $32 Address: $36A0 - n-mod-m
16725 333D 86 36                DEFW    L3686           ; $33 Address: $3686 - jump
16726 333F C6 33                DEFW    L33C6           ; $34 Address: $33C6 - stk-data
16727 3341 7A 36                DEFW    L367A           ; $35 Address: $367A - dec-jr-nz
16728 3343 06 35                DEFW    L3506           ; $36 Address: $3506 - less-0
16729 3345 F9 34                DEFW    L34F9           ; $37 Address: $34F9 - greater-0
16730 3347 9B 36                DEFW    L369B           ; $38 Address: $369B - end-calc
16731 3349 83 37                DEFW    L3783           ; $39 Address: $3783 - get-argt
16732 334B 14 32                DEFW    L3214           ; $3A Address: $3214 - truncate
16733 334D A2 33                DEFW    L33A2           ; $3B Address: $33A2 - fp-calc-2
16734 334F 4F 2D                DEFW    L2D4F           ; $3C Address: $2D4F - e-to-fp
16735 3351 97 32                DEFW    L3297           ; $3D Address: $3297 - re-stack
16736 3353
16737 3353              ;   The following are just the next available slots for the 128 compound
16738 3353              ;   literals which are in range $80 - $FF.
16739 3353
16740 3353 49 34                DEFW    L3449           ;     Address: $3449 - series-xx    $80 - $9F.
16741 3355 1B 34                DEFW    L341B           ;     Address: $341B - stk-const-xx $A0 - $BF.
16742 3357 2D 34                DEFW    L342D           ;     Address: $342D - st-mem-xx    $C0 - $DF.
16743 3359 0F 34                DEFW    L340F           ;     Address: $340F - get-mem-xx   $E0 - $FF.
16744 335B
16745 335B              ;   Aside: 3E - 3F are therefore unused calculator literals.
16746 335B              ;   If the literal has to be also usable as a function then bits 6 and 7 are
16747 335B              ;   used to show type of arguments and result.
16748 335B
16749 335B              ; --------------
16750 335B              ; The Calculator
16751 335B              ; --------------
16752 335B              ;  "A good calculator does not need artificial aids"
16753 335B              ;  Lao Tze 604 - 531 B.C.
16754 335B
16755 335B              ;; CALCULATE
16756 335B CD BF 35     L335B:  CALL    L35BF           ; routine STK-PNTRS is called to set up the
16757 335E                                              ; calculator stack pointers for a default
16758 335E                                              ; unary operation. HL = last value on stack.
16759 335E                                              ; DE = STKEND first location after stack.
16760 335E
16761 335E              ; the calculate routine is called at this point by the series generator...
16762 335E
16763 335E              ;; GEN-ENT-1
16764 335E 78           L335E:  LD      A,B             ; fetch the Z80 B register to A
16765 335F 32 67 5C             LD      ($5C67),A       ; and store value in system variable BREG.
16766 3362                                              ; this will be the counter for dec-jr-nz
16767 3362                                              ; or if used from fp-calc2 the calculator
16768 3362                                              ; instruction.
16769 3362
16770 3362              ; ... and again later at this point
16771 3362
16772 3362              ;; GEN-ENT-2
16773 3362 D9           L3362:  EXX                     ; switch sets
16774 3363 E3                   EX      (SP),HL         ; and store the address of next instruction,
16775 3364                                              ; the return address, in H'L'.
16776 3364                                              ; If this is a recursive call the H'L'
16777 3364                                              ; of the previous invocation goes on stack.
16778 3364                                              ; c.f. end-calc.
16779 3364 D9                   EXX                     ; switch back to main set
16780 3365
16781 3365              ; this is the re-entry looping point when handling a string of literals.
16782 3365
16783 3365              ;; RE-ENTRY
16784 3365 ED 53 65 5C  L3365:  LD      ($5C65),DE      ; save end of stack in system variable STKEND
16785 3369 D9                   EXX                     ; switch to alt
16786 336A 7E                   LD      A,(HL)          ; get next literal
16787 336B 23                   INC     HL              ; increase pointer'
16788 336C
16789 336C              ; single operation jumps back to here
16790 336C
16791 336C              ;; SCAN-ENT
16792 336C E5           L336C:  PUSH    HL              ; save pointer on stack
16793 336D A7                   AND     A               ; now test the literal
16794 336E F2 80 33             JP      P,L3380         ; forward to FIRST-3D if in range $00 - $3D
16795 3371                                              ; anything with bit 7 set will be one of
16796 3371                                              ; 128 compound literals.
16797 3371
16798 3371              ; compound literals have the following format.
16799 3371              ; bit 7 set indicates compound.
16800 3371              ; bits 6-5 the subgroup 0-3.
16801 3371              ; bits 4-0 the embedded parameter $00 - $1F.
16802 3371              ; The subgroup 0-3 needs to be manipulated to form the next available four
16803 3371              ; address places after the simple literals in the address table.
16804 3371
16805 3371 57                   LD      D,A             ; save literal in D
16806 3372 E6 60                AND     $60             ; and with 01100000 to isolate subgroup
16807 3374 0F                   RRCA                    ; rotate bits
16808 3375 0F                   RRCA                    ; 4 places to right
16809 3376 0F                   RRCA                    ; not five as we need offset * 2
16810 3377 0F                   RRCA                    ; 00000xx0
16811 3378 C6 7C                ADD     A,$7C           ; add ($3E * 2) to give correct offset.
16812 337A                                              ; alter above if you add more literals.
16813 337A 6F                   LD      L,A             ; store in L for later indexing.
16814 337B 7A                   LD      A,D             ; bring back compound literal
16815 337C E6 1F                AND     $1F             ; use mask to isolate parameter bits
16816 337E 18 0E                JR      L338E           ; forward to ENT-TABLE
16817 3380
16818 3380              ; ---
16819 3380
16820 3380              ; the branch was here with simple literals.
16821 3380
16822 3380              ;; FIRST-3D
16823 3380 FE 18        L3380:  CP      $18             ; compare with first unary operations.
16824 3382 30 08                JR      NC,L338C        ; to DOUBLE-A with unary operations
16825 3384
16826 3384              ; it is binary so adjust pointers.
16827 3384
16828 3384 D9                   EXX                     ;
16829 3385 01 FB FF             LD      BC,$FFFB        ; the value -5
16830 3388 54                   LD      D,H             ; transfer HL, the last value, to DE.
16831 3389 5D                   LD      E,L             ;
16832 338A 09                   ADD     HL,BC           ; subtract 5 making HL point to second
16833 338B                                              ; value.
16834 338B D9                   EXX                     ;
16835 338C
16836 338C              ;; DOUBLE-A
16837 338C 07           L338C:  RLCA                    ; double the literal
16838 338D 6F                   LD      L,A             ; and store in L for indexing
16839 338E
16840 338E              ;; ENT-TABLE
16841 338E 11 D7 32     L338E:  LD      DE,L32D7        ; Address: tbl-addrs
16842 3391 26 00                LD      H,$00           ; prepare to index
16843 3393 19                   ADD     HL,DE           ; add to get address of routine
16844 3394 5E                   LD      E,(HL)          ; low byte to E
16845 3395 23                   INC     HL              ;
16846 3396 56                   LD      D,(HL)          ; high byte to D
16847 3397 21 65 33             LD      HL,L3365        ; Address: RE-ENTRY
16848 339A E3                   EX      (SP),HL         ; goes to stack
16849 339B D5                   PUSH    DE              ; now address of routine
16850 339C D9                   EXX                     ; main set
16851 339D                                              ; avoid using IY register.
16852 339D ED 4B 66 5C          LD      BC,($5C66)      ; STKEND_hi
16853 33A1                                              ; nothing much goes to C but BREG to B
16854 33A1                                              ; and continue into next ret instruction
16855 33A1                                              ; which has a dual identity
16856 33A1
16857 33A1
16858 33A1              ; ------------------
16859 33A1              ; Handle delete (02)
16860 33A1              ; ------------------
16861 33A1              ; A simple return but when used as a calculator literal this
16862 33A1              ; deletes the last value from the calculator stack.
16863 33A1              ; On entry, as always with binary operations,
16864 33A1              ; HL=first number, DE=second number
16865 33A1              ; On exit, HL=result, DE=stkend.
16866 33A1              ; So nothing to do
16867 33A1
16868 33A1              ;; delete
16869 33A1 C9           L33A1:  RET                     ; return - indirect jump if from above.
16870 33A2
16871 33A2              ; ---------------------
16872 33A2              ; Single operation (3B)
16873 33A2              ; ---------------------
16874 33A2              ;   This single operation is used, in the first instance, to evaluate most
16875 33A2              ;   of the mathematical and string functions found in BASIC expressions.
16876 33A2
16877 33A2              ;; fp-calc-2
16878 33A2 F1           L33A2:  POP     AF              ; drop return address.
16879 33A3 3A 67 5C             LD      A,($5C67)       ; load accumulator from system variable BREG
16880 33A6                                              ; value will be literal e.g. 'tan'
16881 33A6 D9                   EXX                     ; switch to alt
16882 33A7 18 C3                JR      L336C           ; back to SCAN-ENT
16883 33A9                                              ; next literal will be end-calc at L2758
16884 33A9
16885 33A9              ; ---------------------------------
16886 33A9              ; THE 'TEST FIVE SPACES' SUBROUTINE
16887 33A9              ; ---------------------------------
16888 33A9              ;   This routine is called from MOVE-FP, STK-CONST and STK-STORE to test that
16889 33A9              ;   there is enough space between the calculator stack and the machine stack
16890 33A9              ;   for another five-byte value.  It returns with BC holding the value 5 ready
16891 33A9              ;   for any subsequent LDIR.
16892 33A9
16893 33A9              ;; TEST-5-SP
16894 33A9 D5           L33A9:  PUSH    DE              ; save
16895 33AA E5                   PUSH    HL              ; registers
16896 33AB 01 05 00             LD      BC,$0005        ; an overhead of five bytes
16897 33AE CD 05 1F             CALL    L1F05           ; routine TEST-ROOM tests free RAM raising
16898 33B1                                              ; an error if not.
16899 33B1 E1                   POP     HL              ; else restore
16900 33B2 D1                   POP     DE              ; registers.
16901 33B3 C9                   RET                     ; return with BC set at 5.
16902 33B4
16903 33B4              ; -----------------------------
16904 33B4              ; THE 'STACK NUMBER' SUBROUTINE
16905 33B4              ; -----------------------------
16906 33B4              ;   This routine is called to stack a hidden floating point number found in
16907 33B4              ;   a BASIC line.  It is also called to stack a numeric variable value, and
16908 33B4              ;   from BEEP, to stack an entry in the semi-tone table.  It is not part of the
16909 33B4              ;   calculator suite of routines.  On entry, HL points to the number to be
16910 33B4              ;   stacked.
16911 33B4
16912 33B4              ;; STACK-NUM
16913 33B4 ED 5B 65 5C  L33B4:  LD      DE,($5C65)      ; Load destination from STKEND system variable.
16914 33B8
16915 33B8 CD C0 33             CALL    L33C0           ; Routine MOVE-FP puts on calculator stack
16916 33BB                                              ; with a memory check.
16917 33BB ED 53 65 5C          LD      ($5C65),DE      ; Set STKEND to next free location.
16918 33BF
16919 33BF C9                   RET                     ; Return.
16920 33C0
16921 33C0              ; ---------------------------------
16922 33C0              ; Move a floating point number (31)
16923 33C0              ; ---------------------------------
16924 33C0
16925 33C0              ; This simple routine is a 5-byte LDIR instruction
16926 33C0              ; that incorporates a memory check.
16927 33C0              ; When used as a calculator literal it duplicates the last value on the
16928 33C0              ; calculator stack.
16929 33C0              ; Unary so on entry HL points to last value, DE to stkend
16930 33C0
16931 33C0              ;; duplicate
16932 33C0              ;; MOVE-FP
16933 33C0 CD A9 33     L33C0:  CALL    L33A9           ; routine TEST-5-SP test free memory
16934 33C3                                              ; and sets BC to 5.
16935 33C3 ED B0                LDIR                    ; copy the five bytes.
16936 33C5 C9                   RET                     ; return with DE addressing new STKEND
16937 33C6                                              ; and HL addressing new last value.
16938 33C6
16939 33C6              ; -------------------
16940 33C6              ; Stack literals ($34)
16941 33C6              ; -------------------
16942 33C6              ; When a calculator subroutine needs to put a value on the calculator
16943 33C6              ; stack that is not a regular constant this routine is called with a
16944 33C6              ; variable number of following data bytes that convey to the routine
16945 33C6              ; the integer or floating point form as succinctly as is possible.
16946 33C6
16947 33C6              ;; stk-data
16948 33C6 62           L33C6:  LD      H,D             ; transfer STKEND
16949 33C7 6B                   LD      L,E             ; to HL for result.
16950 33C8
16951 33C8              ;; STK-CONST
16952 33C8 CD A9 33     L33C8:  CALL    L33A9           ; routine TEST-5-SP tests that room exists
16953 33CB                                              ; and sets BC to $05.
16954 33CB
16955 33CB D9                   EXX                     ; switch to alternate set
16956 33CC E5                   PUSH    HL              ; save the pointer to next literal on stack
16957 33CD D9                   EXX                     ; switch back to main set
16958 33CE
16959 33CE E3                   EX      (SP),HL         ; pointer to HL, destination to stack.
16960 33CF
16961 33CF C5                   PUSH    BC              ; save BC - value 5 from test room ??.
16962 33D0
16963 33D0 7E                   LD      A,(HL)          ; fetch the byte following 'stk-data'
16964 33D1 E6 C0                AND     $C0             ; isolate bits 7 and 6
16965 33D3 07                   RLCA                    ; rotate
16966 33D4 07                   RLCA                    ; to bits 1 and 0  range $00 - $03.
16967 33D5 4F                   LD      C,A             ; transfer to C
16968 33D6 0C                   INC     C               ; and increment to give number of bytes
16969 33D7                                              ; to read. $01 - $04
16970 33D7 7E                   LD      A,(HL)          ; reload the first byte
16971 33D8 E6 3F                AND     $3F             ; mask off to give possible exponent.
16972 33DA 20 02                JR      NZ,L33DE        ; forward to FORM-EXP if it was possible to
16973 33DC                                              ; include the exponent.
16974 33DC
16975 33DC              ; else byte is just a byte count and exponent comes next.
16976 33DC
16977 33DC 23                   INC     HL              ; address next byte and
16978 33DD 7E                   LD      A,(HL)          ; pick up the exponent ( - $50).
16979 33DE
16980 33DE              ;; FORM-EXP
16981 33DE C6 50        L33DE:  ADD     A,$50           ; now add $50 to form actual exponent
16982 33E0 12                   LD      (DE),A          ; and load into first destination byte.
16983 33E1 3E 05                LD      A,$05           ; load accumulator with $05 and
16984 33E3 91                   SUB     C               ; subtract C to give count of trailing
16985 33E4                                              ; zeros plus one.
16986 33E4 23                   INC     HL              ; increment source
16987 33E5 13                   INC     DE              ; increment destination
16988 33E6 06 00                LD      B,$00           ; prepare to copy
16989 33E8 ED B0                LDIR                    ; copy C bytes
16990 33EA
16991 33EA C1                   POP     BC              ; restore 5 counter to BC ??.
16992 33EB
16993 33EB E3                   EX      (SP),HL         ; put HL on stack as next literal pointer
16994 33EC                                              ; and the stack value - result pointer -
16995 33EC                                              ; to HL.
16996 33EC
16997 33EC D9                   EXX                     ; switch to alternate set.
16998 33ED E1                   POP     HL              ; restore next literal pointer from stack
16999 33EE                                              ; to H'L'.
17000 33EE D9                   EXX                     ; switch back to main set.
17001 33EF
17002 33EF 47                   LD      B,A             ; zero count to B
17003 33F0 AF                   XOR     A               ; clear accumulator
17004 33F1
17005 33F1              ;; STK-ZEROS
17006 33F1 05           L33F1:  DEC     B               ; decrement B counter
17007 33F2 C8                   RET     Z               ; return if zero.          >>
17008 33F3                                              ; DE points to new STKEND
17009 33F3                                              ; HL to new number.
17010 33F3
17011 33F3 12                   LD      (DE),A          ; else load zero to destination
17012 33F4 13                   INC     DE              ; increase destination
17013 33F5 18 FA                JR      L33F1           ; loop back to STK-ZEROS until done.
17014 33F7
17015 33F7              ; -------------------------------
17016 33F7              ; THE 'SKIP CONSTANTS' SUBROUTINE
17017 33F7              ; -------------------------------
17018 33F7              ;   This routine traverses variable-length entries in the table of constants,
17019 33F7              ;   stacking intermediate, unwanted constants onto a dummy calculator stack,
17020 33F7              ;   in the first five bytes of ROM.  The destination DE normally points to the
17021 33F7              ;   end of the calculator stack which might be in the normal place or in the
17022 33F7              ;   system variables area during E-LINE-NO; INT-TO-FP; stk-ten.  In any case,
17023 33F7              ;   it would be simpler all round if the routine just shoved unwanted values
17024 33F7              ;   where it is going to stick the wanted value.  The instruction LD DE, $0000
17025 33F7              ;   can be removed.
17026 33F7
17027 33F7              ;; SKIP-CONS
17028 33F7 A7           L33F7:  AND     A               ; test if initially zero.
17029 33F8
17030 33F8              ;; SKIP-NEXT
17031 33F8 C8           L33F8:  RET     Z               ; return if zero.          >>
17032 33F9
17033 33F9 F5                   PUSH    AF              ; save count.
17034 33FA D5                   PUSH    DE              ; and normal STKEND
17035 33FB
17036 33FB 11 00 00             LD      DE,$0000        ; dummy value for STKEND at start of ROM
17037 33FE                                              ; Note. not a fault but this has to be
17038 33FE                                              ; moved elsewhere when running in RAM.
17039 33FE                                              ; e.g. with Expandor Systems 'Soft ROM'.
17040 33FE                                              ; Better still, write to the normal place.
17041 33FE CD C8 33             CALL    L33C8           ; routine STK-CONST works through variable
17042 3401                                              ; length records.
17043 3401
17044 3401 D1                   POP     DE              ; restore real STKEND
17045 3402 F1                   POP     AF              ; restore count
17046 3403 3D                   DEC     A               ; decrease
17047 3404 18 F2                JR      L33F8           ; loop back to SKIP-NEXT
17048 3406
17049 3406              ; ------------------------------
17050 3406              ; THE 'LOCATE MEMORY' SUBROUTINE
17051 3406              ; ------------------------------
17052 3406              ;   This routine, when supplied with a base address in HL and an index in A,
17053 3406              ;   will calculate the address of the A'th entry, where each entry occupies
17054 3406              ;   five bytes.  It is used for reading the semi-tone table and addressing
17055 3406              ;   floating-point numbers in the calculator's memory area.
17056 3406              ;   It is not possible to use this routine for the table of constants as these
17057 3406              ;   six values are held in compressed format.
17058 3406
17059 3406              ;; LOC-MEM
17060 3406 4F           L3406:  LD      C,A             ; store the original number $00-$1F.
17061 3407 07                   RLCA                    ; X2 - double.
17062 3408 07                   RLCA                    ; X4 - quadruple.
17063 3409 81                   ADD     A,C             ; X5 - now add original to multiply by five.
17064 340A
17065 340A 4F                   LD      C,A             ; place the result in the low byte.
17066 340B 06 00                LD      B,$00           ; set high byte to zero.
17067 340D 09                   ADD     HL,BC           ; add to form address of start of number in HL.
17068 340E
17069 340E C9                   RET                     ; return.
17070 340F
17071 340F              ; ------------------------------
17072 340F              ; Get from memory area ($E0 etc.)
17073 340F              ; ------------------------------
17074 340F              ; Literals $E0 to $FF
17075 340F              ; A holds $00-$1F offset.
17076 340F              ; The calculator stack increases by 5 bytes.
17077 340F
17078 340F              ;; get-mem-xx
17079 340F D5           L340F:  PUSH    DE              ; save STKEND
17080 3410 2A 68 5C             LD      HL,($5C68)      ; MEM is base address of the memory cells.
17081 3413 CD 06 34             CALL    L3406           ; routine LOC-MEM so that HL = first byte
17082 3416 CD C0 33             CALL    L33C0           ; routine MOVE-FP moves 5 bytes with memory
17083 3419                                              ; check.
17084 3419                                              ; DE now points to new STKEND.
17085 3419 E1                   POP     HL              ; original STKEND is now RESULT pointer.
17086 341A C9                   RET                     ; return.
17087 341B
17088 341B              ; --------------------------
17089 341B              ; Stack a constant (A0 etc.)
17090 341B              ; --------------------------
17091 341B              ; This routine allows a one-byte instruction to stack up to 32 constants
17092 341B              ; held in short form in a table of constants. In fact only 5 constants are
17093 341B              ; required. On entry the A register holds the literal ANDed with 1F.
17094 341B              ; It isn't very efficient and it would have been better to hold the
17095 341B              ; numbers in full, five byte form and stack them in a similar manner
17096 341B              ; to that used for semi-tone table values.
17097 341B
17098 341B              ;; stk-const-xx
17099 341B 62           L341B:  LD      H,D             ; save STKEND - required for result
17100 341C 6B                   LD      L,E             ;
17101 341D D9                   EXX                     ; swap
17102 341E E5                   PUSH    HL              ; save pointer to next literal
17103 341F 21 C5 32             LD      HL,L32C5        ; Address: stk-zero - start of table of
17104 3422                                              ; constants
17105 3422 D9                   EXX                     ;
17106 3423 CD F7 33             CALL    L33F7           ; routine SKIP-CONS
17107 3426 CD C8 33             CALL    L33C8           ; routine STK-CONST
17108 3429 D9                   EXX                     ;
17109 342A E1                   POP     HL              ; restore pointer to next literal.
17110 342B D9                   EXX                     ;
17111 342C C9                   RET                     ; return.
17112 342D
17113 342D              ; --------------------------------
17114 342D              ; Store in a memory area ($C0 etc.)
17115 342D              ; --------------------------------
17116 342D              ; Offsets $C0 to $DF
17117 342D              ; Although 32 memory storage locations can be addressed, only six
17118 342D              ; $C0 to $C5 are required by the ROM and only the thirty bytes (6*5)
17119 342D              ; required for these are allocated. Spectrum programmers who wish to
17120 342D              ; use the floating point routines from assembly language may wish to
17121 342D              ; alter the system variable MEM to point to 160 bytes of RAM to have
17122 342D              ; use the full range available.
17123 342D              ; A holds the derived offset $00-$1F.
17124 342D              ; This is a unary operation, so on entry HL points to the last value and DE
17125 342D              ; points to STKEND.
17126 342D
17127 342D              ;; st-mem-xx
17128 342D E5           L342D:  PUSH    HL              ; save the result pointer.
17129 342E EB                   EX      DE,HL           ; transfer to DE.
17130 342F 2A 68 5C             LD      HL,($5C68)      ; fetch MEM the base of memory area.
17131 3432 CD 06 34             CALL    L3406           ; routine LOC-MEM sets HL to the destination.
17132 3435 EB                   EX      DE,HL           ; swap - HL is start, DE is destination.
17133 3436 CD C0 33             CALL    L33C0           ; routine MOVE-FP.
17134 3439                                              ; note. a short ld bc,5; ldir
17135 3439                                              ; the embedded memory check is not required
17136 3439                                              ; so these instructions would be faster.
17137 3439 EB                   EX      DE,HL           ; DE = STKEND
17138 343A E1                   POP     HL              ; restore original result pointer
17139 343B C9                   RET                     ; return.
17140 343C
17141 343C              ; -------------------------
17142 343C              ; THE 'EXCHANGE' SUBROUTINE
17143 343C              ; -------------------------
17144 343C              ; (offset: $01 'exchange')
17145 343C              ;   This routine swaps the last two values on the calculator stack.
17146 343C              ;   On entry, as always with binary operations,
17147 343C              ;   HL=first number, DE=second number
17148 343C              ;   On exit, HL=result, DE=stkend.
17149 343C
17150 343C              ;; exchange
17151 343C 06 05        L343C:  LD      B,$05           ; there are five bytes to be swapped
17152 343E
17153 343E              ; start of loop.
17154 343E
17155 343E              ;; SWAP-BYTE
17156 343E 1A           L343E:  LD      A,(DE)          ; each byte of second
17157 343F 4E                   LD      C,(HL)          ; each byte of first
17158 3440 EB                   EX      DE,HL           ; swap pointers
17159 3441 12                   LD      (DE),A          ; store each byte of first
17160 3442 71                   LD      (HL),C          ; store each byte of second
17161 3443 23                   INC     HL              ; advance both
17162 3444 13                   INC     DE              ; pointers.
17163 3445 10 F7                DJNZ    L343E           ; loop back to SWAP-BYTE until all 5 done.
17164 3447
17165 3447 EB                   EX      DE,HL           ; even up the exchanges so that DE addresses
17166 3448                                              ; STKEND.
17167 3448
17168 3448 C9                   RET                     ; return.
17169 3449
17170 3449              ; ------------------------------
17171 3449              ; THE 'SERIES GENERATOR' ROUTINE
17172 3449              ; ------------------------------
17173 3449              ; (offset: $86 'series-06')
17174 3449              ; (offset: $88 'series-08')
17175 3449              ; (offset: $8C 'series-0C')
17176 3449              ;   The Spectrum uses Chebyshev polynomials to generate approximations for
17177 3449              ;   SIN, ATN, LN and EXP.  These are named after the Russian mathematician
17178 3449              ;   Pafnuty Chebyshev, born in 1821, who did much pioneering work on numerical
17179 3449              ;   series.  As far as calculators are concerned, Chebyshev polynomials have an
17180 3449              ;   advantage over other series, for example the Taylor series, as they can
17181 3449              ;   reach an approximation in just six iterations for SIN, eight for EXP and
17182 3449              ;   twelve for LN and ATN.  The mechanics of the routine are interesting but
17183 3449              ;   for full treatment of how these are generated with demonstrations in
17184 3449              ;   Sinclair BASIC see "The Complete Spectrum ROM Disassembly" by Dr Ian Logan
17185 3449              ;   and Dr Frank O'Hara, published 1983 by Melbourne House.
17186 3449
17187 3449              ;; series-xx
17188 3449 47           L3449:  LD      B,A             ; parameter $00 - $1F to B counter
17189 344A CD 5E 33             CALL    L335E           ; routine GEN-ENT-1 is called.
17190 344D                                              ; A recursive call to a special entry point
17191 344D                                              ; in the calculator that puts the B register
17192 344D                                              ; in the system variable BREG. The return
17193 344D                                              ; address is the next location and where
17194 344D                                              ; the calculator will expect its first
17195 344D                                              ; instruction - now pointed to by HL'.
17196 344D                                              ; The previous pointer to the series of
17197 344D                                              ; five-byte numbers goes on the machine stack.
17198 344D
17199 344D              ; The initialization phase.
17200 344D
17201 344D 31                   DEFB    $31             ;;duplicate       x,x
17202 344E 0F                   DEFB    $0F             ;;addition        x+x
17203 344F C0                   DEFB    $C0             ;;st-mem-0        x+x
17204 3450 02                   DEFB    $02             ;;delete          .
17205 3451 A0                   DEFB    $A0             ;;stk-zero        0
17206 3452 C2                   DEFB    $C2             ;;st-mem-2        0
17207 3453
17208 3453              ; a loop is now entered to perform the algebraic calculation for each of
17209 3453              ; the numbers in the series
17210 3453
17211 3453              ;; G-LOOP
17212 3453 31           L3453:  DEFB    $31             ;;duplicate       v,v.
17213 3454 E0                   DEFB    $E0             ;;get-mem-0       v,v,x+2
17214 3455 04                   DEFB    $04             ;;multiply        v,v*x+2
17215 3456 E2                   DEFB    $E2             ;;get-mem-2       v,v*x+2,v
17216 3457 C1                   DEFB    $C1             ;;st-mem-1
17217 3458 03                   DEFB    $03             ;;subtract
17218 3459 38                   DEFB    $38             ;;end-calc
17219 345A
17220 345A              ; the previous pointer is fetched from the machine stack to H'L' where it
17221 345A              ; addresses one of the numbers of the series following the series literal.
17222 345A
17223 345A CD C6 33             CALL    L33C6           ; routine STK-DATA is called directly to
17224 345D                                              ; push a value and advance H'L'.
17225 345D CD 62 33             CALL    L3362           ; routine GEN-ENT-2 recursively re-enters
17226 3460                                              ; the calculator without disturbing
17227 3460                                              ; system variable BREG
17228 3460                                              ; H'L' value goes on the machine stack and is
17229 3460                                              ; then loaded as usual with the next address.
17230 3460
17231 3460 0F                   DEFB    $0F             ;;addition
17232 3461 01                   DEFB    $01             ;;exchange
17233 3462 C2                   DEFB    $C2             ;;st-mem-2
17234 3463 02                   DEFB    $02             ;;delete
17235 3464
17236 3464 35                   DEFB    $35             ;;dec-jr-nz
17237 3465 EE                   DEFB    $EE             ;;back to L3453, G-LOOP
17238 3466
17239 3466              ; when the counted loop is complete the final subtraction yields the result
17240 3466              ; for example SIN X.
17241 3466
17242 3466 E1                   DEFB    $E1             ;;get-mem-1
17243 3467 03                   DEFB    $03             ;;subtract
17244 3468 38                   DEFB    $38             ;;end-calc
17245 3469
17246 3469 C9                   RET                     ; return with H'L' pointing to location
17247 346A                                              ; after last number in series.
17248 346A
17249 346A              ; ---------------------------------
17250 346A              ; THE 'ABSOLUTE MAGNITUDE' FUNCTION
17251 346A              ; ---------------------------------
17252 346A              ; (offset: $2A 'abs')
17253 346A              ;   This calculator literal finds the absolute value of the last value,
17254 346A              ;   integer or floating point, on calculator stack.
17255 346A
17256 346A              ;; abs
17257 346A 06 FF        L346A:  LD      B,$FF           ; signal abs
17258 346C 18 06                JR      L3474           ; forward to NEG-TEST
17259 346E
17260 346E              ; ---------------------------
17261 346E              ; THE 'UNARY MINUS' OPERATION
17262 346E              ; ---------------------------
17263 346E              ; (offset: $1B 'negate')
17264 346E              ;   Unary so on entry HL points to last value, DE to STKEND.
17265 346E
17266 346E              ;; NEGATE
17267 346E              ;; negate
17268 346E CD E9 34     L346E:  CALL    L34E9           ; call routine TEST-ZERO and
17269 3471 D8                   RET     C               ; return if so leaving zero unchanged.
17270 3472
17271 3472 06 00                LD      B,$00           ; signal negate required before joining
17272 3474                                              ; common code.
17273 3474
17274 3474              ;; NEG-TEST
17275 3474 7E           L3474:  LD      A,(HL)          ; load first byte and
17276 3475 A7                   AND     A               ; test for zero
17277 3476 28 0B                JR      Z,L3483         ; forward to INT-CASE if a small integer
17278 3478
17279 3478              ; for floating point numbers a single bit denotes the sign.
17280 3478
17281 3478 23                   INC     HL              ; address the first byte of mantissa.
17282 3479 78                   LD      A,B             ; action flag $FF=abs, $00=neg.
17283 347A E6 80                AND     $80             ; now         $80      $00
17284 347C B6                   OR      (HL)            ; sets bit 7 for abs
17285 347D 17                   RLA                     ; sets carry for abs and if number negative
17286 347E 3F                   CCF                     ; complement carry flag
17287 347F 1F                   RRA                     ; and rotate back in altering sign
17288 3480 77                   LD      (HL),A          ; put the altered adjusted number back
17289 3481 2B                   DEC     HL              ; HL points to result
17290 3482 C9                   RET                     ; return with DE unchanged
17291 3483
17292 3483              ; ---
17293 3483
17294 3483              ; for integer numbers an entire byte denotes the sign.
17295 3483
17296 3483              ;; INT-CASE
17297 3483 D5           L3483:  PUSH    DE              ; save STKEND.
17298 3484
17299 3484 E5                   PUSH    HL              ; save pointer to the last value/result.
17300 3485
17301 3485 CD 7F 2D             CALL    L2D7F           ; routine INT-FETCH puts integer in DE
17302 3488                                              ; and the sign in C.
17303 3488
17304 3488 E1                   POP     HL              ; restore the result pointer.
17305 3489
17306 3489 78                   LD      A,B             ; $FF=abs, $00=neg
17307 348A B1                   OR      C               ; $FF for abs, no change neg
17308 348B 2F                   CPL                     ; $00 for abs, switched for neg
17309 348C 4F                   LD      C,A             ; transfer result to sign byte.
17310 348D
17311 348D CD 8E 2D             CALL    L2D8E           ; routine INT-STORE to re-write the integer.
17312 3490
17313 3490 D1                   POP     DE              ; restore STKEND.
17314 3491 C9                   RET                     ; return.
17315 3492
17316 3492              ; ---------------------
17317 3492              ; THE 'SIGNUM' FUNCTION
17318 3492              ; ---------------------
17319 3492              ; (offset: $29 'sgn')
17320 3492              ;   This routine replaces the last value on the calculator stack,
17321 3492              ;   which may be in floating point or integer form, with the integer values
17322 3492              ;   zero if zero, with one if positive and  with -minus one if negative.
17323 3492
17324 3492              ;; sgn
17325 3492 CD E9 34     L3492:  CALL    L34E9           ; call routine TEST-ZERO and
17326 3495 D8                   RET     C               ; exit if so as no change is required.
17327 3496
17328 3496 D5                   PUSH    DE              ; save pointer to STKEND.
17329 3497
17330 3497 11 01 00             LD      DE,$0001        ; the result will be 1.
17331 349A 23                   INC     HL              ; skip over the exponent.
17332 349B CB 16                RL      (HL)            ; rotate the sign bit into the carry flag.
17333 349D 2B                   DEC     HL              ; step back to point to the result.
17334 349E 9F                   SBC     A,A             ; byte will be $FF if negative, $00 if positive.
17335 349F 4F                   LD      C,A             ; store the sign byte in the C register.
17336 34A0 CD 8E 2D             CALL    L2D8E           ; routine INT-STORE to overwrite the last
17337 34A3                                              ; value with 0001 and sign.
17338 34A3
17339 34A3 D1                   POP     DE              ; restore STKEND.
17340 34A4 C9                   RET                     ; return.
17341 34A5
17342 34A5              ; -----------------
17343 34A5              ; THE 'IN' FUNCTION
17344 34A5              ; -----------------
17345 34A5              ; (offset: $2C 'in')
17346 34A5              ;   This function reads a byte from an input port.
17347 34A5
17348 34A5              ;; in
17349 34A5 CD 99 1E     L34A5:  CALL    L1E99           ; Routine FIND-INT2 puts port address in BC.
17350 34A8                                              ; All 16 bits are put on the address line.
17351 34A8
17352 34A8 ED 78                IN      A,(C)           ; Read the port.
17353 34AA
17354 34AA 18 04                JR      L34B0           ; exit to STACK-A (via IN-PK-STK to save a byte
17355 34AC                                              ; of instruction code).
17356 34AC
17357 34AC              ; -------------------
17358 34AC              ; THE 'PEEK' FUNCTION
17359 34AC              ; -------------------
17360 34AC              ; (offset: $2B 'peek')
17361 34AC              ;   This function returns the contents of a memory address.
17362 34AC              ;   The entire address space can be peeked including the ROM.
17363 34AC
17364 34AC              ;; peek
17365 34AC CD 99 1E     L34AC:  CALL    L1E99           ; routine FIND-INT2 puts address in BC.
17366 34AF 0A                   LD      A,(BC)          ; load contents into A register.
17367 34B0
17368 34B0              ;; IN-PK-STK
17369 34B0 C3 28 2D     L34B0:  JP      L2D28           ; exit via STACK-A to put the value on the
17370 34B3                                              ; calculator stack.
17371 34B3
17372 34B3              ; ------------------
17373 34B3              ; THE 'USR' FUNCTION
17374 34B3              ; ------------------
17375 34B3              ; (offset: $2d 'usr-no')
17376 34B3              ;   The USR function followed by a number 0-65535 is the method by which
17377 34B3              ;   the Spectrum invokes machine code programs. This function returns the
17378 34B3              ;   contents of the BC register pair.
17379 34B3              ;   Note. that STACK-BC re-initializes the IY register if a user-written
17380 34B3              ;   program has altered it.
17381 34B3
17382 34B3              ;; usr-no
17383 34B3 CD 99 1E     L34B3:  CALL    L1E99           ; routine FIND-INT2 to fetch the
17384 34B6                                              ; supplied address into BC.
17385 34B6
17386 34B6 21 2B 2D             LD      HL,L2D2B        ; address: STACK-BC is
17387 34B9 E5                   PUSH    HL              ; pushed onto the machine stack.
17388 34BA C5                   PUSH    BC              ; then the address of the machine code
17389 34BB                                              ; routine.
17390 34BB
17391 34BB C9                   RET                     ; make an indirect jump to the routine
17392 34BC                                              ; and, hopefully, to STACK-BC also.
17393 34BC
17394 34BC              ; -------------------------
17395 34BC              ; THE 'USR STRING' FUNCTION
17396 34BC              ; -------------------------
17397 34BC              ; (offset: $19 'usr-$')
17398 34BC              ;   The user function with a one-character string argument, calculates the
17399 34BC              ;   address of the User Defined Graphic character that is in the string.
17400 34BC              ;   As an alternative, the ASCII equivalent, upper or lower case,
17401 34BC              ;   may be supplied. This provides a user-friendly method of redefining
17402 34BC              ;   the 21 User Definable Graphics e.g.
17403 34BC              ;   POKE USR "a", BIN 10000000 will put a dot in the top left corner of the
17404 34BC              ;   character 144.
17405 34BC              ;   Note. the curious double check on the range. With 26 UDGs the first check
17406 34BC              ;   only is necessary. With anything less the second check only is required.
17407 34BC              ;   It is highly likely that the first check was written by Steven Vickers.
17408 34BC
17409 34BC              ;; usr-$
17410 34BC CD F1 2B     L34BC:  CALL    L2BF1           ; routine STK-FETCH fetches the string
17411 34BF                                              ; parameters.
17412 34BF 0B                   DEC     BC              ; decrease BC by
17413 34C0 78                   LD      A,B             ; one to test
17414 34C1 B1                   OR      C               ; the length.
17415 34C2 20 23                JR      NZ,L34E7        ; to REPORT-A if not a single character.
17416 34C4
17417 34C4 1A                   LD      A,(DE)          ; fetch the character
17418 34C5 CD 8D 2C             CALL    L2C8D           ; routine ALPHA sets carry if 'A-Z' or 'a-z'.
17419 34C8 38 09                JR      C,L34D3         ; forward to USR-RANGE if ASCII.
17420 34CA
17421 34CA D6 90                SUB     $90             ; make UDGs range 0-20d
17422 34CC 38 19                JR      C,L34E7         ; to REPORT-A if too low. e.g. usr " ".
17423 34CE
17424 34CE FE 15                CP      $15             ; Note. this test is not necessary.
17425 34D0 30 15                JR      NC,L34E7        ; to REPORT-A if higher than 20.
17426 34D2
17427 34D2 3C                   INC     A               ; make range 1-21d to match LSBs of ASCII
17428 34D3
17429 34D3              ;; USR-RANGE
17430 34D3 3D           L34D3:  DEC     A               ; make range of bits 0-4 start at zero
17431 34D4 87                   ADD     A,A             ; multiply by eight
17432 34D5 87                   ADD     A,A             ; and lose any set bits
17433 34D6 87                   ADD     A,A             ; range now 0 - 25*8
17434 34D7 FE A8                CP      $A8             ; compare to 21*8
17435 34D9 30 0C                JR      NC,L34E7        ; to REPORT-A if originally higher
17436 34DB                                              ; than 'U','u' or graphics U.
17437 34DB
17438 34DB ED 4B 7B 5C          LD      BC,($5C7B)      ; fetch the UDG system variable value.
17439 34DF 81                   ADD     A,C             ; add the offset to character
17440 34E0 4F                   LD      C,A             ; and store back in register C.
17441 34E1 30 01                JR      NC,L34E4        ; forward to USR-STACK if no overflow.
17442 34E3
17443 34E3 04                   INC     B               ; increment high byte.
17444 34E4
17445 34E4              ;; USR-STACK
17446 34E4 C3 2B 2D     L34E4:  JP      L2D2B           ; jump back and exit via STACK-BC to store
17447 34E7
17448 34E7              ; ---
17449 34E7
17450 34E7              ;; REPORT-A
17451 34E7 CF           L34E7:  RST     08H             ; ERROR-1
17452 34E8 09                   DEFB    $09             ; Error Report: Invalid argument
17453 34E9
17454 34E9              ; ------------------------------
17455 34E9              ; THE 'TEST FOR ZERO' SUBROUTINE
17456 34E9              ; ------------------------------
17457 34E9              ;   Test if top value on calculator stack is zero.  The carry flag is set if
17458 34E9              ;   the last value is zero but no registers are altered.
17459 34E9              ;   All five bytes will be zero but first four only need be tested.
17460 34E9              ;   On entry, HL points to the exponent the first byte of the value.
17461 34E9
17462 34E9              ;; TEST-ZERO
17463 34E9 E5           L34E9:  PUSH    HL              ; preserve HL which is used to address.
17464 34EA C5                   PUSH    BC              ; preserve BC which is used as a store.
17465 34EB 47                   LD      B,A             ; preserve A in B.
17466 34EC
17467 34EC 7E                   LD      A,(HL)          ; load first byte to accumulator
17468 34ED 23                   INC     HL              ; advance.
17469 34EE B6                   OR      (HL)            ; OR with second byte and clear carry.
17470 34EF 23                   INC     HL              ; advance.
17471 34F0 B6                   OR      (HL)            ; OR with third byte.
17472 34F1 23                   INC     HL              ; advance.
17473 34F2 B6                   OR      (HL)            ; OR with fourth byte.
17474 34F3
17475 34F3 78                   LD      A,B             ; restore A without affecting flags.
17476 34F4 C1                   POP     BC              ; restore the saved
17477 34F5 E1                   POP     HL              ; registers.
17478 34F6
17479 34F6 C0                   RET     NZ              ; return if not zero and with carry reset.
17480 34F7
17481 34F7 37                   SCF                     ; set the carry flag.
17482 34F8 C9                   RET                     ; return with carry set if zero.
17483 34F9
17484 34F9              ; --------------------------------
17485 34F9              ; THE 'GREATER THAN ZERO' OPERATOR
17486 34F9              ; --------------------------------
17487 34F9              ; (offset: $37 'greater-0' )
17488 34F9              ;   Test if the last value on the calculator stack is greater than zero.
17489 34F9              ;   This routine is also called directly from the end-tests of the comparison
17490 34F9              ;   routine.
17491 34F9
17492 34F9              ;; GREATER-0
17493 34F9              ;; greater-0
17494 34F9 CD E9 34     L34F9:  CALL    L34E9           ; routine TEST-ZERO
17495 34FC D8                   RET     C               ; return if was zero as this
17496 34FD                                              ; is also the Boolean 'false' value.
17497 34FD
17498 34FD 3E FF                LD      A,$FF           ; prepare XOR mask for sign bit
17499 34FF 18 06                JR      L3507           ; forward to SIGN-TO-C
17500 3501                                              ; to put sign in carry
17501 3501                                              ; (carry will become set if sign is positive)
17502 3501                                              ; and then overwrite location with 1 or 0
17503 3501                                              ; as appropriate.
17504 3501
17505 3501              ; ------------------
17506 3501              ; THE 'NOT' FUNCTION
17507 3501              ; ------------------
17508 3501              ; (offset: $30 'not')
17509 3501              ;   This overwrites the last value with 1 if it was zero else with zero
17510 3501              ;   if it was any other value.
17511 3501              ;
17512 3501              ;   e.g. NOT 0 returns 1, NOT 1 returns 0, NOT -3 returns 0.
17513 3501              ;
17514 3501              ;   The subroutine is also called directly from the end-tests of the comparison
17515 3501              ;   operator.
17516 3501
17517 3501              ;; NOT
17518 3501              ;; not
17519 3501 CD E9 34     L3501:  CALL    L34E9           ; routine TEST-ZERO sets carry if zero
17520 3504
17521 3504 18 05                JR      L350B           ; to FP-0/1 to overwrite operand with
17522 3506                                              ; 1 if carry is set else to overwrite with zero.
17523 3506
17524 3506              ; ------------------------------
17525 3506              ; THE 'LESS THAN ZERO' OPERATION
17526 3506              ; ------------------------------
17527 3506              ; (offset: $36 'less-0' )
17528 3506              ;   Destructively test if last value on calculator stack is less than zero.
17529 3506              ;   Bit 7 of second byte will be set if so.
17530 3506
17531 3506              ;; less-0
17532 3506 AF           L3506:  XOR     A               ; set XOR mask to zero
17533 3507                                              ; (carry will become set if sign is negative).
17534 3507
17535 3507              ;   transfer sign of mantissa to Carry Flag.
17536 3507
17537 3507              ;; SIGN-TO-C
17538 3507 23           L3507:  INC     HL              ; address 2nd byte.
17539 3508 AE                   XOR     (HL)            ; bit 7 of HL will be set if number is negative.
17540 3509 2B                   DEC     HL              ; address 1st byte again.
17541 350A 07                   RLCA                    ; rotate bit 7 of A to carry.
17542 350B
17543 350B              ; ----------------------------
17544 350B              ; THE 'ZERO OR ONE' SUBROUTINE
17545 350B              ; ----------------------------
17546 350B              ;   This routine places an integer value of zero or one at the addressed
17547 350B              ;   location of the calculator stack or MEM area.  The value one is written if
17548 350B              ;   carry is set on entry else zero.
17549 350B
17550 350B              ;; FP-0/1
17551 350B E5           L350B:  PUSH    HL              ; save pointer to the first byte
17552 350C 3E 00                LD      A,$00           ; load accumulator with zero - without
17553 350E                                              ; disturbing flags.
17554 350E 77                   LD      (HL),A          ; zero to first byte
17555 350F 23                   INC     HL              ; address next
17556 3510 77                   LD      (HL),A          ; zero to 2nd byte
17557 3511 23                   INC     HL              ; address low byte of integer
17558 3512 17                   RLA                     ; carry to bit 0 of A
17559 3513 77                   LD      (HL),A          ; load one or zero to low byte.
17560 3514 1F                   RRA                     ; restore zero to accumulator.
17561 3515 23                   INC     HL              ; address high byte of integer.
17562 3516 77                   LD      (HL),A          ; put a zero there.
17563 3517 23                   INC     HL              ; address fifth byte.
17564 3518 77                   LD      (HL),A          ; put a zero there.
17565 3519 E1                   POP     HL              ; restore pointer to the first byte.
17566 351A C9                   RET                     ; return.
17567 351B
17568 351B              ; -----------------
17569 351B              ; THE 'OR' OPERATOR
17570 351B              ; -----------------
17571 351B              ; (offset: $07 'or' )
17572 351B              ; The Boolean OR operator. e.g. X OR Y
17573 351B              ; The result is zero if both values are zero else a non-zero value.
17574 351B              ;
17575 351B              ; e.g.    0 OR 0  returns 0.
17576 351B              ;        -3 OR 0  returns -3.
17577 351B              ;         0 OR -3 returns 1.
17578 351B              ;        -3 OR 2  returns 1.
17579 351B              ;
17580 351B              ; A binary operation.
17581 351B              ; On entry HL points to first operand (X) and DE to second operand (Y).
17582 351B
17583 351B              ;; or
17584 351B EB           L351B:  EX      DE,HL           ; make HL point to second number
17585 351C CD E9 34             CALL    L34E9           ; routine TEST-ZERO
17586 351F EB                   EX      DE,HL           ; restore pointers
17587 3520 D8                   RET     C               ; return if result was zero - first operand,
17588 3521                                              ; now the last value, is the result.
17589 3521
17590 3521 37                   SCF                     ; set carry flag
17591 3522 18 E7                JR      L350B           ; back to FP-0/1 to overwrite the first operand
17592 3524                                              ; with the value 1.
17593 3524
17594 3524
17595 3524              ; ---------------------------------
17596 3524              ; THE 'NUMBER AND NUMBER' OPERATION
17597 3524              ; ---------------------------------
17598 3524              ; (offset: $08 'no-&-no')
17599 3524              ;   The Boolean AND operator.
17600 3524              ;
17601 3524              ;   e.g.    -3 AND 2  returns -3.
17602 3524              ;           -3 AND 0  returns 0.
17603 3524              ;            0 and -2 returns 0.
17604 3524              ;            0 and 0  returns 0.
17605 3524              ;
17606 3524              ;   Compare with OR routine above.
17607 3524
17608 3524              ;; no-&-no
17609 3524 EB           L3524:  EX      DE,HL           ; make HL address second operand.
17610 3525
17611 3525 CD E9 34             CALL    L34E9           ; routine TEST-ZERO sets carry if zero.
17612 3528
17613 3528 EB                   EX      DE,HL           ; restore pointers.
17614 3529 D0                   RET     NC              ; return if second non-zero, first is result.
17615 352A
17616 352A              ;
17617 352A
17618 352A A7                   AND     A               ; else clear carry.
17619 352B 18 DE                JR      L350B           ; back to FP-0/1 to overwrite first operand
17620 352D                                              ; with zero for return value.
17621 352D
17622 352D              ; ---------------------------------
17623 352D              ; THE 'STRING AND NUMBER' OPERATION
17624 352D              ; ---------------------------------
17625 352D              ; (offset: $10 'str-&-no')
17626 352D              ;   e.g. "You Win" AND score>99 will return the string if condition is true
17627 352D              ;   or the null string if false.
17628 352D
17629 352D              ;; str-&-no
17630 352D EB           L352D:  EX      DE,HL           ; make HL point to the number.
17631 352E CD E9 34             CALL    L34E9           ; routine TEST-ZERO.
17632 3531 EB                   EX      DE,HL           ; restore pointers.
17633 3532 D0                   RET     NC              ; return if number was not zero - the string
17634 3533                                              ; is the result.
17635 3533
17636 3533              ;   if the number was zero (false) then the null string must be returned by
17637 3533              ;   altering the length of the string on the calculator stack to zero.
17638 3533
17639 3533 D5                   PUSH    DE              ; save pointer to the now obsolete number
17640 3534                                              ; (which will become the new STKEND)
17641 3534
17642 3534 1B                   DEC     DE              ; point to the 5th byte of string descriptor.
17643 3535 AF                   XOR     A               ; clear the accumulator.
17644 3536 12                   LD      (DE),A          ; place zero in high byte of length.
17645 3537 1B                   DEC     DE              ; address low byte of length.
17646 3538 12                   LD      (DE),A          ; place zero there - now the null string.
17647 3539
17648 3539 D1                   POP     DE              ; restore pointer - new STKEND.
17649 353A C9                   RET                     ; return.
17650 353B
17651 353B              ; ---------------------------
17652 353B              ; THE 'COMPARISON' OPERATIONS
17653 353B              ; ---------------------------
17654 353B              ; (offset: $0A 'no-gr-eql')
17655 353B              ; (offset: $0B 'nos-neql')
17656 353B              ; (offset: $0C 'no-grtr')
17657 353B              ; (offset: $0D 'no-less')
17658 353B              ; (offset: $0E 'nos-eql')
17659 353B              ; (offset: $11 'str-l-eql')
17660 353B              ; (offset: $12 'str-gr-eql')
17661 353B              ; (offset: $13 'strs-neql')
17662 353B              ; (offset: $14 'str-grtr')
17663 353B              ; (offset: $15 'str-less')
17664 353B              ; (offset: $16 'strs-eql')
17665 353B
17666 353B              ;   True binary operations.
17667 353B              ;   A single entry point is used to evaluate six numeric and six string
17668 353B              ;   comparisons. On entry, the calculator literal is in the B register and
17669 353B              ;   the two numeric values, or the two string parameters, are on the
17670 353B              ;   calculator stack.
17671 353B              ;   The individual bits of the literal are manipulated to group similar
17672 353B              ;   operations although the SUB 8 instruction does nothing useful and merely
17673 353B              ;   alters the string test bit.
17674 353B              ;   Numbers are compared by subtracting one from the other, strings are
17675 353B              ;   compared by comparing every character until a mismatch, or the end of one
17676 353B              ;   or both, is reached.
17677 353B              ;
17678 353B              ;   Numeric Comparisons.
17679 353B              ;   --------------------
17680 353B              ;   The 'x>y' example is the easiest as it employs straight-thru logic.
17681 353B              ;   Number y is subtracted from x and the result tested for greater-0 yielding
17682 353B              ;   a final value 1 (true) or 0 (false).
17683 353B              ;   For 'x<y' the same logic is used but the two values are first swapped on the
17684 353B              ;   calculator stack.
17685 353B              ;   For 'x=y' NOT is applied to the subtraction result yielding true if the
17686 353B              ;   difference was zero and false with anything else.
17687 353B              ;   The first three numeric comparisons are just the opposite of the last three
17688 353B              ;   so the same processing steps are used and then a final NOT is applied.
17689 353B              ;
17690 353B              ; literal    Test   No  sub 8       ExOrNot  1st RRCA  exch sub  ?   End-Tests
17691 353B              ; =========  ====   == ======== === ======== ========  ==== ===  =  === === ===
17692 353B              ; no-l-eql   x<=y   09 00000001 dec 00000000 00000000  ---- x-y  ?  --- >0? NOT
17693 353B              ; no-gr-eql  x>=y   0A 00000010 dec 00000001 10000000c swap y-x  ?  --- >0? NOT
17694 353B              ; nos-neql   x<>y   0B 00000011 dec 00000010 00000001  ---- x-y  ?  NOT --- NOT
17695 353B              ; no-grtr    x>y    0C 00000100  -  00000100 00000010  ---- x-y  ?  --- >0? ---
17696 353B              ; no-less    x<y    0D 00000101  -  00000101 10000010c swap y-x  ?  --- >0? ---
17697 353B              ; nos-eql    x=y    0E 00000110  -  00000110 00000011  ---- x-y  ?  NOT --- ---
17698 353B              ;
17699 353B              ;                                                           comp -> C/F
17700 353B              ;                                                           ====    ===
17701 353B              ; str-l-eql  x$<=y$ 11 00001001 dec 00001000 00000100  ---- x$y$ 0  !or >0? NOT
17702 353B              ; str-gr-eql x$>=y$ 12 00001010 dec 00001001 10000100c swap y$x$ 0  !or >0? NOT
17703 353B              ; strs-neql  x$<>y$ 13 00001011 dec 00001010 00000101  ---- x$y$ 0  !or >0? NOT
17704 353B              ; str-grtr   x$>y$  14 00001100  -  00001100 00000110  ---- x$y$ 0  !or >0? ---
17705 353B              ; str-less   x$<y$  15 00001101  -  00001101 10000110c swap y$x$ 0  !or >0? ---
17706 353B              ; strs-eql   x$=y$  16 00001110  -  00001110 00000111  ---- x$y$ 0  !or >0? ---
17707 353B              ;
17708 353B              ;   String comparisons are a little different in that the eql/neql carry flag
17709 353B              ;   from the 2nd RRCA is, as before, fed into the first of the end tests but
17710 353B              ;   along the way it gets modified by the comparison process. The result on the
17711 353B              ;   stack always starts off as zero and the carry fed in determines if NOT is
17712 353B              ;   applied to it. So the only time the greater-0 test is applied is if the
17713 353B              ;   stack holds zero which is not very efficient as the test will always yield
17714 353B              ;   zero. The most likely explanation is that there were once separate end tests
17715 353B              ;   for numbers and strings.
17716 353B
17717 353B              ;; no-l-eql,etc.
17718 353B 78           L353B:  LD      A,B             ; transfer literal to accumulator.
17719 353C D6 08                SUB     $08             ; subtract eight - which is not useful.
17720 353E
17721 353E CB 57                BIT     2,A             ; isolate '>', '<', '='.
17722 3540
17723 3540 20 01                JR      NZ,L3543        ; skip to EX-OR-NOT with these.
17724 3542
17725 3542 3D                   DEC     A               ; else make $00-$02, $08-$0A to match bits 0-2.
17726 3543
17727 3543              ;; EX-OR-NOT
17728 3543 0F           L3543:  RRCA                    ; the first RRCA sets carry for a swap.
17729 3544 30 08                JR      NC,L354E        ; forward to NU-OR-STR with other 8 cases
17730 3546
17731 3546              ; for the other 4 cases the two values on the calculator stack are exchanged.
17732 3546
17733 3546 F5                   PUSH    AF              ; save A and carry.
17734 3547 E5                   PUSH    HL              ; save HL - pointer to first operand.
17735 3548                                              ; (DE points to second operand).
17736 3548
17737 3548 CD 3C 34             CALL    L343C           ; routine exchange swaps the two values.
17738 354B                                              ; (HL = second operand, DE = STKEND)
17739 354B
17740 354B D1                   POP     DE              ; DE = first operand
17741 354C EB                   EX      DE,HL           ; as we were.
17742 354D F1                   POP     AF              ; restore A and carry.
17743 354E
17744 354E              ; Note. it would be better if the 2nd RRCA preceded the string test.
17745 354E              ; It would save two duplicate bytes and if we also got rid of that sub 8
17746 354E              ; at the beginning we wouldn't have to alter which bit we test.
17747 354E
17748 354E              ;; NU-OR-STR
17749 354E CB 57        L354E:  BIT     2,A             ; test if a string comparison.
17750 3550 20 07                JR      NZ,L3559        ; forward to STRINGS if so.
17751 3552
17752 3552              ; continue with numeric comparisons.
17753 3552
17754 3552 0F                   RRCA                    ; 2nd RRCA causes eql/neql to set carry.
17755 3553 F5                   PUSH    AF              ; save A and carry
17756 3554
17757 3554 CD 0F 30             CALL    L300F           ; routine subtract leaves result on stack.
17758 3557 18 33                JR      L358C           ; forward to END-TESTS
17759 3559
17760 3559              ; ---
17761 3559
17762 3559              ;; STRINGS
17763 3559 0F           L3559:  RRCA                    ; 2nd RRCA causes eql/neql to set carry.
17764 355A F5                   PUSH    AF              ; save A and carry.
17765 355B
17766 355B CD F1 2B             CALL    L2BF1           ; routine STK-FETCH gets 2nd string params
17767 355E D5                   PUSH    DE              ; save start2 *.
17768 355F C5                   PUSH    BC              ; and the length.
17769 3560
17770 3560 CD F1 2B             CALL    L2BF1           ; routine STK-FETCH gets 1st string
17771 3563                                              ; parameters - start in DE, length in BC.
17772 3563 E1                   POP     HL              ; restore length of second to HL.
17773 3564
17774 3564              ; A loop is now entered to compare, by subtraction, each corresponding character
17775 3564              ; of the strings. For each successful match, the pointers are incremented and
17776 3564              ; the lengths decreased and the branch taken back to here. If both string
17777 3564              ; remainders become null at the same time, then an exact match exists.
17778 3564
17779 3564              ;; BYTE-COMP
17780 3564 7C           L3564:  LD      A,H             ; test if the second string
17781 3565 B5                   OR      L               ; is the null string and hold flags.
17782 3566
17783 3566 E3                   EX      (SP),HL         ; put length2 on stack, bring start2 to HL *.
17784 3567 78                   LD      A,B             ; hi byte of length1 to A
17785 3568
17786 3568 20 0B                JR      NZ,L3575        ; forward to SEC-PLUS if second not null.
17787 356A
17788 356A B1                   OR      C               ; test length of first string.
17789 356B
17790 356B              ;; SECND-LOW
17791 356B C1           L356B:  POP     BC              ; pop the second length off stack.
17792 356C 28 04                JR      Z,L3572         ; forward to BOTH-NULL if first string is also
17793 356E                                              ; of zero length.
17794 356E
17795 356E              ; the true condition - first is longer than second (SECND-LESS)
17796 356E
17797 356E F1                   POP     AF              ; restore carry (set if eql/neql)
17798 356F 3F                   CCF                     ; complement carry flag.
17799 3570                                              ; Note. equality becomes false.
17800 3570                                              ; Inequality is true. By swapping or applying
17801 3570                                              ; a terminal 'not', all comparisons have been
17802 3570                                              ; manipulated so that this is success path.
17803 3570 18 16                JR      L3588           ; forward to leave via STR-TEST
17804 3572
17805 3572              ; ---
17806 3572              ; the branch was here with a match
17807 3572
17808 3572              ;; BOTH-NULL
17809 3572 F1           L3572:  POP     AF              ; restore carry - set for eql/neql
17810 3573 18 13                JR      L3588           ; forward to STR-TEST
17811 3575
17812 3575              ; ---
17813 3575              ; the branch was here when 2nd string not null and low byte of first is yet
17814 3575              ; to be tested.
17815 3575
17816 3575
17817 3575              ;; SEC-PLUS
17818 3575 B1           L3575:  OR      C               ; test the length of first string.
17819 3576 28 0D                JR      Z,L3585         ; forward to FRST-LESS if length is zero.
17820 3578
17821 3578              ; both strings have at least one character left.
17822 3578
17823 3578 1A                   LD      A,(DE)          ; fetch character of first string.
17824 3579 96                   SUB     (HL)            ; subtract with that of 2nd string.
17825 357A 38 09                JR      C,L3585         ; forward to FRST-LESS if carry set
17826 357C
17827 357C 20 ED                JR      NZ,L356B        ; back to SECND-LOW and then STR-TEST
17828 357E                                              ; if not exact match.
17829 357E
17830 357E 0B                   DEC     BC              ; decrease length of 1st string.
17831 357F 13                   INC     DE              ; increment 1st string pointer.
17832 3580
17833 3580 23                   INC     HL              ; increment 2nd string pointer.
17834 3581 E3                   EX      (SP),HL         ; swap with length on stack
17835 3582 2B                   DEC     HL              ; decrement 2nd string length
17836 3583 18 DF                JR      L3564           ; back to BYTE-COMP
17837 3585
17838 3585              ; ---
17839 3585              ; the false condition.
17840 3585
17841 3585              ;; FRST-LESS
17842 3585 C1           L3585:  POP     BC              ; discard length
17843 3586 F1                   POP     AF              ; pop A
17844 3587 A7                   AND     A               ; clear the carry for false result.
17845 3588
17846 3588              ; ---
17847 3588              ; exact match and x$>y$ rejoin here
17848 3588
17849 3588              ;; STR-TEST
17850 3588 F5           L3588:  PUSH    AF              ; save A and carry
17851 3589
17852 3589 EF                   RST     28H             ;; FP-CALC
17853 358A A0                   DEFB    $A0             ;;stk-zero      an initial false value.
17854 358B 38                   DEFB    $38             ;;end-calc
17855 358C
17856 358C              ; both numeric and string paths converge here.
17857 358C
17858 358C              ;; END-TESTS
17859 358C F1           L358C:  POP     AF              ; pop carry  - will be set if eql/neql
17860 358D F5                   PUSH    AF              ; save it again.
17861 358E
17862 358E DC 01 35             CALL    C,L3501         ; routine NOT sets true(1) if equal(0)
17863 3591                                              ; or, for strings, applies true result.
17864 3591
17865 3591 F1                   POP     AF              ; pop carry and
17866 3592 F5                   PUSH    AF              ; save A
17867 3593
17868 3593 D4 F9 34             CALL    NC,L34F9        ; routine GREATER-0 tests numeric subtraction
17869 3596                                              ; result but also needlessly tests the string
17870 3596                                              ; value for zero - it must be.
17871 3596
17872 3596 F1                   POP     AF              ; pop A
17873 3597 0F                   RRCA                    ; the third RRCA - test for '<=', '>=' or '<>'.
17874 3598 D4 01 35             CALL    NC,L3501        ; apply a terminal NOT if so.
17875 359B C9                   RET                     ; return.
17876 359C
17877 359C              ; ------------------------------------
17878 359C              ; THE 'STRING CONCATENATION' OPERATION
17879 359C              ; ------------------------------------
17880 359C              ; (offset: $17 'strs-add')
17881 359C              ;   This literal combines two strings into one e.g. LET a$ = b$ + c$
17882 359C              ;   The two parameters of the two strings to be combined are on the stack.
17883 359C
17884 359C              ;; strs-add
17885 359C CD F1 2B     L359C:  CALL    L2BF1           ; routine STK-FETCH fetches string parameters
17886 359F                                              ; and deletes calculator stack entry.
17887 359F D5                   PUSH    DE              ; save start address.
17888 35A0 C5                   PUSH    BC              ; and length.
17889 35A1
17890 35A1 CD F1 2B             CALL    L2BF1           ; routine STK-FETCH for first string
17891 35A4 E1                   POP     HL              ; re-fetch first length
17892 35A5 E5                   PUSH    HL              ; and save again
17893 35A6 D5                   PUSH    DE              ; save start of second string
17894 35A7 C5                   PUSH    BC              ; and its length.
17895 35A8
17896 35A8 09                   ADD     HL,BC           ; add the two lengths.
17897 35A9 44                   LD      B,H             ; transfer to BC
17898 35AA 4D                   LD      C,L             ; and create
17899 35AB F7                   RST     30H             ; BC-SPACES in workspace.
17900 35AC                                              ; DE points to start of space.
17901 35AC
17902 35AC CD B2 2A             CALL    L2AB2           ; routine STK-STO-$ stores parameters
17903 35AF                                              ; of new string updating STKEND.
17904 35AF
17905 35AF C1                   POP     BC              ; length of first
17906 35B0 E1                   POP     HL              ; address of start
17907 35B1 78                   LD      A,B             ; test for
17908 35B2 B1                   OR      C               ; zero length.
17909 35B3 28 02                JR      Z,L35B7         ; to OTHER-STR if null string
17910 35B5
17911 35B5 ED B0                LDIR                    ; copy string to workspace.
17912 35B7
17913 35B7              ;; OTHER-STR
17914 35B7 C1           L35B7:  POP     BC              ; now second length
17915 35B8 E1                   POP     HL              ; and start of string
17916 35B9 78                   LD      A,B             ; test this one
17917 35BA B1                   OR      C               ; for zero length
17918 35BB 28 02                JR      Z,L35BF         ; skip forward to STK-PNTRS if so as complete.
17919 35BD
17920 35BD ED B0                LDIR                    ; else copy the bytes.
17921 35BF                                              ; and continue into next routine which
17922 35BF                                              ; sets the calculator stack pointers.
17923 35BF
17924 35BF              ; -----------------------------------
17925 35BF              ; THE 'SET STACK POINTERS' SUBROUTINE
17926 35BF              ; -----------------------------------
17927 35BF              ;   Register DE is set to STKEND and HL, the result pointer, is set to five
17928 35BF              ;   locations below this.
17929 35BF              ;   This routine is used when it is inconvenient to save these values at the
17930 35BF              ;   time the calculator stack is manipulated due to other activity on the
17931 35BF              ;   machine stack.
17932 35BF              ;   This routine is also used to terminate the VAL and READ-IN  routines for
17933 35BF              ;   the same reason and to initialize the calculator stack at the start of
17934 35BF              ;   the CALCULATE routine.
17935 35BF
17936 35BF              ;; STK-PNTRS
17937 35BF 2A 65 5C     L35BF:  LD      HL,($5C65)      ; fetch STKEND value from system variable.
17938 35C2 11 FB FF             LD      DE,$FFFB        ; the value -5
17939 35C5 E5                   PUSH    HL              ; push STKEND value.
17940 35C6
17941 35C6 19                   ADD     HL,DE           ; subtract 5 from HL.
17942 35C7
17943 35C7 D1                   POP     DE              ; pop STKEND to DE.
17944 35C8 C9                   RET                     ; return.
17945 35C9
17946 35C9              ; -------------------
17947 35C9              ; THE 'CHR$' FUNCTION
17948 35C9              ; -------------------
17949 35C9              ; (offset: $2f 'chr$')
17950 35C9              ;   This function returns a single character string that is a result of
17951 35C9              ;   converting a number in the range 0-255 to a string e.g. CHR$ 65 = "A".
17952 35C9
17953 35C9              ;; chrs
17954 35C9 CD D5 2D     L35C9:  CALL    L2DD5           ; routine FP-TO-A puts the number in A.
17955 35CC
17956 35CC 38 0E                JR      C,L35DC         ; forward to REPORT-Bd if overflow
17957 35CE 20 0C                JR      NZ,L35DC        ; forward to REPORT-Bd if negative
17958 35D0
17959 35D0 F5                   PUSH    AF              ; save the argument.
17960 35D1
17961 35D1 01 01 00             LD      BC,$0001        ; one space required.
17962 35D4 F7                   RST     30H             ; BC-SPACES makes DE point to start
17963 35D5
17964 35D5 F1                   POP     AF              ; restore the number.
17965 35D6
17966 35D6 12                   LD      (DE),A          ; and store in workspace
17967 35D7
17968 35D7 CD B2 2A             CALL    L2AB2           ; routine STK-STO-$ stacks descriptor.
17969 35DA
17970 35DA EB                   EX      DE,HL           ; make HL point to result and DE to STKEND.
17971 35DB C9                   RET                     ; return.
17972 35DC
17973 35DC              ; ---
17974 35DC
17975 35DC              ;; REPORT-Bd
17976 35DC CF           L35DC:  RST     08H             ; ERROR-1
17977 35DD 0A                   DEFB    $0A             ; Error Report: Integer out of range
17978 35DE
17979 35DE              ; ----------------------------
17980 35DE              ; THE 'VAL and VAL$' FUNCTIONS
17981 35DE              ; ----------------------------
17982 35DE              ; (offset: $1d 'val')
17983 35DE              ; (offset: $18 'val$')
17984 35DE              ;   VAL treats the characters in a string as a numeric expression.
17985 35DE              ;   e.g. VAL "2.3" = 2.3, VAL "2+4" = 6, VAL ("2" + "4") = 24.
17986 35DE              ;   VAL$ treats the characters in a string as a string expression.
17987 35DE              ;   e.g. VAL$ (z$+"(2)") = a$(2) if z$ happens to be "a$".
17988 35DE
17989 35DE              ;; val
17990 35DE              ;; val$
17991 35DE 2A 5D 5C     L35DE:  LD      HL,($5C5D)      ; fetch value of system variable CH_ADD
17992 35E1 E5                   PUSH    HL              ; and save on the machine stack.
17993 35E2 78                   LD      A,B             ; fetch the literal (either $1D or $18).
17994 35E3 C6 E3                ADD     A,$E3           ; add $E3 to form $00 (setting carry) or $FB.
17995 35E5 9F                   SBC     A,A             ; now form $FF bit 6 = numeric result
17996 35E6                                              ; or $00 bit 6 = string result.
17997 35E6 F5                   PUSH    AF              ; save this mask on the stack
17998 35E7
17999 35E7 CD F1 2B             CALL    L2BF1           ; routine STK-FETCH fetches the string operand
18000 35EA                                              ; from calculator stack.
18001 35EA
18002 35EA D5                   PUSH    DE              ; save the address of the start of the string.
18003 35EB 03                   INC     BC              ; increment the length for a carriage return.
18004 35EC
18005 35EC F7                   RST     30H             ; BC-SPACES creates the space in workspace.
18006 35ED E1                   POP     HL              ; restore start of string to HL.
18007 35EE ED 53 5D 5C          LD      ($5C5D),DE      ; load CH_ADD with start DE in workspace.
18008 35F2
18009 35F2 D5                   PUSH    DE              ; save the start in workspace
18010 35F3 ED B0                LDIR                    ; copy string from program or variables or
18011 35F5                                              ; workspace to the workspace area.
18012 35F5 EB                   EX      DE,HL           ; end of string + 1 to HL
18013 35F6 2B                   DEC     HL              ; decrement HL to point to end of new area.
18014 35F7 36 0D                LD      (HL),$0D        ; insert a carriage return at end.
18015 35F9 FD CB 01 BE          RES     7,(IY+$01)      ; update FLAGS  - signal checking syntax.
18016 35FD CD FB 24             CALL    L24FB           ; routine SCANNING evaluates string
18017 3600                                              ; expression and result.
18018 3600
18019 3600 DF                   RST     18H             ; GET-CHAR fetches next character.
18020 3601 FE 0D                CP      $0D             ; is it the expected carriage return ?
18021 3603 20 07                JR      NZ,L360C        ; forward to V-RPORT-C if not
18022 3605                                              ; 'Nonsense in BASIC'.
18023 3605
18024 3605 E1                   POP     HL              ; restore start of string in workspace.
18025 3606 F1                   POP     AF              ; restore expected result flag (bit 6).
18026 3607 FD AE 01             XOR     (IY+$01)        ; xor with FLAGS now updated by SCANNING.
18027 360A E6 40                AND     $40             ; test bit 6 - should be zero if result types
18028 360C                                              ; match.
18029 360C
18030 360C              ;; V-RPORT-C
18031 360C C2 8A 1C     L360C:  JP      NZ,L1C8A        ; jump back to REPORT-C with a result mismatch.
18032 360F
18033 360F 22 5D 5C             LD      ($5C5D),HL      ; set CH_ADD to the start of the string again.
18034 3612 FD CB 01 FE          SET     7,(IY+$01)      ; update FLAGS  - signal running program.
18035 3616 CD FB 24             CALL    L24FB           ; routine SCANNING evaluates the string
18036 3619                                              ; in full leaving result on calculator stack.
18037 3619
18038 3619 E1                   POP     HL              ; restore saved character address in program.
18039 361A 22 5D 5C             LD      ($5C5D),HL      ; and reset the system variable CH_ADD.
18040 361D
18041 361D 18 A0                JR      L35BF           ; back to exit via STK-PNTRS.
18042 361F                                              ; resetting the calculator stack pointers
18043 361F                                              ; HL and DE from STKEND as it wasn't possible
18044 361F                                              ; to preserve them during this routine.
18045 361F
18046 361F              ; -------------------
18047 361F              ; THE 'STR$' FUNCTION
18048 361F              ; -------------------
18049 361F              ; (offset: $2e 'str$')
18050 361F              ;   This function produces a string comprising the characters that would appear
18051 361F              ;   if the numeric argument were printed.
18052 361F              ;   e.g. STR$ (1/10) produces "0.1".
18053 361F
18054 361F              ;; str$
18055 361F 01 01 00     L361F:  LD      BC,$0001        ; create an initial byte in workspace
18056 3622 F7                   RST     30H             ; using BC-SPACES restart.
18057 3623
18058 3623 22 5B 5C             LD      ($5C5B),HL      ; set system variable K_CUR to new location.
18059 3626 E5                   PUSH    HL              ; and save start on machine stack also.
18060 3627
18061 3627 2A 51 5C             LD      HL,($5C51)      ; fetch value of system variable CURCHL
18062 362A E5                   PUSH    HL              ; and save that too.
18063 362B
18064 362B 3E FF                LD      A,$FF           ; select system channel 'R'.
18065 362D CD 01 16             CALL    L1601           ; routine CHAN-OPEN opens it.
18066 3630 CD E3 2D             CALL    L2DE3           ; routine PRINT-FP outputs the number to
18067 3633                                              ; workspace updating K-CUR.
18068 3633
18069 3633 E1                   POP     HL              ; restore current channel.
18070 3634 CD 15 16             CALL    L1615           ; routine CHAN-FLAG resets flags.
18071 3637
18072 3637 D1                   POP     DE              ; fetch saved start of string to DE.
18073 3638 2A 5B 5C             LD      HL,($5C5B)      ; load HL with end of string from K_CUR.
18074 363B
18075 363B A7                   AND     A               ; prepare for true subtraction.
18076 363C ED 52                SBC     HL,DE           ; subtract start from end to give length.
18077 363E 44                   LD      B,H             ; transfer the length to
18078 363F 4D                   LD      C,L             ; the BC register pair.
18079 3640
18080 3640 CD B2 2A             CALL    L2AB2           ; routine STK-STO-$ stores string parameters
18081 3643                                              ; on the calculator stack.
18082 3643
18083 3643 EB                   EX      DE,HL           ; HL = last value, DE = STKEND.
18084 3644 C9                   RET                     ; return.
18085 3645
18086 3645              ; ------------------------
18087 3645              ; THE 'READ-IN' SUBROUTINE
18088 3645              ; ------------------------
18089 3645              ; (offset: $1a 'read-in')
18090 3645              ;   This is the calculator literal used by the INKEY$ function when a '#'
18091 3645              ;   is encountered after the keyword.
18092 3645              ;   INKEY$ # does not interact correctly with the keyboard, #0 or #1, and
18093 3645              ;   its uses are for other channels.
18094 3645
18095 3645              ;; read-in
18096 3645 CD 94 1E     L3645:  CALL    L1E94           ; routine FIND-INT1 fetches stream to A
18097 3648 FE 10                CP      $10             ; compare with 16 decimal.
18098 364A D2 9F 1E             JP      NC,L1E9F        ; JUMP to REPORT-Bb if not in range 0 - 15.
18099 364D                                              ; 'Integer out of range'
18100 364D                                              ; (REPORT-Bd is within range)
18101 364D
18102 364D 2A 51 5C             LD      HL,($5C51)      ; fetch current channel CURCHL
18103 3650 E5                   PUSH    HL              ; save it
18104 3651
18105 3651 CD 01 16             CALL    L1601           ; routine CHAN-OPEN opens channel
18106 3654
18107 3654 CD E6 15             CALL    L15E6           ; routine INPUT-AD - the channel must have an
18108 3657                                              ; input stream or else error here from stream
18109 3657                                              ; stub.
18110 3657 01 00 00             LD      BC,$0000        ; initialize length of string to zero
18111 365A 30 03                JR      NC,L365F        ; forward to R-I-STORE if no key detected.
18112 365C
18113 365C 0C                   INC     C               ; increase length to one.
18114 365D
18115 365D F7                   RST     30H             ; BC-SPACES creates space for one character
18116 365E                                              ; in workspace.
18117 365E 12                   LD      (DE),A          ; the character is inserted.
18118 365F
18119 365F              ;; R-I-STORE
18120 365F CD B2 2A     L365F:  CALL    L2AB2           ; routine STK-STO-$ stacks the string
18121 3662                                              ; parameters.
18122 3662 E1                   POP     HL              ; restore current channel address
18123 3663
18124 3663 CD 15 16             CALL    L1615           ; routine CHAN-FLAG resets current channel
18125 3666                                              ; system variable and flags.
18126 3666
18127 3666 C3 BF 35             JP      L35BF           ; jump back to STK-PNTRS
18128 3669
18129 3669              ; -------------------
18130 3669              ; THE 'CODE' FUNCTION
18131 3669              ; -------------------
18132 3669              ; (offset: $1c 'code')
18133 3669              ;   Returns the ASCII code of a character or first character of a string
18134 3669              ;   e.g. CODE "Aardvark" = 65, CODE "" = 0.
18135 3669
18136 3669              ;; code
18137 3669 CD F1 2B     L3669:  CALL    L2BF1           ; routine STK-FETCH to fetch and delete the
18138 366C                                              ; string parameters.
18139 366C                                              ; DE points to the start, BC holds the length.
18140 366C
18141 366C 78                   LD      A,B             ; test length
18142 366D B1                   OR      C               ; of the string.
18143 366E 28 01                JR      Z,L3671         ; skip to STK-CODE with zero if the null string.
18144 3670
18145 3670 1A                   LD      A,(DE)          ; else fetch the first character.
18146 3671
18147 3671              ;; STK-CODE
18148 3671 C3 28 2D     L3671:  JP      L2D28           ; jump back to STACK-A (with memory check)
18149 3674
18150 3674              ; ------------------
18151 3674              ; THE 'LEN' FUNCTION
18152 3674              ; ------------------
18153 3674              ; (offset: $1e 'len')
18154 3674              ;   Returns the length of a string.
18155 3674              ;   In Sinclair BASIC strings can be more than twenty thousand characters long
18156 3674              ;   so a sixteen-bit register is required to store the length
18157 3674
18158 3674              ;; len
18159 3674 CD F1 2B     L3674:  CALL    L2BF1           ; Routine STK-FETCH to fetch and delete the
18160 3677                                              ; string parameters from the calculator stack.
18161 3677                                              ; Register BC now holds the length of string.
18162 3677
18163 3677 C3 2B 2D             JP      L2D2B           ; Jump back to STACK-BC to save result on the
18164 367A                                              ; calculator stack (with memory check).
18165 367A
18166 367A              ; -------------------------------------
18167 367A              ; THE 'DECREASE THE COUNTER' SUBROUTINE
18168 367A              ; -------------------------------------
18169 367A              ; (offset: $35 'dec-jr-nz')
18170 367A              ;   The calculator has an instruction that decrements a single-byte
18171 367A              ;   pseudo-register and makes consequential relative jumps just like
18172 367A              ;   the Z80's DJNZ instruction.
18173 367A
18174 367A              ;; dec-jr-nz
18175 367A D9           L367A:  EXX                     ; switch in set that addresses code
18176 367B
18177 367B E5                   PUSH    HL              ; save pointer to offset byte
18178 367C 21 67 5C             LD      HL,$5C67        ; address BREG in system variables
18179 367F 35                   DEC     (HL)            ; decrement it
18180 3680 E1                   POP     HL              ; restore pointer
18181 3681
18182 3681 20 04                JR      NZ,L3687        ; to JUMP-2 if not zero
18183 3683
18184 3683 23                   INC     HL              ; step past the jump length.
18185 3684 D9                   EXX                     ; switch in the main set.
18186 3685 C9                   RET                     ; return.
18187 3686
18188 3686              ; Note. as a general rule the calculator avoids using the IY register
18189 3686              ; otherwise the cumbersome 4 instructions in the middle could be replaced by
18190 3686              ; dec (iy+$2d) - three bytes instead of six.
18191 3686
18192 3686
18193 3686              ; ---------------------
18194 3686              ; THE 'JUMP' SUBROUTINE
18195 3686              ; ---------------------
18196 3686              ; (offset: $33 'jump')
18197 3686              ;   This enables the calculator to perform relative jumps just like the Z80
18198 3686              ;   chip's JR instruction.
18199 3686
18200 3686              ;; jump
18201 3686              ;; JUMP
18202 3686 D9           L3686:  EXX                     ; switch in pointer set
18203 3687
18204 3687              ;; JUMP-2
18205 3687 5E           L3687:  LD      E,(HL)          ; the jump byte 0-127 forward, 128-255 back.
18206 3688 7B                   LD      A,E             ; transfer to accumulator.
18207 3689 17                   RLA                     ; if backward jump, carry is set.
18208 368A 9F                   SBC     A,A             ; will be $FF if backward or $00 if forward.
18209 368B 57                   LD      D,A             ; transfer to high byte.
18210 368C 19                   ADD     HL,DE           ; advance calculator pointer forward or back.
18211 368D
18212 368D D9                   EXX                     ; switch back.
18213 368E C9                   RET                     ; return.
18214 368F
18215 368F              ; --------------------------
18216 368F              ; THE 'JUMP-TRUE' SUBROUTINE
18217 368F              ; --------------------------
18218 368F              ; (offset: $00 'jump-true')
18219 368F              ;   This enables the calculator to perform conditional relative jumps dependent
18220 368F              ;   on whether the last test gave a true result.
18221 368F
18222 368F              ;; jump-true
18223 368F 13           L368F:  INC     DE              ; Collect the
18224 3690 13                   INC     DE              ; third byte
18225 3691 1A                   LD      A,(DE)          ; of the test
18226 3692 1B                   DEC     DE              ; result and
18227 3693 1B                   DEC     DE              ; backtrack.
18228 3694
18229 3694 A7                   AND     A               ; Is result 0 or 1 ?
18230 3695 20 EF                JR      NZ,L3686        ; Back to JUMP if true (1).
18231 3697
18232 3697 D9                   EXX                     ; Else switch in the pointer set.
18233 3698 23                   INC     HL              ; Step past the jump length.
18234 3699 D9                   EXX                     ; Switch in the main set.
18235 369A C9                   RET                     ; Return.
18236 369B
18237 369B              ; -------------------------
18238 369B              ; THE 'END-CALC' SUBROUTINE
18239 369B              ; -------------------------
18240 369B              ; (offset: $38 'end-calc')
18241 369B              ;   The end-calc literal terminates a mini-program written in the Spectrum's
18242 369B              ;   internal language.
18243 369B
18244 369B              ;; end-calc
18245 369B F1           L369B:  POP     AF              ; Drop the calculator return address RE-ENTRY
18246 369C D9                   EXX                     ; Switch to the other set.
18247 369D
18248 369D E3                   EX      (SP),HL         ; Transfer H'L' to machine stack for the
18249 369E                                              ; return address.
18250 369E                                              ; When exiting recursion, then the previous
18251 369E                                              ; pointer is transferred to H'L'.
18252 369E
18253 369E D9                   EXX                     ; Switch back to main set.
18254 369F C9                   RET                     ; Return.
18255 36A0
18256 36A0
18257 36A0              ; ------------------------
18258 36A0              ; THE 'MODULUS' SUBROUTINE
18259 36A0              ; ------------------------
18260 36A0              ; (offset: $32 'n-mod-m')
18261 36A0              ; (n1,n2 -- r,q)
18262 36A0              ;   Similar to FORTH's 'divide mod' /MOD
18263 36A0              ;   On the Spectrum, this is only used internally by the RND function and could
18264 36A0              ;   have been implemented inline.  On the ZX81, this calculator routine was also
18265 36A0              ;   used by PRINT-FP.
18266 36A0
18267 36A0              ;; n-mod-m
18268 36A0 EF           L36A0:  RST     28H             ;; FP-CALC          17, 3.
18269 36A1 C0                   DEFB    $C0             ;;st-mem-0          17, 3.
18270 36A2 02                   DEFB    $02             ;;delete            17.
18271 36A3 31                   DEFB    $31             ;;duplicate         17, 17.
18272 36A4 E0                   DEFB    $E0             ;;get-mem-0         17, 17, 3.
18273 36A5 05                   DEFB    $05             ;;division          17, 17/3.
18274 36A6 27                   DEFB    $27             ;;int               17, 5.
18275 36A7 E0                   DEFB    $E0             ;;get-mem-0         17, 5, 3.
18276 36A8 01                   DEFB    $01             ;;exchange          17, 3, 5.
18277 36A9 C0                   DEFB    $C0             ;;st-mem-0          17, 3, 5.
18278 36AA 04                   DEFB    $04             ;;multiply          17, 15.
18279 36AB 03                   DEFB    $03             ;;subtract          2.
18280 36AC E0                   DEFB    $E0             ;;get-mem-0         2, 5.
18281 36AD 38                   DEFB    $38             ;;end-calc          2, 5.
18282 36AE
18283 36AE C9                   RET                     ; return.
18284 36AF
18285 36AF
18286 36AF              ; ------------------
18287 36AF              ; THE 'INT' FUNCTION
18288 36AF              ; ------------------
18289 36AF              ; (offset $27: 'int' )
18290 36AF              ; This function returns the integer of x, which is just the same as truncate
18291 36AF              ; for positive numbers. The truncate literal truncates negative numbers
18292 36AF              ; upwards so that -3.4 gives -3 whereas the BASIC INT function has to
18293 36AF              ; truncate negative numbers down so that INT -3.4 is -4.
18294 36AF              ; It is best to work through using, say, +-3.4 as examples.
18295 36AF
18296 36AF              ;; int
18297 36AF EF           L36AF:  RST     28H             ;; FP-CALC              x.    (= 3.4 or -3.4).
18298 36B0 31                   DEFB    $31             ;;duplicate             x, x.
18299 36B1 36                   DEFB    $36             ;;less-0                x, (1/0)
18300 36B2 00                   DEFB    $00             ;;jump-true             x, (1/0)
18301 36B3 04                   DEFB    $04             ;;to L36B7, X-NEG
18302 36B4
18303 36B4 3A                   DEFB    $3A             ;;truncate              trunc 3.4 = 3.
18304 36B5 38                   DEFB    $38             ;;end-calc              3.
18305 36B6
18306 36B6 C9                   RET                     ; return with + int x on stack.
18307 36B7
18308 36B7              ; ---
18309 36B7
18310 36B7
18311 36B7              ;; X-NEG
18312 36B7 31           L36B7:  DEFB    $31             ;;duplicate             -3.4, -3.4.
18313 36B8 3A                   DEFB    $3A             ;;truncate              -3.4, -3.
18314 36B9 C0                   DEFB    $C0             ;;st-mem-0              -3.4, -3.
18315 36BA 03                   DEFB    $03             ;;subtract              -.4
18316 36BB E0                   DEFB    $E0             ;;get-mem-0             -.4, -3.
18317 36BC 01                   DEFB    $01             ;;exchange              -3, -.4.
18318 36BD 30                   DEFB    $30             ;;not                   -3, (0).
18319 36BE 00                   DEFB    $00             ;;jump-true             -3.
18320 36BF 03                   DEFB    $03             ;;to L36C2, EXIT        -3.
18321 36C0
18322 36C0 A1                   DEFB    $A1             ;;stk-one               -3, 1.
18323 36C1 03                   DEFB    $03             ;;subtract              -4.
18324 36C2
18325 36C2              ;; EXIT
18326 36C2 38           L36C2:  DEFB    $38             ;;end-calc              -4.
18327 36C3
18328 36C3 C9                   RET                     ; return.
18329 36C4
18330 36C4
18331 36C4              ; ------------------
18332 36C4              ; THE 'EXP' FUNCTION
18333 36C4              ; ------------------
18334 36C4              ; (offset $26: 'exp')
18335 36C4              ;   The exponential function EXP x is equal to e^x, where e is the mathematical
18336 36C4              ;   name for a number approximated to 2.718281828.
18337 36C4              ;   ERROR 6 if argument is more than about 88.
18338 36C4
18339 36C4              ;; EXP
18340 36C4              ;; exp
18341 36C4 EF           L36C4:  RST     28H             ;; FP-CALC
18342 36C5 3D                   DEFB    $3D             ;;re-stack      (not required - mult will do)
18343 36C6 34                   DEFB    $34             ;;stk-data
18344 36C7 F1                   DEFB    $F1             ;;Exponent: $81, Bytes: 4
18345 36C8 38 AA 3B 29          DEFB    $38,$AA,$3B,$29 ;;
18346 36CC 04                   DEFB    $04             ;;multiply
18347 36CD 31                   DEFB    $31             ;;duplicate
18348 36CE 27                   DEFB    $27             ;;int
18349 36CF C3                   DEFB    $C3             ;;st-mem-3
18350 36D0 03                   DEFB    $03             ;;subtract
18351 36D1 31                   DEFB    $31             ;;duplicate
18352 36D2 0F                   DEFB    $0F             ;;addition
18353 36D3 A1                   DEFB    $A1             ;;stk-one
18354 36D4 03                   DEFB    $03             ;;subtract
18355 36D5 88                   DEFB    $88             ;;series-08
18356 36D6 13                   DEFB    $13             ;;Exponent: $63, Bytes: 1
18357 36D7 36                   DEFB    $36             ;;(+00,+00,+00)
18358 36D8 58                   DEFB    $58             ;;Exponent: $68, Bytes: 2
18359 36D9 65 66                DEFB    $65,$66         ;;(+00,+00)
18360 36DB 9D                   DEFB    $9D             ;;Exponent: $6D, Bytes: 3
18361 36DC 78 65 40             DEFB    $78,$65,$40     ;;(+00)
18362 36DF A2                   DEFB    $A2             ;;Exponent: $72, Bytes: 3
18363 36E0 60 32 C9             DEFB    $60,$32,$C9     ;;(+00)
18364 36E3 E7                   DEFB    $E7             ;;Exponent: $77, Bytes: 4
18365 36E4 21 F7 AF 24          DEFB    $21,$F7,$AF,$24 ;;
18366 36E8 EB                   DEFB    $EB             ;;Exponent: $7B, Bytes: 4
18367 36E9 2F B0 B0 14          DEFB    $2F,$B0,$B0,$14 ;;
18368 36ED EE                   DEFB    $EE             ;;Exponent: $7E, Bytes: 4
18369 36EE 7E BB 94 58          DEFB    $7E,$BB,$94,$58 ;;
18370 36F2 F1                   DEFB    $F1             ;;Exponent: $81, Bytes: 4
18371 36F3 3A 7E F8 CF          DEFB    $3A,$7E,$F8,$CF ;;
18372 36F7 E3                   DEFB    $E3             ;;get-mem-3
18373 36F8 38                   DEFB    $38             ;;end-calc
18374 36F9
18375 36F9 CD D5 2D             CALL    L2DD5           ; routine FP-TO-A
18376 36FC 20 07                JR      NZ,L3705        ; to N-NEGTV
18377 36FE
18378 36FE 38 03                JR      C,L3703         ; to REPORT-6b
18379 3700                                              ; 'Number too big'
18380 3700
18381 3700 86                   ADD     A,(HL)          ;
18382 3701 30 09                JR      NC,L370C        ; to RESULT-OK
18383 3703
18384 3703
18385 3703              ;; REPORT-6b
18386 3703 CF           L3703:  RST     08H             ; ERROR-1
18387 3704 05                   DEFB    $05             ; Error Report: Number too big
18388 3705
18389 3705              ; ---
18390 3705
18391 3705              ;; N-NEGTV
18392 3705 38 07        L3705:  JR      C,L370E         ; to RSLT-ZERO
18393 3707
18394 3707 96                   SUB     (HL)            ;
18395 3708 30 04                JR      NC,L370E        ; to RSLT-ZERO
18396 370A
18397 370A ED 44                NEG                     ; Negate
18398 370C
18399 370C              ;; RESULT-OK
18400 370C 77           L370C:  LD      (HL),A          ;
18401 370D C9                   RET                     ; return.
18402 370E
18403 370E              ; ---
18404 370E
18405 370E
18406 370E              ;; RSLT-ZERO
18407 370E EF           L370E:  RST     28H             ;; FP-CALC
18408 370F 02                   DEFB    $02             ;;delete
18409 3710 A0                   DEFB    $A0             ;;stk-zero
18410 3711 38                   DEFB    $38             ;;end-calc
18411 3712
18412 3712 C9                   RET                     ; return.
18413 3713
18414 3713
18415 3713              ; --------------------------------
18416 3713              ; THE 'NATURAL LOGARITHM' FUNCTION
18417 3713              ; --------------------------------
18418 3713              ; (offset $25: 'ln')
18419 3713              ;   Function to calculate the natural logarithm (to the base e ).
18420 3713              ;   Natural logarithms were devised in 1614 by well-traveled Scotsman John
18421 3713              ;   Napier who noted
18422 3713              ;   "Nothing doth more molest and hinder calculators than the multiplications,
18423 3713              ;    divisions, square and cubical extractions of great numbers".
18424 3713              ;
18425 3713              ;   Napier's logarithms enabled the above operations to be accomplished by
18426 3713              ;   simple addition and subtraction simplifying the navigational and
18427 3713              ;   astronomical calculations which beset his age.
18428 3713              ;   Napier's logarithms were quickly overtaken by logarithms to the base 10
18429 3713              ;   devised, in conjunction with Napier, by Henry Briggs a Cambridge-educated
18430 3713              ;   professor of Geometry at Oxford University. These simplified the layout
18431 3713              ;   of the tables enabling humans to easily scale calculations.
18432 3713              ;
18433 3713              ;   It is only recently with the introduction of pocket calculators and machines
18434 3713              ;   like the ZX Spectrum that natural logarithms are once more at the fore,
18435 3713              ;   although some computers retain logarithms to the base ten.
18436 3713              ;
18437 3713              ;   'Natural' logarithms are powers to the base 'e', which like 'pi' is a
18438 3713              ;   naturally occurring number in branches of mathematics.
18439 3713              ;   Like 'pi' also, 'e' is an irrational number and starts 2.718281828...
18440 3713              ;
18441 3713              ;   The tabular use of logarithms was that to multiply two numbers one looked
18442 3713              ;   up their two logarithms in the tables, added them together and then looked
18443 3713              ;   for the result in a table of antilogarithms to give the desired product.
18444 3713              ;
18445 3713              ;   The EXP function is the BASIC equivalent of a calculator's 'antiln' function
18446 3713              ;   and by picking any two numbers, 1.72 and 6.89 say,
18447 3713              ;     10 PRINT EXP ( LN 1.72 + LN 6.89 )
18448 3713              ;   will give just the same result as
18449 3713              ;     20 PRINT 1.72 * 6.89.
18450 3713              ;   Division is accomplished by subtracting the two logs.
18451 3713              ;
18452 3713              ;   Napier also mentioned "square and cubicle extractions".
18453 3713              ;   To raise a number to the power 3, find its 'ln', multiply by 3 and find the
18454 3713              ;   'antiln'.  e.g. PRINT EXP( LN 4 * 3 )  gives 64.
18455 3713              ;   Similarly to find the n'th root divide the logarithm by 'n'.
18456 3713              ;   The ZX81 ROM used PRINT EXP ( LN 9 / 2 ) to find the square root of the
18457 3713              ;   number 9. The Napieran square root function is just a special case of
18458 3713              ;   the 'to_power' function. A cube root or indeed any root/power would be just
18459 3713              ;   as simple.
18460 3713
18461 3713              ;   First test that the argument to LN is a positive, non-zero number.
18462 3713              ;   Error A if the argument is 0 or negative.
18463 3713
18464 3713              ;; ln
18465 3713 EF           L3713:  RST     28H             ;; FP-CALC
18466 3714 3D                   DEFB    $3D             ;;re-stack
18467 3715 31                   DEFB    $31             ;;duplicate
18468 3716 37                   DEFB    $37             ;;greater-0
18469 3717 00                   DEFB    $00             ;;jump-true
18470 3718 04                   DEFB    $04             ;;to L371C, VALID
18471 3719
18472 3719 38                   DEFB    $38             ;;end-calc
18473 371A
18474 371A
18475 371A              ;; REPORT-Ab
18476 371A CF           L371A:  RST     08H             ; ERROR-1
18477 371B 09                   DEFB    $09             ; Error Report: Invalid argument
18478 371C
18479 371C              ;; VALID
18480 371C A0           L371C:  DEFB    $A0             ;;stk-zero              Note. not
18481 371D 02                   DEFB    $02             ;;delete                necessary.
18482 371E 38                   DEFB    $38             ;;end-calc
18483 371F 7E                   LD      A,(HL)          ;
18484 3720
18485 3720 36 80                LD      (HL),$80        ;
18486 3722 CD 28 2D             CALL    L2D28           ; routine STACK-A
18487 3725
18488 3725 EF                   RST     28H             ;; FP-CALC
18489 3726 34                   DEFB    $34             ;;stk-data
18490 3727 38                   DEFB    $38             ;;Exponent: $88, Bytes: 1
18491 3728 00                   DEFB    $00             ;;(+00,+00,+00)
18492 3729 03                   DEFB    $03             ;;subtract
18493 372A 01                   DEFB    $01             ;;exchange
18494 372B 31                   DEFB    $31             ;;duplicate
18495 372C 34                   DEFB    $34             ;;stk-data
18496 372D F0                   DEFB    $F0             ;;Exponent: $80, Bytes: 4
18497 372E 4C CC CC CD          DEFB    $4C,$CC,$CC,$CD ;;
18498 3732 03                   DEFB    $03             ;;subtract
18499 3733 37                   DEFB    $37             ;;greater-0
18500 3734 00                   DEFB    $00             ;;jump-true
18501 3735 08                   DEFB    $08             ;;to L373D, GRE.8
18502 3736
18503 3736 01                   DEFB    $01             ;;exchange
18504 3737 A1                   DEFB    $A1             ;;stk-one
18505 3738 03                   DEFB    $03             ;;subtract
18506 3739 01                   DEFB    $01             ;;exchange
18507 373A 38                   DEFB    $38             ;;end-calc
18508 373B
18509 373B 34                   INC     (HL)            ;
18510 373C
18511 373C EF                   RST     28H             ;; FP-CALC
18512 373D
18513 373D              ;; GRE.8
18514 373D 01           L373D:  DEFB    $01             ;;exchange
18515 373E 34                   DEFB    $34             ;;stk-data
18516 373F F0                   DEFB    $F0             ;;Exponent: $80, Bytes: 4
18517 3740 31 72 17 F8          DEFB    $31,$72,$17,$F8 ;;
18518 3744 04                   DEFB    $04             ;;multiply
18519 3745 01                   DEFB    $01             ;;exchange
18520 3746 A2                   DEFB    $A2             ;;stk-half
18521 3747 03                   DEFB    $03             ;;subtract
18522 3748 A2                   DEFB    $A2             ;;stk-half
18523 3749 03                   DEFB    $03             ;;subtract
18524 374A 31                   DEFB    $31             ;;duplicate
18525 374B 34                   DEFB    $34             ;;stk-data
18526 374C 32                   DEFB    $32             ;;Exponent: $82, Bytes: 1
18527 374D 20                   DEFB    $20             ;;(+00,+00,+00)
18528 374E 04                   DEFB    $04             ;;multiply
18529 374F A2                   DEFB    $A2             ;;stk-half
18530 3750 03                   DEFB    $03             ;;subtract
18531 3751 8C                   DEFB    $8C             ;;series-0C
18532 3752 11                   DEFB    $11             ;;Exponent: $61, Bytes: 1
18533 3753 AC                   DEFB    $AC             ;;(+00,+00,+00)
18534 3754 14                   DEFB    $14             ;;Exponent: $64, Bytes: 1
18535 3755 09                   DEFB    $09             ;;(+00,+00,+00)
18536 3756 56                   DEFB    $56             ;;Exponent: $66, Bytes: 2
18537 3757 DA A5                DEFB    $DA,$A5         ;;(+00,+00)
18538 3759 59                   DEFB    $59             ;;Exponent: $69, Bytes: 2
18539 375A 30 C5                DEFB    $30,$C5         ;;(+00,+00)
18540 375C 5C                   DEFB    $5C             ;;Exponent: $6C, Bytes: 2
18541 375D 90 AA                DEFB    $90,$AA         ;;(+00,+00)
18542 375F 9E                   DEFB    $9E             ;;Exponent: $6E, Bytes: 3
18543 3760 70 6F 61             DEFB    $70,$6F,$61     ;;(+00)
18544 3763 A1                   DEFB    $A1             ;;Exponent: $71, Bytes: 3
18545 3764 CB DA 96             DEFB    $CB,$DA,$96     ;;(+00)
18546 3767 A4                   DEFB    $A4             ;;Exponent: $74, Bytes: 3
18547 3768 31 9F B4             DEFB    $31,$9F,$B4     ;;(+00)
18548 376B E7                   DEFB    $E7             ;;Exponent: $77, Bytes: 4
18549 376C A0 FE 5C FC          DEFB    $A0,$FE,$5C,$FC ;;
18550 3770 EA                   DEFB    $EA             ;;Exponent: $7A, Bytes: 4
18551 3771 1B 43 CA 36          DEFB    $1B,$43,$CA,$36 ;;
18552 3775 ED                   DEFB    $ED             ;;Exponent: $7D, Bytes: 4
18553 3776 A7 9C 7E 5E          DEFB    $A7,$9C,$7E,$5E ;;
18554 377A F0                   DEFB    $F0             ;;Exponent: $80, Bytes: 4
18555 377B 6E 23 80 93          DEFB    $6E,$23,$80,$93 ;;
18556 377F 04                   DEFB    $04             ;;multiply
18557 3780 0F                   DEFB    $0F             ;;addition
18558 3781 38                   DEFB    $38             ;;end-calc
18559 3782
18560 3782 C9                   RET                     ; return.
18561 3783
18562 3783
18563 3783              ; -----------------------------
18564 3783              ; THE 'TRIGONOMETRIC' FUNCTIONS
18565 3783              ; -----------------------------
18566 3783              ; Trigonometry is rocket science. It is also used by carpenters and pyramid
18567 3783              ; builders.
18568 3783              ; Some uses can be quite abstract but the principles can be seen in simple
18569 3783              ; right-angled triangles. Triangles have some special properties -
18570 3783              ;
18571 3783              ; 1) The sum of the three angles is always PI radians (180 degrees).
18572 3783              ;    Very helpful if you know two angles and wish to find the third.
18573 3783              ; 2) In any right-angled triangle the sum of the squares of the two shorter
18574 3783              ;    sides is equal to the square of the longest side opposite the right-angle.
18575 3783              ;    Very useful if you know the length of two sides and wish to know the
18576 3783              ;    length of the third side.
18577 3783              ; 3) Functions sine, cosine and tangent enable one to calculate the length
18578 3783              ;    of an unknown side when the length of one other side and an angle is
18579 3783              ;    known.
18580 3783              ; 4) Functions arcsin, arccosine and arctan enable one to calculate an unknown
18581 3783              ;    angle when the length of two of the sides is known.
18582 3783
18583 3783              ; --------------------------------
18584 3783              ; THE 'REDUCE ARGUMENT' SUBROUTINE
18585 3783              ; --------------------------------
18586 3783              ; (offset $39: 'get-argt')
18587 3783              ;
18588 3783              ; This routine performs two functions on the angle, in radians, that forms
18589 3783              ; the argument to the sine and cosine functions.
18590 3783              ; First it ensures that the angle 'wraps round'. That if a ship turns through
18591 3783              ; an angle of, say, 3*PI radians (540 degrees) then the net effect is to turn
18592 3783              ; through an angle of PI radians (180 degrees).
18593 3783              ; Secondly it converts the angle in radians to a fraction of a right angle,
18594 3783              ; depending within which quadrant the angle lies, with the periodicity
18595 3783              ; resembling that of the desired sine value.
18596 3783              ; The result lies in the range -1 to +1.
18597 3783              ;
18598 3783              ;                     90 deg.
18599 3783              ;
18600 3783              ;                     (pi/2)
18601 3783              ;              II       +1        I
18602 3783              ;                       |
18603 3783              ;        sin+      |\   |   /|    sin+
18604 3783              ;        cos-      | \  |  / |    cos+
18605 3783              ;        tan-      |  \ | /  |    tan+
18606 3783              ;                  |   \|/)  |
18607 3783              ; 180 deg. (pi) 0 -|----+----|-- 0  (0)   0 degrees
18608 3783              ;                  |   /|\   |
18609 3783              ;        sin-      |  / | \  |    sin-
18610 3783              ;        cos-      | /  |  \ |    cos+
18611 3783              ;        tan+      |/   |   \|    tan-
18612 3783              ;                       |
18613 3783              ;              III      -1       IV
18614 3783              ;                     (3pi/2)
18615 3783              ;
18616 3783              ;                     270 deg.
18617 3783              ;
18618 3783
18619 3783              ;; get-argt
18620 3783 EF           L3783:  RST     28H             ;; FP-CALC      X.
18621 3784 3D                   DEFB    $3D             ;;re-stack      (not rquired done by mult)
18622 3785 34                   DEFB    $34             ;;stk-data
18623 3786 EE                   DEFB    $EE             ;;Exponent: $7E,
18624 3787                                              ;;Bytes: 4
18625 3787 22 F9 83 6E          DEFB    $22,$F9,$83,$6E ;;              X, 1/(2*PI)
18626 378B 04                   DEFB    $04             ;;multiply      X/(2*PI) = fraction
18627 378C 31                   DEFB    $31             ;;duplicate
18628 378D A2                   DEFB    $A2             ;;stk-half
18629 378E 0F                   DEFB    $0F             ;;addition
18630 378F 27                   DEFB    $27             ;;int
18631 3790
18632 3790 03                   DEFB    $03             ;;subtract      now range -.5 to .5
18633 3791
18634 3791 31                   DEFB    $31             ;;duplicate
18635 3792 0F                   DEFB    $0F             ;;addition      now range -1 to 1.
18636 3793 31                   DEFB    $31             ;;duplicate
18637 3794 0F                   DEFB    $0F             ;;addition      now range -2 to +2.
18638 3795
18639 3795              ; quadrant I (0 to +1) and quadrant IV (-1 to 0) are now correct.
18640 3795              ; quadrant II ranges +1 to +2.
18641 3795              ; quadrant III ranges -2 to -1.
18642 3795
18643 3795 31                   DEFB    $31             ;;duplicate     Y, Y.
18644 3796 2A                   DEFB    $2A             ;;abs           Y, abs(Y).    range 1 to 2
18645 3797 A1                   DEFB    $A1             ;;stk-one       Y, abs(Y), 1.
18646 3798 03                   DEFB    $03             ;;subtract      Y, abs(Y)-1.  range 0 to 1
18647 3799 31                   DEFB    $31             ;;duplicate     Y, Z, Z.
18648 379A 37                   DEFB    $37             ;;greater-0     Y, Z, (1/0).
18649 379B
18650 379B C0                   DEFB    $C0             ;;st-mem-0         store as possible sign
18651 379C                                              ;;                 for cosine function.
18652 379C
18653 379C 00                   DEFB    $00             ;;jump-true
18654 379D 04                   DEFB    $04             ;;to L37A1, ZPLUS  with quadrants II and III.
18655 379E
18656 379E              ; else the angle lies in quadrant I or IV and value Y is already correct.
18657 379E
18658 379E 02                   DEFB    $02             ;;delete        Y.   delete the test value.
18659 379F 38                   DEFB    $38             ;;end-calc      Y.
18660 37A0
18661 37A0 C9                   RET                     ; return.       with Q1 and Q4           >>>
18662 37A1
18663 37A1              ; ---
18664 37A1
18665 37A1              ; the branch was here with quadrants II (0 to 1) and III (1 to 0).
18666 37A1              ; Y will hold -2 to -1 if this is quadrant III.
18667 37A1
18668 37A1              ;; ZPLUS
18669 37A1 A1           L37A1:  DEFB    $A1             ;;stk-one         Y, Z, 1.
18670 37A2 03                   DEFB    $03             ;;subtract        Y, Z-1.       Q3 = 0 to -1
18671 37A3 01                   DEFB    $01             ;;exchange        Z-1, Y.
18672 37A4 36                   DEFB    $36             ;;less-0          Z-1, (1/0).
18673 37A5 00                   DEFB    $00             ;;jump-true       Z-1.
18674 37A6 02                   DEFB    $02             ;;to L37A8, YNEG
18675 37A7                                              ;;if angle in quadrant III
18676 37A7
18677 37A7              ; else angle is within quadrant II (-1 to 0)
18678 37A7
18679 37A7 1B                   DEFB    $1B             ;;negate          range +1 to 0.
18680 37A8
18681 37A8              ;; YNEG
18682 37A8 38           L37A8:  DEFB    $38             ;;end-calc        quadrants II and III correct.
18683 37A9
18684 37A9 C9                   RET                     ; return.
18685 37AA
18686 37AA
18687 37AA              ; ---------------------
18688 37AA              ; THE 'COSINE' FUNCTION
18689 37AA              ; ---------------------
18690 37AA              ; (offset $20: 'cos')
18691 37AA              ; Cosines are calculated as the sine of the opposite angle rectifying the
18692 37AA              ; sign depending on the quadrant rules.
18693 37AA              ;
18694 37AA              ;
18695 37AA              ;           /|
18696 37AA              ;        h /y|
18697 37AA              ;         /  |o
18698 37AA              ;        /x  |
18699 37AA              ;       /----|
18700 37AA              ;         a
18701 37AA              ;
18702 37AA              ; The cosine of angle x is the adjacent side (a) divided by the hypotenuse 1.
18703 37AA              ; However if we examine angle y then a/h is the sine of that angle.
18704 37AA              ; Since angle x plus angle y equals a right-angle, we can find angle y by
18705 37AA              ; subtracting angle x from pi/2.
18706 37AA              ; However it's just as easy to reduce the argument first and subtract the
18707 37AA              ; reduced argument from the value 1 (a reduced right-angle).
18708 37AA              ; It's even easier to subtract 1 from the angle and rectify the sign.
18709 37AA              ; In fact, after reducing the argument, the absolute value of the argument
18710 37AA              ; is used and rectified using the test result stored in mem-0 by 'get-argt'
18711 37AA              ; for that purpose.
18712 37AA              ;
18713 37AA
18714 37AA              ;; cos
18715 37AA EF           L37AA:  RST     28H             ;; FP-CALC              angle in radians.
18716 37AB 39                   DEFB    $39             ;;get-argt              X     reduce -1 to +1
18717 37AC
18718 37AC 2A                   DEFB    $2A             ;;abs                   ABS X.   0 to 1
18719 37AD A1                   DEFB    $A1             ;;stk-one               ABS X, 1.
18720 37AE 03                   DEFB    $03             ;;subtract              now opposite angle
18721 37AF                                              ;;                      although sign is -ve.
18722 37AF
18723 37AF E0                   DEFB    $E0             ;;get-mem-0             fetch the sign indicator
18724 37B0 00                   DEFB    $00             ;;jump-true
18725 37B1 06                   DEFB    $06             ;;fwd to L37B7, C-ENT
18726 37B2                                              ;;forward to common code if in QII or QIII.
18727 37B2
18728 37B2 1B                   DEFB    $1B             ;;negate                else make sign +ve.
18729 37B3 33                   DEFB    $33             ;;jump
18730 37B4 03                   DEFB    $03             ;;fwd to L37B7, C-ENT
18731 37B5                                              ;; with quadrants I and IV.
18732 37B5
18733 37B5              ; -------------------
18734 37B5              ; THE 'SINE' FUNCTION
18735 37B5              ; -------------------
18736 37B5              ; (offset $1F: 'sin')
18737 37B5              ; This is a fundamental transcendental function from which others such as cos
18738 37B5              ; and tan are directly, or indirectly, derived.
18739 37B5              ; It uses the series generator to produce Chebyshev polynomials.
18740 37B5              ;
18741 37B5              ;
18742 37B5              ;           /|
18743 37B5              ;        1 / |
18744 37B5              ;         /  |x
18745 37B5              ;        /a  |
18746 37B5              ;       /----|
18747 37B5              ;         y
18748 37B5              ;
18749 37B5              ; The 'get-argt' function is designed to modify the angle and its sign
18750 37B5              ; in line with the desired sine value and afterwards it can launch straight
18751 37B5              ; into common code.
18752 37B5
18753 37B5              ;; sin
18754 37B5 EF           L37B5:  RST     28H             ;; FP-CALC      angle in radians
18755 37B6 39                   DEFB    $39             ;;get-argt      reduce - sign now correct.
18756 37B7
18757 37B7              ;; C-ENT
18758 37B7 31           L37B7:  DEFB    $31             ;;duplicate
18759 37B8 31                   DEFB    $31             ;;duplicate
18760 37B9 04                   DEFB    $04             ;;multiply
18761 37BA 31                   DEFB    $31             ;;duplicate
18762 37BB 0F                   DEFB    $0F             ;;addition
18763 37BC A1                   DEFB    $A1             ;;stk-one
18764 37BD 03                   DEFB    $03             ;;subtract
18765 37BE
18766 37BE 86                   DEFB    $86             ;;series-06
18767 37BF 14                   DEFB    $14             ;;Exponent: $64, Bytes: 1
18768 37C0 E6                   DEFB    $E6             ;;(+00,+00,+00)
18769 37C1 5C                   DEFB    $5C             ;;Exponent: $6C, Bytes: 2
18770 37C2 1F 0B                DEFB    $1F,$0B         ;;(+00,+00)
18771 37C4 A3                   DEFB    $A3             ;;Exponent: $73, Bytes: 3
18772 37C5 8F 38 EE             DEFB    $8F,$38,$EE     ;;(+00)
18773 37C8 E9                   DEFB    $E9             ;;Exponent: $79, Bytes: 4
18774 37C9 15 63 BB 23          DEFB    $15,$63,$BB,$23 ;;
18775 37CD EE                   DEFB    $EE             ;;Exponent: $7E, Bytes: 4
18776 37CE 92 0D CD ED          DEFB    $92,$0D,$CD,$ED ;;
18777 37D2 F1                   DEFB    $F1             ;;Exponent: $81, Bytes: 4
18778 37D3 23 5D 1B EA          DEFB    $23,$5D,$1B,$EA ;;
18779 37D7 04                   DEFB    $04             ;;multiply
18780 37D8 38                   DEFB    $38             ;;end-calc
18781 37D9
18782 37D9 C9                   RET                     ; return.
18783 37DA
18784 37DA              ; ----------------------
18785 37DA              ; THE 'TANGENT' FUNCTION
18786 37DA              ; ----------------------
18787 37DA              ; (offset $21: 'tan')
18788 37DA              ;
18789 37DA              ; Evaluates tangent x as    sin(x) / cos(x).
18790 37DA              ;
18791 37DA              ;
18792 37DA              ;           /|
18793 37DA              ;        h / |
18794 37DA              ;         /  |o
18795 37DA              ;        /x  |
18796 37DA              ;       /----|
18797 37DA              ;         a
18798 37DA              ;
18799 37DA              ; the tangent of angle x is the ratio of the length of the opposite side
18800 37DA              ; divided by the length of the adjacent side. As the opposite length can
18801 37DA              ; be calculates using sin(x) and the adjacent length using cos(x) then
18802 37DA              ; the tangent can be defined in terms of the previous two functions.
18803 37DA
18804 37DA              ; Error 6 if the argument, in radians, is too close to one like pi/2
18805 37DA              ; which has an infinite tangent. e.g. PRINT TAN (PI/2)  evaluates as 1/0.
18806 37DA              ; Similarly PRINT TAN (3*PI/2), TAN (5*PI/2) etc.
18807 37DA
18808 37DA              ;; tan
18809 37DA EF           L37DA:  RST     28H             ;; FP-CALC          x.
18810 37DB 31                   DEFB    $31             ;;duplicate         x, x.
18811 37DC 1F                   DEFB    $1F             ;;sin               x, sin x.
18812 37DD 01                   DEFB    $01             ;;exchange          sin x, x.
18813 37DE 20                   DEFB    $20             ;;cos               sin x, cos x.
18814 37DF 05                   DEFB    $05             ;;division          sin x/cos x (= tan x).
18815 37E0 38                   DEFB    $38             ;;end-calc          tan x.
18816 37E1
18817 37E1 C9                   RET                     ; return.
18818 37E2
18819 37E2              ; ---------------------
18820 37E2              ; THE 'ARCTAN' FUNCTION
18821 37E2              ; ---------------------
18822 37E2              ; (Offset $24: 'atn')
18823 37E2              ; the inverse tangent function with the result in radians.
18824 37E2              ; This is a fundamental transcendental function from which others such as asn
18825 37E2              ; and acs are directly, or indirectly, derived.
18826 37E2              ; It uses the series generator to produce Chebyshev polynomials.
18827 37E2
18828 37E2              ;; atn
18829 37E2 CD 97 32     L37E2:  CALL    L3297           ; routine re-stack
18830 37E5 7E                   LD      A,(HL)          ; fetch exponent byte.
18831 37E6 FE 81                CP      $81             ; compare to that for 'one'
18832 37E8 38 0E                JR      C,L37F8         ; forward, if less, to SMALL
18833 37EA
18834 37EA EF                   RST     28H             ;; FP-CALC
18835 37EB A1                   DEFB    $A1             ;;stk-one
18836 37EC 1B                   DEFB    $1B             ;;negate
18837 37ED 01                   DEFB    $01             ;;exchange
18838 37EE 05                   DEFB    $05             ;;division
18839 37EF 31                   DEFB    $31             ;;duplicate
18840 37F0 36                   DEFB    $36             ;;less-0
18841 37F1 A3                   DEFB    $A3             ;;stk-pi/2
18842 37F2 01                   DEFB    $01             ;;exchange
18843 37F3 00                   DEFB    $00             ;;jump-true
18844 37F4 06                   DEFB    $06             ;;to L37FA, CASES
18845 37F5
18846 37F5 1B                   DEFB    $1B             ;;negate
18847 37F6 33                   DEFB    $33             ;;jump
18848 37F7 03                   DEFB    $03             ;;to L37FA, CASES
18849 37F8
18850 37F8              ;; SMALL
18851 37F8 EF           L37F8:  RST     28H             ;; FP-CALC
18852 37F9 A0                   DEFB    $A0             ;;stk-zero
18853 37FA
18854 37FA              ;; CASES
18855 37FA 01           L37FA:  DEFB    $01             ;;exchange
18856 37FB 31                   DEFB    $31             ;;duplicate
18857 37FC 31                   DEFB    $31             ;;duplicate
18858 37FD 04                   DEFB    $04             ;;multiply
18859 37FE 31                   DEFB    $31             ;;duplicate
18860 37FF 0F                   DEFB    $0F             ;;addition
18861 3800 A1                   DEFB    $A1             ;;stk-one
18862 3801 03                   DEFB    $03             ;;subtract
18863 3802 8C                   DEFB    $8C             ;;series-0C
18864 3803 10                   DEFB    $10             ;;Exponent: $60, Bytes: 1
18865 3804 B2                   DEFB    $B2             ;;(+00,+00,+00)
18866 3805 13                   DEFB    $13             ;;Exponent: $63, Bytes: 1
18867 3806 0E                   DEFB    $0E             ;;(+00,+00,+00)
18868 3807 55                   DEFB    $55             ;;Exponent: $65, Bytes: 2
18869 3808 E4 8D                DEFB    $E4,$8D         ;;(+00,+00)
18870 380A 58                   DEFB    $58             ;;Exponent: $68, Bytes: 2
18871 380B 39 BC                DEFB    $39,$BC         ;;(+00,+00)
18872 380D 5B                   DEFB    $5B             ;;Exponent: $6B, Bytes: 2
18873 380E 98 FD                DEFB    $98,$FD         ;;(+00,+00)
18874 3810 9E                   DEFB    $9E             ;;Exponent: $6E, Bytes: 3
18875 3811 00 36 75             DEFB    $00,$36,$75     ;;(+00)
18876 3814 A0                   DEFB    $A0             ;;Exponent: $70, Bytes: 3
18877 3815 DB E8 B4             DEFB    $DB,$E8,$B4     ;;(+00)
18878 3818 63                   DEFB    $63             ;;Exponent: $73, Bytes: 2
18879 3819 42 C4                DEFB    $42,$C4         ;;(+00,+00)
18880 381B E6                   DEFB    $E6             ;;Exponent: $76, Bytes: 4
18881 381C B5 09 36 BE          DEFB    $B5,$09,$36,$BE ;;
18882 3820 E9                   DEFB    $E9             ;;Exponent: $79, Bytes: 4
18883 3821 36 73 1B 5D          DEFB    $36,$73,$1B,$5D ;;
18884 3825 EC                   DEFB    $EC             ;;Exponent: $7C, Bytes: 4
18885 3826 D8 DE 63 BE          DEFB    $D8,$DE,$63,$BE ;;
18886 382A F0                   DEFB    $F0             ;;Exponent: $80, Bytes: 4
18887 382B 61 A1 B3 0C          DEFB    $61,$A1,$B3,$0C ;;
18888 382F 04                   DEFB    $04             ;;multiply
18889 3830 0F                   DEFB    $0F             ;;addition
18890 3831 38                   DEFB    $38             ;;end-calc
18891 3832
18892 3832 C9                   RET                     ; return.
18893 3833
18894 3833
18895 3833              ; ---------------------
18896 3833              ; THE 'ARCSIN' FUNCTION
18897 3833              ; ---------------------
18898 3833              ; (Offset $22: 'asn')
18899 3833              ;   The inverse sine function with result in radians.
18900 3833              ;   Derived from arctan function above.
18901 3833              ;   Error A unless the argument is between -1 and +1 inclusive.
18902 3833              ;   Uses an adaptation of the formula asn(x) = atn(x/sqr(1-x*x))
18903 3833              ;
18904 3833              ;
18905 3833              ;                 /|
18906 3833              ;                / |
18907 3833              ;              1/  |x
18908 3833              ;              /a  |
18909 3833              ;             /----|
18910 3833              ;               y
18911 3833              ;
18912 3833              ;   e.g. We know the opposite side (x) and hypotenuse (1)
18913 3833              ;   and we wish to find angle a in radians.
18914 3833              ;   We can derive length y by Pythagoras and then use ATN instead.
18915 3833              ;   Since y*y + x*x = 1*1 (Pythagoras Theorem) then
18916 3833              ;   y=sqr(1-x*x)                         - no need to multiply 1 by itself.
18917 3833              ;   So, asn(a) = atn(x/y)
18918 3833              ;   or more fully,
18919 3833              ;   asn(a) = atn(x/sqr(1-x*x))
18920 3833
18921 3833              ;   Close but no cigar.
18922 3833
18923 3833              ;   While PRINT ATN (x/SQR (1-x*x)) gives the same results as PRINT ASN x,
18924 3833              ;   it leads to division by zero when x is 1 or -1.
18925 3833              ;   To overcome this, 1 is added to y giving half the required angle and the
18926 3833              ;   result is then doubled.
18927 3833              ;   That is, PRINT ATN (x/(SQR (1-x*x) +1)) *2
18928 3833              ;
18929 3833              ;   GEOMETRIC PROOF.
18930 3833              ;
18931 3833              ;
18932 3833              ;               . /|
18933 3833              ;            .  c/ |
18934 3833              ;         .     /1 |x
18935 3833              ;      . c   b /a  |
18936 3833              ;    ---------/----|
18937 3833              ;      1      y
18938 3833              ;
18939 3833              ;   By creating an isosceles triangle with two equal sides of 1, angles c and
18940 3833              ;   c are also equal. If b+c+c = 180 degrees and b+a = 180 degrees then c=a/2.
18941 3833              ;
18942 3833              ;   A value higher than 1 gives the required error as attempting to find  the
18943 3833              ;   square root of a negative number generates an error in Sinclair BASIC.
18944 3833
18945 3833              ;; asn
18946 3833 EF           L3833:  RST     28H             ;; FP-CALC      x.
18947 3834 31                   DEFB    $31             ;;duplicate     x, x.
18948 3835 31                   DEFB    $31             ;;duplicate     x, x, x.
18949 3836 04                   DEFB    $04             ;;multiply      x, x*x.
18950 3837 A1                   DEFB    $A1             ;;stk-one       x, x*x, 1.
18951 3838 03                   DEFB    $03             ;;subtract      x, x*x-1.
18952 3839 1B                   DEFB    $1B             ;;negate        x, 1-x*x.
18953 383A 28                   DEFB    $28             ;;sqr           x, sqr(1-x*x) = y
18954 383B A1                   DEFB    $A1             ;;stk-one       x, y, 1.
18955 383C 0F                   DEFB    $0F             ;;addition      x, y+1.
18956 383D 05                   DEFB    $05             ;;division      x/y+1.
18957 383E 24                   DEFB    $24             ;;atn           a/2       (half the angle)
18958 383F 31                   DEFB    $31             ;;duplicate     a/2, a/2.
18959 3840 0F                   DEFB    $0F             ;;addition      a.
18960 3841 38                   DEFB    $38             ;;end-calc      a.
18961 3842
18962 3842 C9                   RET                     ; return.
18963 3843
18964 3843
18965 3843              ; ---------------------
18966 3843              ; THE 'ARCCOS' FUNCTION
18967 3843              ; ---------------------
18968 3843              ; (Offset $23: 'acs')
18969 3843              ; the inverse cosine function with the result in radians.
18970 3843              ; Error A unless the argument is between -1 and +1.
18971 3843              ; Result in range 0 to pi.
18972 3843              ; Derived from asn above which is in turn derived from the preceding atn.
18973 3843              ; It could have been derived directly from atn using acs(x) = atn(sqr(1-x*x)/x).
18974 3843              ; However, as sine and cosine are horizontal translations of each other,
18975 3843              ; uses acs(x) = pi/2 - asn(x)
18976 3843
18977 3843              ; e.g. the arccosine of a known x value will give the required angle b in
18978 3843              ; radians.
18979 3843              ; We know, from above, how to calculate the angle a using asn(x).
18980 3843              ; Since the three angles of any triangle add up to 180 degrees, or pi radians,
18981 3843              ; and the largest angle in this case is a right-angle (pi/2 radians), then
18982 3843              ; we can calculate angle b as pi/2 (both angles) minus asn(x) (angle a).
18983 3843              ;
18984 3843              ;
18985 3843              ;           /|
18986 3843              ;        1 /b|
18987 3843              ;         /  |x
18988 3843              ;        /a  |
18989 3843              ;       /----|
18990 3843              ;         y
18991 3843              ;
18992 3843
18993 3843              ;; acs
18994 3843 EF           L3843:  RST     28H             ;; FP-CALC      x.
18995 3844 22                   DEFB    $22             ;;asn           asn(x).
18996 3845 A3                   DEFB    $A3             ;;stk-pi/2      asn(x), pi/2.
18997 3846 03                   DEFB    $03             ;;subtract      asn(x) - pi/2.
18998 3847 1B                   DEFB    $1B             ;;negate        pi/2 -asn(x)  =  acs(x).
18999 3848 38                   DEFB    $38             ;;end-calc      acs(x).
19000 3849
19001 3849 C9                   RET                     ; return.
19002 384A
19003 384A
19004 384A              ; --------------------------
19005 384A              ; THE 'SQUARE ROOT' FUNCTION
19006 384A              ; --------------------------
19007 384A              ; (Offset $28: 'sqr')
19008 384A              ; This routine is remarkable for its brevity - 7 bytes.
19009 384A              ; It wasn't written here but in the ZX81 where the programmers had to squeeze
19010 384A              ; a bulky operating system into an 8K ROM. It simply calculates
19011 384A              ; the square root by stacking the value .5 and continuing into the 'to-power'
19012 384A              ; routine. With more space available the much faster Newton-Raphson method
19013 384A              ; could have been used as on the Jupiter Ace.
19014 384A
19015 384A              ;; sqr
19016 384A EF           L384A:  RST     28H             ;; FP-CALC
19017 384B 31                   DEFB    $31             ;;duplicate
19018 384C 30                   DEFB    $30             ;;not
19019 384D 00                   DEFB    $00             ;;jump-true
19020 384E 1E                   DEFB    $1E             ;;to L386C, LAST
19021 384F
19022 384F A2                   DEFB    $A2             ;;stk-half
19023 3850 38                   DEFB    $38             ;;end-calc
19024 3851
19025 3851
19026 3851              ; ------------------------------
19027 3851              ; THE 'EXPONENTIATION' OPERATION
19028 3851              ; ------------------------------
19029 3851              ; (Offset $06: 'to-power')
19030 3851              ; This raises the first number X to the power of the second number Y.
19031 3851              ; As with the ZX80,
19032 3851              ; 0 ^ 0 = 1.
19033 3851              ; 0 ^ +n = 0.
19034 3851              ; 0 ^ -n = arithmetic overflow.
19035 3851              ;
19036 3851
19037 3851              ;; to-power
19038 3851 EF           L3851:  RST     28H             ;; FP-CALC              X, Y.
19039 3852 01                   DEFB    $01             ;;exchange              Y, X.
19040 3853 31                   DEFB    $31             ;;duplicate             Y, X, X.
19041 3854 30                   DEFB    $30             ;;not                   Y, X, (1/0).
19042 3855 00                   DEFB    $00             ;;jump-true
19043 3856 07                   DEFB    $07             ;;to L385D, XIS0   if X is zero.
19044 3857
19045 3857              ;   else X is non-zero. Function 'ln' will catch a negative value of X.
19046 3857
19047 3857 25                   DEFB    $25             ;;ln                    Y, LN X.
19048 3858 04                   DEFB    $04             ;;multiply              Y * LN X.
19049 3859 38                   DEFB    $38             ;;end-calc
19050 385A
19051 385A C3 C4 36             JP      L36C4           ; jump back to EXP routine   ->
19052 385D
19053 385D              ; ---
19054 385D
19055 385D              ;   these routines form the three simple results when the number is zero.
19056 385D              ;   begin by deleting the known zero to leave Y the power factor.
19057 385D
19058 385D              ;; XIS0
19059 385D 02           L385D:  DEFB    $02             ;;delete                Y.
19060 385E 31                   DEFB    $31             ;;duplicate             Y, Y.
19061 385F 30                   DEFB    $30             ;;not                   Y, (1/0).
19062 3860 00                   DEFB    $00             ;;jump-true
19063 3861 09                   DEFB    $09             ;;to L386A, ONE         if Y is zero.
19064 3862
19065 3862 A0                   DEFB    $A0             ;;stk-zero              Y, 0.
19066 3863 01                   DEFB    $01             ;;exchange              0, Y.
19067 3864 37                   DEFB    $37             ;;greater-0             0, (1/0).
19068 3865 00                   DEFB    $00             ;;jump-true             0.
19069 3866 06                   DEFB    $06             ;;to L386C, LAST        if Y was any positive
19070 3867                                              ;;                      number.
19071 3867
19072 3867              ;   else force division by zero thereby raising an Arithmetic overflow error.
19073 3867              ;   There are some one and two-byte alternatives but perhaps the most formal
19074 3867              ;   might have been to use end-calc; rst 08; defb 05.
19075 3867
19076 3867 A1                   DEFB    $A1             ;;stk-one               0, 1.
19077 3868 01                   DEFB    $01             ;;exchange              1, 0.
19078 3869 05                   DEFB    $05             ;;division              1/0        ouch!
19079 386A
19080 386A              ; ---
19081 386A
19082 386A              ;; ONE
19083 386A 02           L386A:  DEFB    $02             ;;delete                .
19084 386B A1                   DEFB    $A1             ;;stk-one               1.
19085 386C
19086 386C              ;; LAST
19087 386C 38           L386C:  DEFB    $38             ;;end-calc              last value is 1 or 0.
19088 386D
19089 386D C9                   RET                     ; return.
19090 386E
19091 386E              ;   "Everything should be made as simple as possible, but not simpler"
19092 386E              ;   - Albert Einstein, 1879-1955.
19093 386E
19094 386E              ; ---------------------
19095 386E              ; THE 'SPARE' LOCATIONS
19096 386E              ; ---------------------
19097 386E
19098 386E              ;; spare
19099 386E FF FF        L386E:  DEFB    $FF, $FF        ;
19100 3870
19101 3870
19102 3870 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19102 3874 FF FF FF FF
19103 3878 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19103 387C FF FF FF FF
19104 3880 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19104 3884 FF FF FF FF
19105 3888 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19105 388C FF FF FF FF
19106 3890 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19106 3894 FF FF FF FF
19107 3898 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19107 389C FF FF FF FF
19108 38A0 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19108 38A4 FF FF FF FF
19109 38A8 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19109 38AC FF FF FF FF
19110 38B0 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19110 38B4 FF FF FF FF
19111 38B8 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19111 38BC FF FF FF FF
19112 38C0 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19112 38C4 FF FF FF FF
19113 38C8 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19113 38CC FF FF FF FF
19114 38D0 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19114 38D4 FF FF FF FF
19115 38D8 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19115 38DC FF FF FF FF
19116 38E0 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19116 38E4 FF FF FF FF
19117 38E8 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19117 38EC FF FF FF FF
19118 38F0 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19118 38F4 FF FF FF FF
19119 38F8 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19119 38FC FF FF FF FF
19120 3900 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19120 3904 FF FF FF FF
19121 3908 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19121 390C FF FF FF FF
19122 3910 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19122 3914 FF FF FF FF
19123 3918 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19123 391C FF FF FF FF
19124 3920 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19124 3924 FF FF FF FF
19125 3928 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19125 392C FF FF FF FF
19126 3930 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19126 3934 FF FF FF FF
19127 3938 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19127 393C FF FF FF FF
19128 3940 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19128 3944 FF FF FF FF
19129 3948 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19129 394C FF FF FF FF
19130 3950 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19130 3954 FF FF FF FF
19131 3958 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19131 395C FF FF FF FF
19132 3960 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19132 3964 FF FF FF FF
19133 3968 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19133 396C FF FF FF FF
19134 3970 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19134 3974 FF FF FF FF
19135 3978 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19135 397C FF FF FF FF
19136 3980 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19136 3984 FF FF FF FF
19137 3988 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19137 398C FF FF FF FF
19138 3990 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19138 3994 FF FF FF FF
19139 3998 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19139 399C FF FF FF FF
19140 39A0 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19140 39A4 FF FF FF FF
19141 39A8 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19141 39AC FF FF FF FF
19142 39B0 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19142 39B4 FF FF FF FF
19143 39B8 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19143 39BC FF FF FF FF
19144 39C0 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19144 39C4 FF FF FF FF
19145 39C8 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19145 39CC FF FF FF FF
19146 39D0 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19146 39D4 FF FF FF FF
19147 39D8 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19147 39DC FF FF FF FF
19148 39E0 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19148 39E4 FF FF FF FF
19149 39E8 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19149 39EC FF FF FF FF
19150 39F0 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19150 39F4 FF FF FF FF
19151 39F8 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19151 39FC FF FF FF FF
19152 3A00 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19152 3A04 FF FF FF FF
19153 3A08 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19153 3A0C FF FF FF FF
19154 3A10 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19154 3A14 FF FF FF FF
19155 3A18 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19155 3A1C FF FF FF FF
19156 3A20 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19156 3A24 FF FF FF FF
19157 3A28 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19157 3A2C FF FF FF FF
19158 3A30 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19158 3A34 FF FF FF FF
19159 3A38 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19159 3A3C FF FF FF FF
19160 3A40 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19160 3A44 FF FF FF FF
19161 3A48 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19161 3A4C FF FF FF FF
19162 3A50 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19162 3A54 FF FF FF FF
19163 3A58 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19163 3A5C FF FF FF FF
19164 3A60 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19164 3A64 FF FF FF FF
19165 3A68 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19165 3A6C FF FF FF FF
19166 3A70 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19166 3A74 FF FF FF FF
19167 3A78 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19167 3A7C FF FF FF FF
19168 3A80 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19168 3A84 FF FF FF FF
19169 3A88 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19169 3A8C FF FF FF FF
19170 3A90 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19170 3A94 FF FF FF FF
19171 3A98 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19171 3A9C FF FF FF FF
19172 3AA0 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19172 3AA4 FF FF FF FF
19173 3AA8 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19173 3AAC FF FF FF FF
19174 3AB0 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19174 3AB4 FF FF FF FF
19175 3AB8 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19175 3ABC FF FF FF FF
19176 3AC0 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19176 3AC4 FF FF FF FF
19177 3AC8 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19177 3ACC FF FF FF FF
19178 3AD0 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19178 3AD4 FF FF FF FF
19179 3AD8 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19179 3ADC FF FF FF FF
19180 3AE0 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19180 3AE4 FF FF FF FF
19181 3AE8 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19181 3AEC FF FF FF FF
19182 3AF0 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19182 3AF4 FF FF FF FF
19183 3AF8 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19183 3AFC FF FF FF FF
19184 3B00 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19184 3B04 FF FF FF FF
19185 3B08 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19185 3B0C FF FF FF FF
19186 3B10 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19186 3B14 FF FF FF FF
19187 3B18 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19187 3B1C FF FF FF FF
19188 3B20 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19188 3B24 FF FF FF FF
19189 3B28 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19189 3B2C FF FF FF FF
19190 3B30 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19190 3B34 FF FF FF FF
19191 3B38 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19191 3B3C FF FF FF FF
19192 3B40 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19192 3B44 FF FF FF FF
19193 3B48 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19193 3B4C FF FF FF FF
19194 3B50 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19194 3B54 FF FF FF FF
19195 3B58 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19195 3B5C FF FF FF FF
19196 3B60 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19196 3B64 FF FF FF FF
19197 3B68 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19197 3B6C FF FF FF FF
19198 3B70 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19198 3B74 FF FF FF FF
19199 3B78 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19199 3B7C FF FF FF FF
19200 3B80 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19200 3B84 FF FF FF FF
19201 3B88 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19201 3B8C FF FF FF FF
19202 3B90 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19202 3B94 FF FF FF FF
19203 3B98 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19203 3B9C FF FF FF FF
19204 3BA0 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19204 3BA4 FF FF FF FF
19205 3BA8 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19205 3BAC FF FF FF FF
19206 3BB0 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19206 3BB4 FF FF FF FF
19207 3BB8 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19207 3BBC FF FF FF FF
19208 3BC0 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19208 3BC4 FF FF FF FF
19209 3BC8 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19209 3BCC FF FF FF FF
19210 3BD0 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19210 3BD4 FF FF FF FF
19211 3BD8 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19211 3BDC FF FF FF FF
19212 3BE0 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19212 3BE4 FF FF FF FF
19213 3BE8 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19213 3BEC FF FF FF FF
19214 3BF0 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19214 3BF4 FF FF FF FF
19215 3BF8 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19215 3BFC FF FF FF FF
19216 3C00 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19216 3C04 FF FF FF FF
19217 3C08 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19217 3C0C FF FF FF FF
19218 3C10 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19218 3C14 FF FF FF FF
19219 3C18 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19219 3C1C FF FF FF FF
19220 3C20 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19220 3C24 FF FF FF FF
19221 3C28 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19221 3C2C FF FF FF FF
19222 3C30 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19222 3C34 FF FF FF FF
19223 3C38 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19223 3C3C FF FF FF FF
19224 3C40 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19224 3C44 FF FF FF FF
19225 3C48 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19225 3C4C FF FF FF FF
19226 3C50 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19226 3C54 FF FF FF FF
19227 3C58 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19227 3C5C FF FF FF FF
19228 3C60 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19228 3C64 FF FF FF FF
19229 3C68 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19229 3C6C FF FF FF FF
19230 3C70 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19230 3C74 FF FF FF FF
19231 3C78 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19231 3C7C FF FF FF FF
19232 3C80 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19232 3C84 FF FF FF FF
19233 3C88 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19233 3C8C FF FF FF FF
19234 3C90 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19234 3C94 FF FF FF FF
19235 3C98 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19235 3C9C FF FF FF FF
19236 3CA0 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19236 3CA4 FF FF FF FF
19237 3CA8 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19237 3CAC FF FF FF FF
19238 3CB0 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19238 3CB4 FF FF FF FF
19239 3CB8 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19239 3CBC FF FF FF FF
19240 3CC0 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19240 3CC4 FF FF FF FF
19241 3CC8 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19241 3CCC FF FF FF FF
19242 3CD0 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19242 3CD4 FF FF FF FF
19243 3CD8 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19243 3CDC FF FF FF FF
19244 3CE0 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19244 3CE4 FF FF FF FF
19245 3CE8 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19245 3CEC FF FF FF FF
19246 3CF0 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19246 3CF4 FF FF FF FF
19247 3CF8 FF FF FF FF          DEFB    $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF;
19247 3CFC FF FF FF FF
19248 3D00
spectrum_rom.asm(19249): warning: Label has different value in pass 3: previous value 0 not equal 15616
spectrum_rom.asm(19249): error: Unrecognized instruction: $3D00
19249 3D00              ORG $3D00
19250 3D00
19251 3D00              ; -------------------------------
19252 3D00              ; THE 'ZX SPECTRUM CHARACTER SET'
19253 3D00              ; -------------------------------
19254 3D00
19255 3D00              ;; char-set
19256 3D00
19257 3D00              ; $20 - Character: ' '          CHR$(32)
19258 3D00
19259 3D00 00           L3D00:  DEFB    %00000000
19260 3D01 00                   DEFB    %00000000
19261 3D02 00                   DEFB    %00000000
19262 3D03 00                   DEFB    %00000000
19263 3D04 00                   DEFB    %00000000
19264 3D05 00                   DEFB    %00000000
19265 3D06 00                   DEFB    %00000000
19266 3D07 00                   DEFB    %00000000
19267 3D08
19268 3D08              ; $21 - Character: '!'          CHR$(33)
19269 3D08
19270 3D08 00                   DEFB    %00000000
19271 3D09 10                   DEFB    %00010000
19272 3D0A 10                   DEFB    %00010000
19273 3D0B 10                   DEFB    %00010000
19274 3D0C 10                   DEFB    %00010000
19275 3D0D 00                   DEFB    %00000000
19276 3D0E 10                   DEFB    %00010000
19277 3D0F 00                   DEFB    %00000000
19278 3D10
19279 3D10              ; $22 - Character: '"'          CHR$(34)
19280 3D10
19281 3D10 00                   DEFB    %00000000
19282 3D11 24                   DEFB    %00100100
19283 3D12 24                   DEFB    %00100100
19284 3D13 00                   DEFB    %00000000
19285 3D14 00                   DEFB    %00000000
19286 3D15 00                   DEFB    %00000000
19287 3D16 00                   DEFB    %00000000
19288 3D17 00                   DEFB    %00000000
19289 3D18
19290 3D18              ; $23 - Character: '#'          CHR$(35)
19291 3D18
19292 3D18 00                   DEFB    %00000000
19293 3D19 24                   DEFB    %00100100
19294 3D1A 7E                   DEFB    %01111110
19295 3D1B 24                   DEFB    %00100100
19296 3D1C 24                   DEFB    %00100100
19297 3D1D 7E                   DEFB    %01111110
19298 3D1E 24                   DEFB    %00100100
19299 3D1F 00                   DEFB    %00000000
19300 3D20
19301 3D20              ; $24 - Character: '$'          CHR$(36)
19302 3D20
19303 3D20 00                   DEFB    %00000000
19304 3D21 08                   DEFB    %00001000
19305 3D22 3E                   DEFB    %00111110
19306 3D23 28                   DEFB    %00101000
19307 3D24 3E                   DEFB    %00111110
19308 3D25 0A                   DEFB    %00001010
19309 3D26 3E                   DEFB    %00111110
19310 3D27 08                   DEFB    %00001000
19311 3D28
19312 3D28              ; $25 - Character: '%'          CHR$(37)
19313 3D28
19314 3D28 00                   DEFB    %00000000
19315 3D29 62                   DEFB    %01100010
19316 3D2A 64                   DEFB    %01100100
19317 3D2B 08                   DEFB    %00001000
19318 3D2C 10                   DEFB    %00010000
19319 3D2D 26                   DEFB    %00100110
19320 3D2E 46                   DEFB    %01000110
19321 3D2F 00                   DEFB    %00000000
19322 3D30
19323 3D30              ; $26 - Character: '&'          CHR$(38)
19324 3D30
19325 3D30 00                   DEFB    %00000000
19326 3D31 10                   DEFB    %00010000
19327 3D32 28                   DEFB    %00101000
19328 3D33 10                   DEFB    %00010000
19329 3D34 2A                   DEFB    %00101010
19330 3D35 44                   DEFB    %01000100
19331 3D36 3A                   DEFB    %00111010
19332 3D37 00                   DEFB    %00000000
19333 3D38
19334 3D38              ; $27 - Character: '''          CHR$(39)
19335 3D38
19336 3D38 00                   DEFB    %00000000
19337 3D39 08                   DEFB    %00001000
19338 3D3A 10                   DEFB    %00010000
19339 3D3B 00                   DEFB    %00000000
19340 3D3C 00                   DEFB    %00000000
19341 3D3D 00                   DEFB    %00000000
19342 3D3E 00                   DEFB    %00000000
19343 3D3F 00                   DEFB    %00000000
19344 3D40
19345 3D40              ; $28 - Character: '('          CHR$(40)
19346 3D40
19347 3D40 00                   DEFB    %00000000
19348 3D41 04                   DEFB    %00000100
19349 3D42 08                   DEFB    %00001000
19350 3D43 08                   DEFB    %00001000
19351 3D44 08                   DEFB    %00001000
19352 3D45 08                   DEFB    %00001000
19353 3D46 04                   DEFB    %00000100
19354 3D47 00                   DEFB    %00000000
19355 3D48
19356 3D48              ; $29 - Character: ')'          CHR$(41)
19357 3D48
19358 3D48 00                   DEFB    %00000000
19359 3D49 20                   DEFB    %00100000
19360 3D4A 10                   DEFB    %00010000
19361 3D4B 10                   DEFB    %00010000
19362 3D4C 10                   DEFB    %00010000
19363 3D4D 10                   DEFB    %00010000
19364 3D4E 20                   DEFB    %00100000
19365 3D4F 00                   DEFB    %00000000
19366 3D50
19367 3D50              ; $2A - Character: '*'          CHR$(42)
19368 3D50
19369 3D50 00                   DEFB    %00000000
19370 3D51 00                   DEFB    %00000000
19371 3D52 14                   DEFB    %00010100
19372 3D53 08                   DEFB    %00001000
19373 3D54 3E                   DEFB    %00111110
19374 3D55 08                   DEFB    %00001000
19375 3D56 14                   DEFB    %00010100
19376 3D57 00                   DEFB    %00000000
19377 3D58
19378 3D58              ; $2B - Character: '+'          CHR$(43)
19379 3D58
19380 3D58 00                   DEFB    %00000000
19381 3D59 00                   DEFB    %00000000
19382 3D5A 08                   DEFB    %00001000
19383 3D5B 08                   DEFB    %00001000
19384 3D5C 3E                   DEFB    %00111110
19385 3D5D 08                   DEFB    %00001000
19386 3D5E 08                   DEFB    %00001000
19387 3D5F 00                   DEFB    %00000000
19388 3D60
19389 3D60              ; $2C - Character: ','          CHR$(44)
19390 3D60
19391 3D60 00                   DEFB    %00000000
19392 3D61 00                   DEFB    %00000000
19393 3D62 00                   DEFB    %00000000
19394 3D63 00                   DEFB    %00000000
19395 3D64 00                   DEFB    %00000000
19396 3D65 08                   DEFB    %00001000
19397 3D66 08                   DEFB    %00001000
19398 3D67 10                   DEFB    %00010000
19399 3D68
19400 3D68              ; $2D - Character: '-'          CHR$(45)
19401 3D68
19402 3D68 00                   DEFB    %00000000
19403 3D69 00                   DEFB    %00000000
19404 3D6A 00                   DEFB    %00000000
19405 3D6B 00                   DEFB    %00000000
19406 3D6C 3E                   DEFB    %00111110
19407 3D6D 00                   DEFB    %00000000
19408 3D6E 00                   DEFB    %00000000
19409 3D6F 00                   DEFB    %00000000
19410 3D70
19411 3D70              ; $2E - Character: '.'          CHR$(46)
19412 3D70
19413 3D70 00                   DEFB    %00000000
19414 3D71 00                   DEFB    %00000000
19415 3D72 00                   DEFB    %00000000
19416 3D73 00                   DEFB    %00000000
19417 3D74 00                   DEFB    %00000000
19418 3D75 18                   DEFB    %00011000
19419 3D76 18                   DEFB    %00011000
19420 3D77 00                   DEFB    %00000000
19421 3D78
19422 3D78              ; $2F - Character: '/'          CHR$(47)
19423 3D78
19424 3D78 00                   DEFB    %00000000
19425 3D79 00                   DEFB    %00000000
19426 3D7A 02                   DEFB    %00000010
19427 3D7B 04                   DEFB    %00000100
19428 3D7C 08                   DEFB    %00001000
19429 3D7D 10                   DEFB    %00010000
19430 3D7E 20                   DEFB    %00100000
19431 3D7F 00                   DEFB    %00000000
19432 3D80
19433 3D80              ; $30 - Character: '0'          CHR$(48)
19434 3D80
19435 3D80 00                   DEFB    %00000000
19436 3D81 3C                   DEFB    %00111100
19437 3D82 46                   DEFB    %01000110
19438 3D83 4A                   DEFB    %01001010
19439 3D84 52                   DEFB    %01010010
19440 3D85 62                   DEFB    %01100010
19441 3D86 3C                   DEFB    %00111100
19442 3D87 00                   DEFB    %00000000
19443 3D88
19444 3D88              ; $31 - Character: '1'          CHR$(49)
19445 3D88
19446 3D88 00                   DEFB    %00000000
19447 3D89 18                   DEFB    %00011000
19448 3D8A 28                   DEFB    %00101000
19449 3D8B 08                   DEFB    %00001000
19450 3D8C 08                   DEFB    %00001000
19451 3D8D 08                   DEFB    %00001000
19452 3D8E 3E                   DEFB    %00111110
19453 3D8F 00                   DEFB    %00000000
19454 3D90
19455 3D90              ; $32 - Character: '2'          CHR$(50)
19456 3D90
19457 3D90 00                   DEFB    %00000000
19458 3D91 3C                   DEFB    %00111100
19459 3D92 42                   DEFB    %01000010
19460 3D93 02                   DEFB    %00000010
19461 3D94 3C                   DEFB    %00111100
19462 3D95 40                   DEFB    %01000000
19463 3D96 7E                   DEFB    %01111110
19464 3D97 00                   DEFB    %00000000
19465 3D98
19466 3D98              ; $33 - Character: '3'          CHR$(51)
19467 3D98
19468 3D98 00                   DEFB    %00000000
19469 3D99 3C                   DEFB    %00111100
19470 3D9A 42                   DEFB    %01000010
19471 3D9B 0C                   DEFB    %00001100
19472 3D9C 02                   DEFB    %00000010
19473 3D9D 42                   DEFB    %01000010
19474 3D9E 3C                   DEFB    %00111100
19475 3D9F 00                   DEFB    %00000000
19476 3DA0
19477 3DA0              ; $34 - Character: '4'          CHR$(52)
19478 3DA0
19479 3DA0 00                   DEFB    %00000000
19480 3DA1 08                   DEFB    %00001000
19481 3DA2 18                   DEFB    %00011000
19482 3DA3 28                   DEFB    %00101000
19483 3DA4 48                   DEFB    %01001000
19484 3DA5 7E                   DEFB    %01111110
19485 3DA6 08                   DEFB    %00001000
19486 3DA7 00                   DEFB    %00000000
19487 3DA8
19488 3DA8              ; $35 - Character: '5'          CHR$(53)
19489 3DA8
19490 3DA8 00                   DEFB    %00000000
19491 3DA9 7E                   DEFB    %01111110
19492 3DAA 40                   DEFB    %01000000
19493 3DAB 7C                   DEFB    %01111100
19494 3DAC 02                   DEFB    %00000010
19495 3DAD 42                   DEFB    %01000010
19496 3DAE 3C                   DEFB    %00111100
19497 3DAF 00                   DEFB    %00000000
19498 3DB0
19499 3DB0              ; $36 - Character: '6'          CHR$(54)
19500 3DB0
19501 3DB0 00                   DEFB    %00000000
19502 3DB1 3C                   DEFB    %00111100
19503 3DB2 40                   DEFB    %01000000
19504 3DB3 7C                   DEFB    %01111100
19505 3DB4 42                   DEFB    %01000010
19506 3DB5 42                   DEFB    %01000010
19507 3DB6 3C                   DEFB    %00111100
19508 3DB7 00                   DEFB    %00000000
19509 3DB8
19510 3DB8              ; $37 - Character: '7'          CHR$(55)
19511 3DB8
19512 3DB8 00                   DEFB    %00000000
19513 3DB9 7E                   DEFB    %01111110
19514 3DBA 02                   DEFB    %00000010
19515 3DBB 04                   DEFB    %00000100
19516 3DBC 08                   DEFB    %00001000
19517 3DBD 10                   DEFB    %00010000
19518 3DBE 10                   DEFB    %00010000
19519 3DBF 00                   DEFB    %00000000
19520 3DC0
19521 3DC0              ; $38 - Character: '8'          CHR$(56)
19522 3DC0
19523 3DC0 00                   DEFB    %00000000
19524 3DC1 3C                   DEFB    %00111100
19525 3DC2 42                   DEFB    %01000010
19526 3DC3 3C                   DEFB    %00111100
19527 3DC4 42                   DEFB    %01000010
19528 3DC5 42                   DEFB    %01000010
19529 3DC6 3C                   DEFB    %00111100
19530 3DC7 00                   DEFB    %00000000
19531 3DC8
19532 3DC8              ; $39 - Character: '9'          CHR$(57)
19533 3DC8
19534 3DC8 00                   DEFB    %00000000
19535 3DC9 3C                   DEFB    %00111100
19536 3DCA 42                   DEFB    %01000010
19537 3DCB 42                   DEFB    %01000010
19538 3DCC 3E                   DEFB    %00111110
19539 3DCD 02                   DEFB    %00000010
19540 3DCE 3C                   DEFB    %00111100
19541 3DCF 00                   DEFB    %00000000
19542 3DD0
19543 3DD0              ; $3A - Character: ':'          CHR$(58)
19544 3DD0
19545 3DD0 00                   DEFB    %00000000
19546 3DD1 00                   DEFB    %00000000
19547 3DD2 00                   DEFB    %00000000
19548 3DD3 10                   DEFB    %00010000
19549 3DD4 00                   DEFB    %00000000
19550 3DD5 00                   DEFB    %00000000
19551 3DD6 10                   DEFB    %00010000
19552 3DD7 00                   DEFB    %00000000
19553 3DD8
19554 3DD8              ; $3B - Character: ';'          CHR$(59)
19555 3DD8
19556 3DD8 00                   DEFB    %00000000
19557 3DD9 00                   DEFB    %00000000
19558 3DDA 10                   DEFB    %00010000
19559 3DDB 00                   DEFB    %00000000
19560 3DDC 00                   DEFB    %00000000
19561 3DDD 10                   DEFB    %00010000
19562 3DDE 10                   DEFB    %00010000
19563 3DDF 20                   DEFB    %00100000
19564 3DE0
19565 3DE0              ; $3C - Character: '<'          CHR$(60)
19566 3DE0
19567 3DE0 00                   DEFB    %00000000
19568 3DE1 00                   DEFB    %00000000
19569 3DE2 04                   DEFB    %00000100
19570 3DE3 08                   DEFB    %00001000
19571 3DE4 10                   DEFB    %00010000
19572 3DE5 08                   DEFB    %00001000
19573 3DE6 04                   DEFB    %00000100
19574 3DE7 00                   DEFB    %00000000
19575 3DE8
19576 3DE8              ; $3D - Character: '='          CHR$(61)
19577 3DE8
19578 3DE8 00                   DEFB    %00000000
19579 3DE9 00                   DEFB    %00000000
19580 3DEA 00                   DEFB    %00000000
19581 3DEB 3E                   DEFB    %00111110
19582 3DEC 00                   DEFB    %00000000
19583 3DED 3E                   DEFB    %00111110
19584 3DEE 00                   DEFB    %00000000
19585 3DEF 00                   DEFB    %00000000
19586 3DF0
19587 3DF0              ; $3E - Character: '>'          CHR$(62)
19588 3DF0
19589 3DF0 00                   DEFB    %00000000
19590 3DF1 00                   DEFB    %00000000
19591 3DF2 10                   DEFB    %00010000
19592 3DF3 08                   DEFB    %00001000
19593 3DF4 04                   DEFB    %00000100
19594 3DF5 08                   DEFB    %00001000
19595 3DF6 10                   DEFB    %00010000
19596 3DF7 00                   DEFB    %00000000
19597 3DF8
19598 3DF8              ; $3F - Character: '?'          CHR$(63)
19599 3DF8
19600 3DF8 00                   DEFB    %00000000
19601 3DF9 3C                   DEFB    %00111100
19602 3DFA 42                   DEFB    %01000010
19603 3DFB 04                   DEFB    %00000100
19604 3DFC 08                   DEFB    %00001000
19605 3DFD 00                   DEFB    %00000000
19606 3DFE 08                   DEFB    %00001000
19607 3DFF 00                   DEFB    %00000000
19608 3E00
19609 3E00              ; $40 - Character: '@'          CHR$(64)
19610 3E00
19611 3E00 00                   DEFB    %00000000
19612 3E01 3C                   DEFB    %00111100
19613 3E02 4A                   DEFB    %01001010
19614 3E03 56                   DEFB    %01010110
19615 3E04 5E                   DEFB    %01011110
19616 3E05 40                   DEFB    %01000000
19617 3E06 3C                   DEFB    %00111100
19618 3E07 00                   DEFB    %00000000
19619 3E08
19620 3E08              ; $41 - Character: 'A'          CHR$(65)
19621 3E08
19622 3E08 00                   DEFB    %00000000
19623 3E09 3C                   DEFB    %00111100
19624 3E0A 42                   DEFB    %01000010
19625 3E0B 42                   DEFB    %01000010
19626 3E0C 7E                   DEFB    %01111110
19627 3E0D 42                   DEFB    %01000010
19628 3E0E 42                   DEFB    %01000010
19629 3E0F 00                   DEFB    %00000000
19630 3E10
19631 3E10              ; $42 - Character: 'B'          CHR$(66)
19632 3E10
19633 3E10 00                   DEFB    %00000000
19634 3E11 7C                   DEFB    %01111100
19635 3E12 42                   DEFB    %01000010
19636 3E13 7C                   DEFB    %01111100
19637 3E14 42                   DEFB    %01000010
19638 3E15 42                   DEFB    %01000010
19639 3E16 7C                   DEFB    %01111100
19640 3E17 00                   DEFB    %00000000
19641 3E18
19642 3E18              ; $43 - Character: 'C'          CHR$(67)
19643 3E18
19644 3E18 00                   DEFB    %00000000
19645 3E19 3C                   DEFB    %00111100
19646 3E1A 42                   DEFB    %01000010
19647 3E1B 40                   DEFB    %01000000
19648 3E1C 40                   DEFB    %01000000
19649 3E1D 42                   DEFB    %01000010
19650 3E1E 3C                   DEFB    %00111100
19651 3E1F 00                   DEFB    %00000000
19652 3E20
19653 3E20              ; $44 - Character: 'D'          CHR$(68)
19654 3E20
19655 3E20 00                   DEFB    %00000000
19656 3E21 78                   DEFB    %01111000
19657 3E22 44                   DEFB    %01000100
19658 3E23 42                   DEFB    %01000010
19659 3E24 42                   DEFB    %01000010
19660 3E25 44                   DEFB    %01000100
19661 3E26 78                   DEFB    %01111000
19662 3E27 00                   DEFB    %00000000
19663 3E28
19664 3E28              ; $45 - Character: 'E'          CHR$(69)
19665 3E28
19666 3E28 00                   DEFB    %00000000
19667 3E29 7E                   DEFB    %01111110
19668 3E2A 40                   DEFB    %01000000
19669 3E2B 7C                   DEFB    %01111100
19670 3E2C 40                   DEFB    %01000000
19671 3E2D 40                   DEFB    %01000000
19672 3E2E 7E                   DEFB    %01111110
19673 3E2F 00                   DEFB    %00000000
19674 3E30
19675 3E30              ; $46 - Character: 'F'          CHR$(70)
19676 3E30
19677 3E30 00                   DEFB    %00000000
19678 3E31 7E                   DEFB    %01111110
19679 3E32 40                   DEFB    %01000000
19680 3E33 7C                   DEFB    %01111100
19681 3E34 40                   DEFB    %01000000
19682 3E35 40                   DEFB    %01000000
19683 3E36 40                   DEFB    %01000000
19684 3E37 00                   DEFB    %00000000
19685 3E38
19686 3E38              ; $47 - Character: 'G'          CHR$(71)
19687 3E38
19688 3E38 00                   DEFB    %00000000
19689 3E39 3C                   DEFB    %00111100
19690 3E3A 42                   DEFB    %01000010
19691 3E3B 40                   DEFB    %01000000
19692 3E3C 4E                   DEFB    %01001110
19693 3E3D 42                   DEFB    %01000010
19694 3E3E 3C                   DEFB    %00111100
19695 3E3F 00                   DEFB    %00000000
19696 3E40
19697 3E40              ; $48 - Character: 'H'          CHR$(72)
19698 3E40
19699 3E40 00                   DEFB    %00000000
19700 3E41 42                   DEFB    %01000010
19701 3E42 42                   DEFB    %01000010
19702 3E43 7E                   DEFB    %01111110
19703 3E44 42                   DEFB    %01000010
19704 3E45 42                   DEFB    %01000010
19705 3E46 42                   DEFB    %01000010
19706 3E47 00                   DEFB    %00000000
19707 3E48
19708 3E48              ; $49 - Character: 'I'          CHR$(73)
19709 3E48
19710 3E48 00                   DEFB    %00000000
19711 3E49 3E                   DEFB    %00111110
19712 3E4A 08                   DEFB    %00001000
19713 3E4B 08                   DEFB    %00001000
19714 3E4C 08                   DEFB    %00001000
19715 3E4D 08                   DEFB    %00001000
19716 3E4E 3E                   DEFB    %00111110
19717 3E4F 00                   DEFB    %00000000
19718 3E50
19719 3E50              ; $4A - Character: 'J'          CHR$(74)
19720 3E50
19721 3E50 00                   DEFB    %00000000
19722 3E51 02                   DEFB    %00000010
19723 3E52 02                   DEFB    %00000010
19724 3E53 02                   DEFB    %00000010
19725 3E54 42                   DEFB    %01000010
19726 3E55 42                   DEFB    %01000010
19727 3E56 3C                   DEFB    %00111100
19728 3E57 00                   DEFB    %00000000
19729 3E58
19730 3E58              ; $4B - Character: 'K'          CHR$(75)
19731 3E58
19732 3E58 00                   DEFB    %00000000
19733 3E59 44                   DEFB    %01000100
19734 3E5A 48                   DEFB    %01001000
19735 3E5B 70                   DEFB    %01110000
19736 3E5C 48                   DEFB    %01001000
19737 3E5D 44                   DEFB    %01000100
19738 3E5E 42                   DEFB    %01000010
19739 3E5F 00                   DEFB    %00000000
19740 3E60
19741 3E60              ; $4C - Character: 'L'          CHR$(76)
19742 3E60
19743 3E60 00                   DEFB    %00000000
19744 3E61 40                   DEFB    %01000000
19745 3E62 40                   DEFB    %01000000
19746 3E63 40                   DEFB    %01000000
19747 3E64 40                   DEFB    %01000000
19748 3E65 40                   DEFB    %01000000
19749 3E66 7E                   DEFB    %01111110
19750 3E67 00                   DEFB    %00000000
19751 3E68
19752 3E68              ; $4D - Character: 'M'          CHR$(77)
19753 3E68
19754 3E68 00                   DEFB    %00000000
19755 3E69 42                   DEFB    %01000010
19756 3E6A 66                   DEFB    %01100110
19757 3E6B 5A                   DEFB    %01011010
19758 3E6C 42                   DEFB    %01000010
19759 3E6D 42                   DEFB    %01000010
19760 3E6E 42                   DEFB    %01000010
19761 3E6F 00                   DEFB    %00000000
19762 3E70
19763 3E70              ; $4E - Character: 'N'          CHR$(78)
19764 3E70
19765 3E70 00                   DEFB    %00000000
19766 3E71 42                   DEFB    %01000010
19767 3E72 62                   DEFB    %01100010
19768 3E73 52                   DEFB    %01010010
19769 3E74 4A                   DEFB    %01001010
19770 3E75 46                   DEFB    %01000110
19771 3E76 42                   DEFB    %01000010
19772 3E77 00                   DEFB    %00000000
19773 3E78
19774 3E78              ; $4F - Character: 'O'          CHR$(79)
19775 3E78
19776 3E78 00                   DEFB    %00000000
19777 3E79 3C                   DEFB    %00111100
19778 3E7A 42                   DEFB    %01000010
19779 3E7B 42                   DEFB    %01000010
19780 3E7C 42                   DEFB    %01000010
19781 3E7D 42                   DEFB    %01000010
19782 3E7E 3C                   DEFB    %00111100
19783 3E7F 00                   DEFB    %00000000
19784 3E80
19785 3E80              ; $50 - Character: 'P'          CHR$(80)
19786 3E80
19787 3E80 00                   DEFB    %00000000
19788 3E81 7C                   DEFB    %01111100
19789 3E82 42                   DEFB    %01000010
19790 3E83 42                   DEFB    %01000010
19791 3E84 7C                   DEFB    %01111100
19792 3E85 40                   DEFB    %01000000
19793 3E86 40                   DEFB    %01000000
19794 3E87 00                   DEFB    %00000000
19795 3E88
19796 3E88              ; $51 - Character: 'Q'          CHR$(81)
19797 3E88
19798 3E88 00                   DEFB    %00000000
19799 3E89 3C                   DEFB    %00111100
19800 3E8A 42                   DEFB    %01000010
19801 3E8B 42                   DEFB    %01000010
19802 3E8C 52                   DEFB    %01010010
19803 3E8D 4A                   DEFB    %01001010
19804 3E8E 3C                   DEFB    %00111100
19805 3E8F 00                   DEFB    %00000000
19806 3E90
19807 3E90              ; $52 - Character: 'R'          CHR$(82)
19808 3E90
19809 3E90 00                   DEFB    %00000000
19810 3E91 7C                   DEFB    %01111100
19811 3E92 42                   DEFB    %01000010
19812 3E93 42                   DEFB    %01000010
19813 3E94 7C                   DEFB    %01111100
19814 3E95 44                   DEFB    %01000100
19815 3E96 42                   DEFB    %01000010
19816 3E97 00                   DEFB    %00000000
19817 3E98
19818 3E98              ; $53 - Character: 'S'          CHR$(83)
19819 3E98
19820 3E98 00                   DEFB    %00000000
19821 3E99 3C                   DEFB    %00111100
19822 3E9A 40                   DEFB    %01000000
19823 3E9B 3C                   DEFB    %00111100
19824 3E9C 02                   DEFB    %00000010
19825 3E9D 42                   DEFB    %01000010
19826 3E9E 3C                   DEFB    %00111100
19827 3E9F 00                   DEFB    %00000000
19828 3EA0
19829 3EA0              ; $54 - Character: 'T'          CHR$(84)
19830 3EA0
19831 3EA0 00                   DEFB    %00000000
19832 3EA1 FE                   DEFB    %11111110
19833 3EA2 10                   DEFB    %00010000
19834 3EA3 10                   DEFB    %00010000
19835 3EA4 10                   DEFB    %00010000
19836 3EA5 10                   DEFB    %00010000
19837 3EA6 10                   DEFB    %00010000
19838 3EA7 00                   DEFB    %00000000
19839 3EA8
19840 3EA8              ; $55 - Character: 'U'          CHR$(85)
19841 3EA8
19842 3EA8 00                   DEFB    %00000000
19843 3EA9 42                   DEFB    %01000010
19844 3EAA 42                   DEFB    %01000010
19845 3EAB 42                   DEFB    %01000010
19846 3EAC 42                   DEFB    %01000010
19847 3EAD 42                   DEFB    %01000010
19848 3EAE 3C                   DEFB    %00111100
19849 3EAF 00                   DEFB    %00000000
19850 3EB0
19851 3EB0              ; $56 - Character: 'V'          CHR$(86)
19852 3EB0
19853 3EB0 00                   DEFB    %00000000
19854 3EB1 42                   DEFB    %01000010
19855 3EB2 42                   DEFB    %01000010
19856 3EB3 42                   DEFB    %01000010
19857 3EB4 42                   DEFB    %01000010
19858 3EB5 24                   DEFB    %00100100
19859 3EB6 18                   DEFB    %00011000
19860 3EB7 00                   DEFB    %00000000
19861 3EB8
19862 3EB8              ; $57 - Character: 'W'          CHR$(87)
19863 3EB8
19864 3EB8 00                   DEFB    %00000000
19865 3EB9 42                   DEFB    %01000010
19866 3EBA 42                   DEFB    %01000010
19867 3EBB 42                   DEFB    %01000010
19868 3EBC 42                   DEFB    %01000010
19869 3EBD 5A                   DEFB    %01011010
19870 3EBE 24                   DEFB    %00100100
19871 3EBF 00                   DEFB    %00000000
19872 3EC0
19873 3EC0              ; $58 - Character: 'X'          CHR$(88)
19874 3EC0
19875 3EC0 00                   DEFB    %00000000
19876 3EC1 42                   DEFB    %01000010
19877 3EC2 24                   DEFB    %00100100
19878 3EC3 18                   DEFB    %00011000
19879 3EC4 18                   DEFB    %00011000
19880 3EC5 24                   DEFB    %00100100
19881 3EC6 42                   DEFB    %01000010
19882 3EC7 00                   DEFB    %00000000
19883 3EC8
19884 3EC8              ; $59 - Character: 'Y'          CHR$(89)
19885 3EC8
19886 3EC8 00                   DEFB    %00000000
19887 3EC9 82                   DEFB    %10000010
19888 3ECA 44                   DEFB    %01000100
19889 3ECB 28                   DEFB    %00101000
19890 3ECC 10                   DEFB    %00010000
19891 3ECD 10                   DEFB    %00010000
19892 3ECE 10                   DEFB    %00010000
19893 3ECF 00                   DEFB    %00000000
19894 3ED0
19895 3ED0              ; $5A - Character: 'Z'          CHR$(90)
19896 3ED0
19897 3ED0 00                   DEFB    %00000000
19898 3ED1 7E                   DEFB    %01111110
19899 3ED2 04                   DEFB    %00000100
19900 3ED3 08                   DEFB    %00001000
19901 3ED4 10                   DEFB    %00010000
19902 3ED5 20                   DEFB    %00100000
19903 3ED6 7E                   DEFB    %01111110
19904 3ED7 00                   DEFB    %00000000
19905 3ED8
19906 3ED8              ; $5B - Character: '['          CHR$(91)
19907 3ED8
19908 3ED8 00                   DEFB    %00000000
19909 3ED9 0E                   DEFB    %00001110
19910 3EDA 08                   DEFB    %00001000
19911 3EDB 08                   DEFB    %00001000
19912 3EDC 08                   DEFB    %00001000
19913 3EDD 08                   DEFB    %00001000
19914 3EDE 0E                   DEFB    %00001110
19915 3EDF 00                   DEFB    %00000000
19916 3EE0
19917 3EE0              ; $5C - Character: '\'          CHR$(92)
19918 3EE0
19919 3EE0 00                   DEFB    %00000000
19920 3EE1 00                   DEFB    %00000000
19921 3EE2 40                   DEFB    %01000000
19922 3EE3 20                   DEFB    %00100000
19923 3EE4 10                   DEFB    %00010000
19924 3EE5 08                   DEFB    %00001000
19925 3EE6 04                   DEFB    %00000100
19926 3EE7 00                   DEFB    %00000000
19927 3EE8
19928 3EE8              ; $5D - Character: ']'          CHR$(93)
19929 3EE8
19930 3EE8 00                   DEFB    %00000000
19931 3EE9 70                   DEFB    %01110000
19932 3EEA 10                   DEFB    %00010000
19933 3EEB 10                   DEFB    %00010000
19934 3EEC 10                   DEFB    %00010000
19935 3EED 10                   DEFB    %00010000
19936 3EEE 70                   DEFB    %01110000
19937 3EEF 00                   DEFB    %00000000
19938 3EF0
19939 3EF0              ; $5E - Character: '^'          CHR$(94)
19940 3EF0
19941 3EF0 00                   DEFB    %00000000
19942 3EF1 10                   DEFB    %00010000
19943 3EF2 38                   DEFB    %00111000
19944 3EF3 54                   DEFB    %01010100
19945 3EF4 10                   DEFB    %00010000
19946 3EF5 10                   DEFB    %00010000
19947 3EF6 10                   DEFB    %00010000
19948 3EF7 00                   DEFB    %00000000
19949 3EF8
19950 3EF8              ; $5F - Character: '_'          CHR$(95)
19951 3EF8
19952 3EF8 00                   DEFB    %00000000
19953 3EF9 00                   DEFB    %00000000
19954 3EFA 00                   DEFB    %00000000
19955 3EFB 00                   DEFB    %00000000
19956 3EFC 00                   DEFB    %00000000
19957 3EFD 00                   DEFB    %00000000
19958 3EFE 00                   DEFB    %00000000
19959 3EFF FF                   DEFB    %11111111
19960 3F00
19961 3F00              ; $60 - Character: '  '        CHR$(96)
19962 3F00
19963 3F00 00                   DEFB    %00000000
19964 3F01 1C                   DEFB    %00011100
19965 3F02 22                   DEFB    %00100010
19966 3F03 78                   DEFB    %01111000
19967 3F04 20                   DEFB    %00100000
19968 3F05 20                   DEFB    %00100000
19969 3F06 7E                   DEFB    %01111110
19970 3F07 00                   DEFB    %00000000
19971 3F08
19972 3F08              ; $61 - Character: 'a'          CHR$(97)
19973 3F08
19974 3F08 00                   DEFB    %00000000
19975 3F09 00                   DEFB    %00000000
19976 3F0A 38                   DEFB    %00111000
19977 3F0B 04                   DEFB    %00000100
19978 3F0C 3C                   DEFB    %00111100
19979 3F0D 44                   DEFB    %01000100
19980 3F0E 3C                   DEFB    %00111100
19981 3F0F 00                   DEFB    %00000000
19982 3F10
19983 3F10              ; $62 - Character: 'b'          CHR$(98)
19984 3F10
19985 3F10 00                   DEFB    %00000000
19986 3F11 20                   DEFB    %00100000
19987 3F12 20                   DEFB    %00100000
19988 3F13 3C                   DEFB    %00111100
19989 3F14 22                   DEFB    %00100010
19990 3F15 22                   DEFB    %00100010
19991 3F16 3C                   DEFB    %00111100
19992 3F17 00                   DEFB    %00000000
19993 3F18
19994 3F18              ; $63 - Character: 'c'          CHR$(99)
19995 3F18
19996 3F18 00                   DEFB    %00000000
19997 3F19 00                   DEFB    %00000000
19998 3F1A 1C                   DEFB    %00011100
19999 3F1B 20                   DEFB    %00100000
20000 3F1C 20                   DEFB    %00100000
20001 3F1D 20                   DEFB    %00100000
20002 3F1E 1C                   DEFB    %00011100
20003 3F1F 00                   DEFB    %00000000
20004 3F20
20005 3F20              ; $64 - Character: 'd'          CHR$(100)
20006 3F20
20007 3F20 00                   DEFB    %00000000
20008 3F21 04                   DEFB    %00000100
20009 3F22 04                   DEFB    %00000100
20010 3F23 3C                   DEFB    %00111100
20011 3F24 44                   DEFB    %01000100
20012 3F25 44                   DEFB    %01000100
20013 3F26 3C                   DEFB    %00111100
20014 3F27 00                   DEFB    %00000000
20015 3F28
20016 3F28              ; $65 - Character: 'e'          CHR$(101)
20017 3F28
20018 3F28 00                   DEFB    %00000000
20019 3F29 00                   DEFB    %00000000
20020 3F2A 38                   DEFB    %00111000
20021 3F2B 44                   DEFB    %01000100
20022 3F2C 78                   DEFB    %01111000
20023 3F2D 40                   DEFB    %01000000
20024 3F2E 3C                   DEFB    %00111100
20025 3F2F 00                   DEFB    %00000000
20026 3F30
20027 3F30              ; $66 - Character: 'f'          CHR$(102)
20028 3F30
20029 3F30 00                   DEFB    %00000000
20030 3F31 0C                   DEFB    %00001100
20031 3F32 10                   DEFB    %00010000
20032 3F33 18                   DEFB    %00011000
20033 3F34 10                   DEFB    %00010000
20034 3F35 10                   DEFB    %00010000
20035 3F36 10                   DEFB    %00010000
20036 3F37 00                   DEFB    %00000000
20037 3F38
20038 3F38              ; $67 - Character: 'g'          CHR$(103)
20039 3F38
20040 3F38 00                   DEFB    %00000000
20041 3F39 00                   DEFB    %00000000
20042 3F3A 3C                   DEFB    %00111100
20043 3F3B 44                   DEFB    %01000100
20044 3F3C 44                   DEFB    %01000100
20045 3F3D 3C                   DEFB    %00111100
20046 3F3E 04                   DEFB    %00000100
20047 3F3F 38                   DEFB    %00111000
20048 3F40
20049 3F40              ; $68 - Character: 'h'          CHR$(104)
20050 3F40
20051 3F40 00                   DEFB    %00000000
20052 3F41 40                   DEFB    %01000000
20053 3F42 40                   DEFB    %01000000
20054 3F43 78                   DEFB    %01111000
20055 3F44 44                   DEFB    %01000100
20056 3F45 44                   DEFB    %01000100
20057 3F46 44                   DEFB    %01000100
20058 3F47 00                   DEFB    %00000000
20059 3F48
20060 3F48              ; $69 - Character: 'i'          CHR$(105)
20061 3F48
20062 3F48 00                   DEFB    %00000000
20063 3F49 10                   DEFB    %00010000
20064 3F4A 00                   DEFB    %00000000
20065 3F4B 30                   DEFB    %00110000
20066 3F4C 10                   DEFB    %00010000
20067 3F4D 10                   DEFB    %00010000
20068 3F4E 38                   DEFB    %00111000
20069 3F4F 00                   DEFB    %00000000
20070 3F50
20071 3F50              ; $6A - Character: 'j'          CHR$(106)
20072 3F50
20073 3F50 00                   DEFB    %00000000
20074 3F51 04                   DEFB    %00000100
20075 3F52 00                   DEFB    %00000000
20076 3F53 04                   DEFB    %00000100
20077 3F54 04                   DEFB    %00000100
20078 3F55 04                   DEFB    %00000100
20079 3F56 24                   DEFB    %00100100
20080 3F57 18                   DEFB    %00011000
20081 3F58
20082 3F58              ; $6B - Character: 'k'          CHR$(107)
20083 3F58
20084 3F58 00                   DEFB    %00000000
20085 3F59 20                   DEFB    %00100000
20086 3F5A 28                   DEFB    %00101000
20087 3F5B 30                   DEFB    %00110000
20088 3F5C 30                   DEFB    %00110000
20089 3F5D 28                   DEFB    %00101000
20090 3F5E 24                   DEFB    %00100100
20091 3F5F 00                   DEFB    %00000000
20092 3F60
20093 3F60              ; $6C - Character: 'l'          CHR$(108)
20094 3F60
20095 3F60 00                   DEFB    %00000000
20096 3F61 10                   DEFB    %00010000
20097 3F62 10                   DEFB    %00010000
20098 3F63 10                   DEFB    %00010000
20099 3F64 10                   DEFB    %00010000
20100 3F65 10                   DEFB    %00010000
20101 3F66 0C                   DEFB    %00001100
20102 3F67 00                   DEFB    %00000000
20103 3F68
20104 3F68              ; $6D - Character: 'm'          CHR$(109)
20105 3F68
20106 3F68 00                   DEFB    %00000000
20107 3F69 00                   DEFB    %00000000
20108 3F6A 68                   DEFB    %01101000
20109 3F6B 54                   DEFB    %01010100
20110 3F6C 54                   DEFB    %01010100
20111 3F6D 54                   DEFB    %01010100
20112 3F6E 54                   DEFB    %01010100
20113 3F6F 00                   DEFB    %00000000
20114 3F70
20115 3F70              ; $6E - Character: 'n'          CHR$(110)
20116 3F70
20117 3F70 00                   DEFB    %00000000
20118 3F71 00                   DEFB    %00000000
20119 3F72 78                   DEFB    %01111000
20120 3F73 44                   DEFB    %01000100
20121 3F74 44                   DEFB    %01000100
20122 3F75 44                   DEFB    %01000100
20123 3F76 44                   DEFB    %01000100
20124 3F77 00                   DEFB    %00000000
20125 3F78
20126 3F78              ; $6F - Character: 'o'          CHR$(111)
20127 3F78
20128 3F78 00                   DEFB    %00000000
20129 3F79 00                   DEFB    %00000000
20130 3F7A 38                   DEFB    %00111000
20131 3F7B 44                   DEFB    %01000100
20132 3F7C 44                   DEFB    %01000100
20133 3F7D 44                   DEFB    %01000100
20134 3F7E 38                   DEFB    %00111000
20135 3F7F 00                   DEFB    %00000000
20136 3F80
20137 3F80              ; $70 - Character: 'p'          CHR$(112)
20138 3F80
20139 3F80 00                   DEFB    %00000000
20140 3F81 00                   DEFB    %00000000
20141 3F82 78                   DEFB    %01111000
20142 3F83 44                   DEFB    %01000100
20143 3F84 44                   DEFB    %01000100
20144 3F85 78                   DEFB    %01111000
20145 3F86 40                   DEFB    %01000000
20146 3F87 40                   DEFB    %01000000
20147 3F88
20148 3F88              ; $71 - Character: 'q'          CHR$(113)
20149 3F88
20150 3F88 00                   DEFB    %00000000
20151 3F89 00                   DEFB    %00000000
20152 3F8A 3C                   DEFB    %00111100
20153 3F8B 44                   DEFB    %01000100
20154 3F8C 44                   DEFB    %01000100
20155 3F8D 3C                   DEFB    %00111100
20156 3F8E 04                   DEFB    %00000100
20157 3F8F 06                   DEFB    %00000110
20158 3F90
20159 3F90              ; $72 - Character: 'r'          CHR$(114)
20160 3F90
20161 3F90 00                   DEFB    %00000000
20162 3F91 00                   DEFB    %00000000
20163 3F92 1C                   DEFB    %00011100
20164 3F93 20                   DEFB    %00100000
20165 3F94 20                   DEFB    %00100000
20166 3F95 20                   DEFB    %00100000
20167 3F96 20                   DEFB    %00100000
20168 3F97 00                   DEFB    %00000000
20169 3F98
20170 3F98              ; $73 - Character: 's'          CHR$(115)
20171 3F98
20172 3F98 00                   DEFB    %00000000
20173 3F99 00                   DEFB    %00000000
20174 3F9A 38                   DEFB    %00111000
20175 3F9B 40                   DEFB    %01000000
20176 3F9C 38                   DEFB    %00111000
20177 3F9D 04                   DEFB    %00000100
20178 3F9E 78                   DEFB    %01111000
20179 3F9F 00                   DEFB    %00000000
20180 3FA0
20181 3FA0              ; $74 - Character: 't'          CHR$(116)
20182 3FA0
20183 3FA0 00                   DEFB    %00000000
20184 3FA1 10                   DEFB    %00010000
20185 3FA2 38                   DEFB    %00111000
20186 3FA3 10                   DEFB    %00010000
20187 3FA4 10                   DEFB    %00010000
20188 3FA5 10                   DEFB    %00010000
20189 3FA6 0C                   DEFB    %00001100
20190 3FA7 00                   DEFB    %00000000
20191 3FA8
20192 3FA8              ; $75 - Character: 'u'          CHR$(117)
20193 3FA8
20194 3FA8 00                   DEFB    %00000000
20195 3FA9 00                   DEFB    %00000000
20196 3FAA 44                   DEFB    %01000100
20197 3FAB 44                   DEFB    %01000100
20198 3FAC 44                   DEFB    %01000100
20199 3FAD 44                   DEFB    %01000100
20200 3FAE 38                   DEFB    %00111000
20201 3FAF 00                   DEFB    %00000000
20202 3FB0
20203 3FB0              ; $76 - Character: 'v'          CHR$(118)
20204 3FB0
20205 3FB0 00                   DEFB    %00000000
20206 3FB1 00                   DEFB    %00000000
20207 3FB2 44                   DEFB    %01000100
20208 3FB3 44                   DEFB    %01000100
20209 3FB4 28                   DEFB    %00101000
20210 3FB5 28                   DEFB    %00101000
20211 3FB6 10                   DEFB    %00010000
20212 3FB7 00                   DEFB    %00000000
20213 3FB8
20214 3FB8              ; $77 - Character: 'w'          CHR$(119)
20215 3FB8
20216 3FB8 00                   DEFB    %00000000
20217 3FB9 00                   DEFB    %00000000
20218 3FBA 44                   DEFB    %01000100
20219 3FBB 54                   DEFB    %01010100
20220 3FBC 54                   DEFB    %01010100
20221 3FBD 54                   DEFB    %01010100
20222 3FBE 28                   DEFB    %00101000
20223 3FBF 00                   DEFB    %00000000
20224 3FC0
20225 3FC0              ; $78 - Character: 'x'          CHR$(120)
20226 3FC0
20227 3FC0 00                   DEFB    %00000000
20228 3FC1 00                   DEFB    %00000000
20229 3FC2 44                   DEFB    %01000100
20230 3FC3 28                   DEFB    %00101000
20231 3FC4 10                   DEFB    %00010000
20232 3FC5 28                   DEFB    %00101000
20233 3FC6 44                   DEFB    %01000100
20234 3FC7 00                   DEFB    %00000000
20235 3FC8
20236 3FC8              ; $79 - Character: 'y'          CHR$(121)
20237 3FC8
20238 3FC8 00                   DEFB    %00000000
20239 3FC9 00                   DEFB    %00000000
20240 3FCA 44                   DEFB    %01000100
20241 3FCB 44                   DEFB    %01000100
20242 3FCC 44                   DEFB    %01000100
20243 3FCD 3C                   DEFB    %00111100
20244 3FCE 04                   DEFB    %00000100
20245 3FCF 38                   DEFB    %00111000
20246 3FD0
20247 3FD0              ; $7A - Character: 'z'          CHR$(122)
20248 3FD0
20249 3FD0 00                   DEFB    %00000000
20250 3FD1 00                   DEFB    %00000000
20251 3FD2 7C                   DEFB    %01111100
20252 3FD3 08                   DEFB    %00001000
20253 3FD4 10                   DEFB    %00010000
20254 3FD5 20                   DEFB    %00100000
20255 3FD6 7C                   DEFB    %01111100
20256 3FD7 00                   DEFB    %00000000
20257 3FD8
20258 3FD8              ; $7B - Character: '{'          CHR$(123)
20259 3FD8
20260 3FD8 00                   DEFB    %00000000
20261 3FD9 0E                   DEFB    %00001110
20262 3FDA 08                   DEFB    %00001000
20263 3FDB 30                   DEFB    %00110000
20264 3FDC 08                   DEFB    %00001000
20265 3FDD 08                   DEFB    %00001000
20266 3FDE 0E                   DEFB    %00001110
20267 3FDF 00                   DEFB    %00000000
20268 3FE0
20269 3FE0              ; $7C - Character: '|'          CHR$(124)
20270 3FE0
20271 3FE0 00                   DEFB    %00000000
20272 3FE1 08                   DEFB    %00001000
20273 3FE2 08                   DEFB    %00001000
20274 3FE3 08                   DEFB    %00001000
20275 3FE4 08                   DEFB    %00001000
20276 3FE5 08                   DEFB    %00001000
20277 3FE6 08                   DEFB    %00001000
20278 3FE7 00                   DEFB    %00000000
20279 3FE8
20280 3FE8              ; $7D - Character: '}'          CHR$(125)
20281 3FE8
20282 3FE8 00                   DEFB    %00000000
20283 3FE9 70                   DEFB    %01110000
20284 3FEA 10                   DEFB    %00010000
20285 3FEB 0C                   DEFB    %00001100
20286 3FEC 10                   DEFB    %00010000
20287 3FED 10                   DEFB    %00010000
20288 3FEE 70                   DEFB    %01110000
20289 3FEF 00                   DEFB    %00000000
20290 3FF0
20291 3FF0              ; $7E - Character: '~'          CHR$(126)
20292 3FF0
20293 3FF0 00                   DEFB    %00000000
20294 3FF1 14                   DEFB    %00010100
20295 3FF2 28                   DEFB    %00101000
20296 3FF3 00                   DEFB    %00000000
20297 3FF4 00                   DEFB    %00000000
20298 3FF5 00                   DEFB    %00000000
20299 3FF6 00                   DEFB    %00000000
20300 3FF7 00                   DEFB    %00000000
20301 3FF8
20302 3FF8              ; $7F - Character: '  '        CHR$(127)
20303 3FF8
20304 3FF8 3C                   DEFB    %00111100
20305 3FF9 42                   DEFB    %01000010
20306 3FFA 99                   DEFB    %10011001
20307 3FFB A1                   DEFB    %10100001
20308 3FFC A1                   DEFB    %10100001
20309 3FFD 99                   DEFB    %10011001
20310 3FFE 42                   DEFB    %01000010
20311 3FFF 3C                   DEFB    %00111100
20312 4000
20313 4000
spectrum_rom.asm(20314): error: Invalid labelname: #end
20314 4000              #end                            ; generic cross-assembler directive
20315 4000
20316 4000              ; Acknowledgements
20317 4000              ; -----------------
20318 4000              ; Sean Irvine               for default list of section headings
20319 4000              ; Dr. Ian Logan             for labels and functional disassembly.
20320 4000              ; Dr. Frank O'Hara          for labels and functional disassembly.
20321 4000              ;
20322 4000              ; Credits
20323 4000              ; -------
20324 4000              ; Alex Pallero Gonzales     for corrections.
20325 4000              ; Mike Dailly               for comments.
20326 4000              ; Alvin Albrecht            for comments.
20327 4000              ; Andy Styles               for full relocatability implementation and testing.                    testing.
20328 4000              ; Andrew Owen               for ZASM compatibility and format improvements.
20329 4000
20330 4000              ;   For other assemblers you may have to add directives like these near the
20331 4000              ;   beginning - see accompanying documentation.
20332 4000              ;   ZASM (MacOs) cross-assembler directives. (uncomment by removing ';' )
20333 4000              ;   #target rom           ; declare target file format as binary.
20334 4000              ;   #code   0,$4000       ; declare code segment.
20335 4000              ;   Also see notes at Address Labels 0609 and 1CA5 if your assembler has
20336 4000              ;   trouble with expressions.
20337 4000              ;
20338 4000              ;   Note. The Sinclair Interface 1 ROM written by Dr. Ian Logan and Martin
20339 4000              ;   Brennan calls numerous routines in this ROM.
20340 4000              ;   Non-standard entry points have a label beginning with X.
20341 4000
# file closed: spectrum_rom.asm
